<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics.Net</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.ILArray`1">
            <summary>
            Main rectangular generic array type. Objects of this class are able to build references.
            </summary>
            <typeparam name="BaseT">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks>This class serves as the main rectangular array, holding arbitrary elements 
            in arbitrary dimensions. The most common manifestation will be a numeric array of arbitrary size. 
            <para>The most significant property of the ILArray is its ability to create, hold and handle references to other 
            ILArrays. Those references act like a solid array to the outside world but consume only a very small amount of 
            memory themselves. Therefore they directly use the elements of the original array for computations and only 
            store access rules in a very economical yet performant way. Write access to any such arrays is 
            controlled by internal reference counting. The references are detached accordingly. Detaching behavior 
            may also be adjusted in a flexible way by the library user by appropriately setting the 
            <see cref="T:ILNumerics.ILDetachingBehavior">ILDetachingBehavior</see> property. </para>
            <para>The inner type of the elements (specified through the generic parameter BaseT)
            does not change the general behavior of the ILArray<![CDATA[<>]]>. However, regarding mathematical operations, 
            there are a limited number of inner types that common mathematical functions and operators are defined for. All basic 
            operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are defined for all ILArrays having 
            the inner type BaseT of a numeric type (system defined like 'double','int' - or complex, fcomplex).
            Some functions are defined for even fewer types. This is the case mostly for linear algebraic functions 
            explicitly involving matrices or vectors (LAPACK) and for trigonometric functions and those, 
            which explicitly return floating point values (cos, atan etc.). Therefore you may create ILArrays 
            of arbitrary types, but might not be able to use them afterwards other than by applying the
            operations defined for all ILArrays - regardless of the inner type - like concatenation, (de)serialization and 
            string export.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILBaseArray"/>
        </member>
        <member name="T:ILNumerics.ILBaseArray`1">
            <summary>
            Typed base class for all ILNumerics.Net data storage classes for any storage type. 
            </summary>
            <remarks><para>You should not use this type directly. It serves as a base class 
            for all typed storages only and will be used by derived classes like ILArray<![CDATA[<>]]>.</para>
            <para>If you are looking for an (untyped) base class to be used as generic class for any ILArray types, you should use ILBaseArray instead!</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILBaseArray">
            <summary>
            The base type for all the array datatypes of ILNumerics.Net.
            </summary>
            <remarks>All numerical arrays must derive from ILBaseArray. ILBaseArrays itself 
            cannot be instantiated. Currently, only ILArray<![CDATA[<>]]> exist, which describe 
            a rectangular array as full (solid) or referencing array. There are plans to 
            extend the collection of derived types to encompass triangular and sparse arrays. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Single)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;float>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;complex></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.fcomplex)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;fcomplex></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Int16)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;Int16></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Int32)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;Int32></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Int32[])~ILNumerics.ILBaseArray">
            <summary>
            Cast system array to ILBaseArray.
            </summary>
            <param name="input">System array type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be of type ILArray&lt;Int32>.
            <para>If input is null or empty, an empty ILArray will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Int64)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;Int64>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.UInt16)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;UInt16>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.UInt32)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;UInt32>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.UInt64)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;UInt64>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Char)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;char>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Byte)~ILNumerics.ILBaseArray">
            <summary>
            Cast scalar to ILBaseArray.
            </summary>
            <param name="input">System value type.</param>
            <returns>ILBaseArray.</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;byte>.</remarks>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_name">
            <summary>
            Name of this object.
            </summary>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_dimensions">
            <summary>
            Dimension specification for this storage object.
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray.CreateReference">
            <summary>
            Create referencing copy of this array.
            </summary>
            <returns>Referencing copy of this ILArray.</returns>
            <remarks>This function is mainly needed for ILCell. Elements of ILCells returned must be 
            detached from their originals in order not to overwrite them on write access. Since ILCell 
            may store any type of array (ILBaseArray) and the actual type is not known, ILBaseArrays 
            must be capable of creating a copy of themselves. For generic ILArrays this is done in the 
            <see cref="M:ILNumerics.ILArray`1.CreateReference"/> class. </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ValuesToString(System.Int32)">
            <summary>
            Convert values of elements into a string representation.
            </summary>
            <param name="maxLength">0: all columns will be printed behind each other. 
            Other than 0: the columns will be split after 'maxLength' characters.</param>
            <returns>Formateed string representation.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Print values of this instance to a stream. 
            </summary>
            <param name="outStream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Name">
            <summary>
            Set / Get name for this object.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Dimensions">
            <summary>
            Dimension for this storage. 
            </summary>
            <value>This is a read only property. Only derived types are allowed to alter the dimensions object directly.</value>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Length">
            <summary>
            Length of the longest dimension of this instance.
            </summary>
            <remarks>This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsScalar">
            <summary>
            Determine if this instance is a scalar.
            </summary>
            <remarks>This attribute is readonly. It returns: Dimension.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsMatrix">
            <summary>
            Determine if this array is a matrix.
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsVector">
            <summary>
            Determine if this array is a vector.
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsRowVector">
            <summary>
            Test if this array instance is a row vector.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsColumnVector">
            <summary>
            Test if this array instance is a column vector.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsEmpty">
            <summary>
            True if array is empty (number of elements stored is 0).
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsComplex">
            <summary>
            Determine if this array is of complex inner type.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsNumeric">
            <summary>
            Determine if this array is of numeric inner type.
            </summary>
        </member>
        <member name="F:ILNumerics.ILBaseArray`1.m_data">
            <summary>
            The actual storage array. 
            </summary>
            <remarks>The derived type is responsible for the implementation, the way in which 
            the storage is used. So far, this is only an 1D-System.Array of arbitrary size 
            and type. This is hidden for framework users since direct public access 
            to the storage is not intended for public users.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.ShiftDimensions(System.Int32)">
            <summary>
            Create shifted version of this array.
            </summary>
            <param name="shift">Number of dimensions to shift.</param>
            <returns>ILBaseArray which is a shifted version of this ILBaseArray.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray of this array and dimension shift
            </summary>
            <param name="range">Arrays specifying the ranges to create subarray from.</param>
            <param name="shift">Number of dimensions to shift the result.</param>
            <returns>Shifted subarray as specified.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray of this array,
            </summary>
            <param name="range">Arrays specifying the ranges from which to create subarray.</param>
            <returns>Subarray as specified.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray of this array and dimension shift.
            </summary>
            <param name="range">Strings specifying the ranges from which to create subarray.</param>
            <param name="shift">Number of dimensions to shift the result.</param>
            <returns>Shifted subarray as specified.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.String[])">
            <summary>
            Subarray of this array.
            </summary>
            <param name="range">Strings specifying the ranges from which to create subarray.</param>
            <returns>Subarray as specified.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter values specified by range.
            </summary>
            <param name="range">
            ILRange specifying the dimensions / indices to alter.
            </param>
            <param name="values">
            ILArray holding the new values.
            </param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            coming from vals. If the underlying 
            ILArray pointed to by vals is of another size than that specified 
            by range, only a part of the vals-storaged will be used or respectivly 
            those values will repeatedly be inserted. One may use this as a 
            feature for filling the range with a sequence of values repeatedly. 
            On the other hand this may cause the problem of not recognizing 
            differences in the size between vals and range!
            Another remarkable situation arises, if this storage is the only 
            reference which is left to an physical storage array and it holds 
            multiple (repeated) entries to single array elements. Due to the 
            nature of a 'reference', altering any values will also update corresponding
            entries in the reference storage, pointing to the same underlying elements. 
            (in fact, those corresponding values will only point to the updated 
            elements also). Keep in mind that setting a range for a reference which 
            is connected to an array which is referenced by more than one storage, will 
            usually lead to a Detach() process - therefore the storage is disconnected 
            and the behavior described will not occur. Since for the user the result 
            is not transparent, consider either:
            <list type="bullet">
            <item>
            Checking the state of the storage before calling SetRange()</item>
            <item>Detach() the storage manually, if required, or</item>
            <item>Set the static flag DetachReferences to true to detach all reference storages 
            automatically before altering any values on it.</item></list> However there might be 
            situations, where one may want to alter many values by altering only 
            one. Therefore the above mentioned flag might be set to true if needed. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">Sysem.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize / restore ILArray from binary stream 'inStream'
            </summary>
            <param name="inStream">System.IO.Stream to reconstruct the 
            ILArray from</param>
            <returns><![CDATA[ILArray<BaseT>]]> reconstructed from Stream. If 
            the ILArray could not get restored, an SerializationException 
            will be thrown.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.CreateIterator">
            <summary>
            Create iterator for the elements of the current instance of ILBaseArray.
            </summary>
            <returns>Iterator of the same type as the current instance of ILBaseArray, initialized 
            to the first element, ready for counting forwards on 
            the first dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.CreateIterator(ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            Create iterator for the elements of the current instance of ILBaseArray, specify start 
            element and dimension to walk along.
            </summary>
            <param name="pos">Start position. One of the ILIteratorPositions: 
            ILStart, ILMiddle, ILEnd.</param>
            <param name="leadingDimension">The dimension index to walk along.</param>
            <returns>Iterator of the same type as the current instance of ILBaseArray.
            </returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value. This can be a comma seperated list 
            or a System.Array.</param>
            <returns>Object on the position pointed to by idx</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified.
            </summary>
            <param name="value">new value</param>
            <param name="idx">index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Clone">
            <summary>
            Create full (shallow) copy of this storage. 
            </summary>
            <returns>ILArray as new (physical) representation of this storages data.</returns>
            <remarks>The ILArray object returned will be of the same size than this object.
            Keep in mind, no reference counters are altered! The new object is just a plain 
            copy of the old one which remains unchanged. Also: "copy" means, the m_data array
            will be copied, but (of course) not (!) the objects referenced by the array elements!
            Therefore this is a 'shallow' copy only! This is necessary, since objects stored inside
            ILArray do not have any restrictions. (Especially they do not have to support the IClonable()
            interface.) </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetEnumerator">
            <summary>
            Create enumerator returning scalar <![CDATA[ILArray<BaseT>]]>.
            </summary>
            <returns>Enumerator.</returns>
            <remarks>This makes objects of type <![CDATA[ILBaseArray<BaseT>]]> usable in a foreach loop.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Create enumerator.
            </summary>
            <returns>Generic enumerator of inner base type as IEnumerator interface.</returns>
            <remarks>This makes objects of type <![CDATA[ILBaseArray<BaseT>]]> usable in a foreach loop.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Iterator(System.Int32)">
            <summary>
            Create enumerator capable of walking along arbitrary dimensions. 
            </summary>
            <param name="leaddim">Leading dimension.</param>
            <returns>Enumerator of inner base type.</returns>
            <remarks>This makes the return value usable in a foreach loop.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.InternalArray4Experts">
            <summary>
            Get a reference to the internal element storage array (CAUTION! Experts only!).
            </summary>
            <remarks>Use this at your own risk and only if you have expert knowledge of the internals of ILArrays!</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is stated to be 'numeric' as long as its inner type is one of the 
            following: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.Values">
            <summary>
            Create enumerator returning elements of inner base type.
            </summary>
            <value>Enumerator walking along the first dimension.</value>
            <remarks>This makes the return value usable in a foreach loop.</remarks>
        </member>
        <member name="F:ILNumerics.ILArray`1.References">
            <summary>
            reference counter
            </summary>
            <remarks><para>The member counts the references connected to any internal array
            based on the hash code of the storage array. The systems hash code 
            for the array is used as key. Upon creation of any ILArray object
            the array is placed as new entry into the dictionary with its hash code as 
            key. Upon creation of any references the value is beeing increased. At 
            finalization time and on detaching as well as on calling the Dispose() member the value gets decreased. </para>
            <para> This reference counter is mainly used for determining the writable state 
            of the storage. A storage is writable (sets IsReadonly == false), if exactly 
            one reference to it exist. </para>
            </remarks>
        </member>
        <member name="F:ILNumerics.ILArray`1.DetachReferences">
            <summary>
            Sets the detaching bahavior for referencing storages of this type
            </summary>
            <remarks> 
            This flag controls, how ILArray objects react on write access.
            Possible values are one of the enum values of ILArray.DetachingBehavior:
            <list>
            <item>
            DetachNever - if used, ILArray's will never automatically detach. This can 
            lead to situations, where altering the elements of one storage also change 
            the elements of another storage, if the second is referencing the same physical
            storage array elements. 
            </item>
            <item>
            DetachOnWrite (default) - Referencing storages will automatically detach 
            themself before attempting to alter any values used. The results are self 
            dereferencing storages which act to the outside world, like they would 
            all consist out of physical storages, but internally save memory by not creating 
            any real copies of arrays as long as it is not neccessary. 
            </item>
            <item>
            DetachAlways - Attempts to create a reference of an existing storage will result 
            in copying the values. This is the way other mathematical engines handle 
            their storages (f.e. Matlab). It consumes more memory, but will most probably 
            lead to increased performance for large computations, since physical storages
            are optimized for faster element access.
            </item>
            <item>DetachSave - This value acts like 'DetachOnWrite' except a storage will not 
            be detached, if it is the only reference to the underlying physical storage. 
            </item>
            </list>
            Special attention is to be made for altering ranges on reference storages. There are 
            cases where setting a value may alter other elements as well. this is true
            for elements "pointing" to the same physical array element. If you dont agree with 
            that behavior, set this switch to 'DetachAlways' so you wont have to worry about 
            storages beeing references anymore. This behavior may be known as similar 
            to other mathematical engines (like Matlab f.e.).
            
            This flag is set to the global value in the ILSettings class, which points to 'DetachOnWrite' by default.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.IncreaseReference">
            <summary>
            Increase reference counter for the key (hash code)
            </summary>
        </member>
        <member name="M:ILNumerics.ILArray`1.DecreaseReference">
            <summary>
            Decrease reference counter for this array
            </summary>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetNumberOfReferences">
            <summary>
            query number of references for the current instance of ILArray
            </summary>
            <returns>Number of object pointing to the current instance.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetNumberOfReferences(`0[])">
            <summary>
            query number of references for a specific array
            </summary>
            <returns>number of objects pointing to an ILArray's storage.</returns>
            <param name="data">storage array for an ILArray</param>
            <returns>Number of references currently existing for this array</returns>
            <remarks>This function is for internal useage only and is not intended to 
            be used directly! Use <see cref="M:ILNumerics.ILArray`1.GetNumberOfReferences"/> instead!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.IsReadonly">
            <summary>
            Returns true if this object cannot be altered without detaching
            </summary>
            <returns>
            True if elements of this storage cannot be altered without detaching, false 
            if they can be written.
            </returns>
            <remarks>
            <para>Upon creation every ILArray starts with a reference counter 
            value of 1. This is due to the physical storage will always lay within 
            its own ILArray container. Therfore it is writeable by that container. 
            If another reference was created, the reference counter will be increased, 
            marking the storage as readonly. If one of the objects (ILArray container 
            or referencing storage) is beeing detached, the storage becomes writable 
            again. In this situation, even a reference storage may alter the values 
            of the underlying solid ILArray.</para> 
            <para>Usually you dont have to handle with 
            the reference counter. It is managed automatically. This member is queried 
            by all functions attempting write access to an storage due to decide, if 
            the storage to write to must be detached before writing to it.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            Create ILArray of specified size and type
            </summary>
            <param name="size">
            Variable length integer array specifying the number and size of dimensions 
            to be created.
            </param>
            <param name="data">preallocated array with data. The array will
            directly be used for storage. No copy will be done.</param>
            <remarks>The size parameter may not be null or empty! 
            An exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified type and 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.Misc.ILDimension)">
            <summary>
            Create ILArray of specified size and type
            </summary>
            <param name="data">preallocated array with data. The array will
            directly be used for storage. No copy will be done.</param>
            <param name="dimensions">
            dimension specification. The ILDimension given must not be null and will 
            directly be used for the new object! No copy will be made for it!
            </param>
            <remarks>The size parameter may not be null or empty! 
            An exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified type and 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(System.Int32[])">
            <summary>
            	Create ILArray of type object and given name and size 
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions 
            to be created.
            </param>
            <remarks>The size parameter may not be null or an empty array! 
            An Exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILArray{`0})">
            <summary>
            'Copy' Constructor. Creates a new ILArray as exact copy of input array
            </summary>
            <param name="inp">
            ILArray object to create a copy from
            </param>
            <remarks>
            <para>
            The ILArray given will be copied and the reference counter will get increased. The resulting 
            new ILArray will be an exact - but shallow - copy of inp. 
            Use this constructor only for casting purposes! For copy/clone operations 
            use the Subarray/CreateReference/Copy/Clone functions or the index access instead!</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.MarshalCopy(ILNumerics.ILArray{`0})">
            <summary>
            implicit copy constructor
            </summary>
            <param name="inp">ILArray to be copied</param>
            <remarks>This is used in C++ derivate as assignment operator</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[])">
            <summary>
            create scalar or row vector from values explitely given
            </summary>
            <param name="vector_elements">elements. </param>
            <remarks><para>The elements may are given as comma seperated list or as predefined System.Array 
            of type 'BaseT'. In this case the System.Array object given will directly be used as storage 
            for the newly created ILArray.</para>
            <para>If vector_elements is null, an empty ILArray will be created.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor">
            <summary>
            Standard constructor creating empty ILArray
            </summary>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILArray{`0},ILNumerics.Storage.ILIndexOffset)">
            <summary>
            Constructor creating referencing ILArray object from ILIndexOffset object
            and source storage.
            </summary>
            <param name="storage">
            ILArray as source for the reference storage. Holds the physical
            data or the source for the reference (i.e. existing storage).
            </param>
            <param name="idxOffset">
            ILIndexOffset object holding indices with destination index for each 
            dimension or null for referencing full storage.
            </param>
            <remarks>
            Any dimensions shifts must be implicitly be reflected by the 
            idxOffset parameter. The dimensions of the resulting reference storage will 
            directly be derived from the idxOffset parameter (if it is not null !). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Finalize">
            <summary>
            free storage on finalize
            </summary>
            <remarks>This will decrease the reference counter for the current m_data member 
            and mark all attribute members as null for garbage collection. <br> You should never 
            have to call any finalizing code directly unless you know, what you are doing!</br></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Dispose">
            <summary>
            Dispose this storage before garbage collection.
            </summary>
            <remarks><para>Calling Dispose should be the last method called for an ILArray. 
            The storage referenced by this object will be released in the next GC run. Calling 
            Dispose() will increase performance of your application, since disposed objects 
            can faster get cleaned up by the GC. However, if this method is not called for an 
            object, the garbage collector finalization queue will call it for you.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this ILArray + dimension shift
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> string specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.String[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Double})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Double})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Byte})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Byte})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Char})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Char})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.UInt64})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.UInt64})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.UInt32})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.UInt32})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.UInt16})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.UInt16})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Int64})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Int64})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Int32})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Int32})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Int16})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Int16})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Single})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequential(ILNumerics.ILArray{System.Single})">
            <summary>
            create physical subarray from this referencing array
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceSequentialShifted(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            create physical subarray from this referencing array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReference(ILNumerics.Storage.ILRange)">
            <summary>
            create physical range from reference array 
            </summary>
            <param name="range">valid range</param>
            <returns>referencing subarray</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromReferenceShifted(System.Int32,ILNumerics.Storage.ILRange)">
            <summary>
            create pyhsical array from reference array and shift dimensions 
            </summary>
            <param name="range">valid range </param>
            <param name="shift">number of dimensions to shift result</param>
            <returns>physical copy of elements adressed</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysical(ILNumerics.Storage.ILRange)">
            <summary>
            create physical subarray from physical ILArray 
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalShifted(System.Int32,ILNumerics.Storage.ILRange)">
            <summary>
            create shifted physical subarray of ILArray specified by range and shift
            </summary>
            <param name="range">must be valid range</param>
            <param name="shift">may be any integer - will be handled modulus ranges dimensions</param>
            <returns>physical array specified by range / shift</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromPhysical(ILNumerics.Storage.ILRange)">
            <summary>
            create full reference subarray if this is a physical array
            </summary>
            <param name="range">range specification - must (o.c.) be a valid range</param>
            <returns>referencing subarray with dimensions specified by range</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromReference(ILNumerics.Storage.ILRange)">
            <summary>
            full referencing subarray if this is reference array 
            </summary>
            <param name="range">range specification</param>
            <returns>referencing subarray with dimensions specified by range</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromPhysicalShifted(System.Int16,ILNumerics.Storage.ILRange)">
            <summary>
            create reference subarray if this is physical array and shift dimensions 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <param name="range">range specification</param>
            <returns>shifted reference array with size specified by range</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromReferenceShifted(System.Int16,ILNumerics.Storage.ILRange)">
            <summary>
            create reference subarray if this is reference and shift dimensions 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <param name="range">range specification</param>
            <returns>shifted reference array with size specified by range</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Double})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Byte})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Char})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.UInt64})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.UInt32})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.UInt16})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Int64})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Int32})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Int16})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequential(ILNumerics.ILArray{System.Single})">
            <summary>
            create reference from sequential indices
            </summary>
            <param name="indices">array of vector size</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceSubarrayFromArraySequentialShifted(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            create reference from sequential indices and shift dimensions
            </summary>
            <param name="indices">array of vector size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>Referencing ILArray vector pointing to this ILArray's elements</returns>
            <remarks> Make sure indices is <b>vector</b> have not more than 2 dimensions and all 
            values in indices fit inside my array! Only the first 2 dimensions 
            will be recognized! No Exception will be thrown!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalShiftedFromPhysical(System.Int32)">
            <summary>
            create physical shifted version if this is physical array 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>physical array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalShiftedFromReference(System.Int32)">
            <summary>
            create physical shifted version if this is a reference array 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>reference array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceShiftedFromPhysical(System.Int32)">
            <summary>
            create reference array by shifting its dimensions 
            </summary>
            <param name="shift">number of dimension to shift</param>
            <returns>reference array with shifted dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReferenceShiftedFromReference(System.Int32)">
            <summary>
            create reference array from full reference array by shifting dimensions 
            </summary>
            <param name="shift">number of dimensions to shift </param>
            <returns>referencing array with shifted dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Equality(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Equalty operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1">first input array</param>
            <param name="in2">second input array</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 equal in2's elements, false if they are not equal.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is valid for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException">thrown if the types 
            of input arguments do not match or the operator does not support the ILArray inner type.
            </exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Inequality(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Unequalty operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 and in2 beeing unequal, false if they are equal.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThanOrEqual(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Greater or equal operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 are greater or equal in2's elements, false else.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThanOrEqual(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            smaller or equal operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 smaller or equal in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThan(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            greater operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 greater in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThan(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            smaller operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 smaller as in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Equality(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Equalty operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Inequality(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Unequalty operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 not equal in2, false if they are equal.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThanOrEqual(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Greater or equal operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 are greater or equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThanOrEqual(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Smaller or equal operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing smaller or equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThan(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Greater operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing greater in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThan(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Smaller operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing smaller in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert scalar to ILArray of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns> New ILArray of type ILArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[])~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast 1-dim. system array to ILArray (vector)
            </summary>
            <param name="vector_elements">1d system array arbitrary type</param>
            <returns>ILArray of same type as elements - built as row vector. Empty array if input is null.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(System.Array)~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast n-dim. system array to ILArray
            </summary>
            <param name="elements">arbitrary sized System.Array</param>
            <returns>If elements is null: empty array. Else: ILArray of same size as elements</returns>
            <remarks>The inner type of input array <paramref name="elements"/> must match the requested type <typeparamref name="BaseT"/>. The resulting ILArray will reflect all dimensions of the input. Elements of input array will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match requested type BaseT</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast 2-dim. system array to ILArray
            </summary>
            <param name="elements">2D System.Array</param>
            <returns>If elements is null: empty array. Else: ILArray of same size as elements</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast 3-dim. system array to ILArray
            </summary>
            <param name="elements">3D System.Array</param>
            <returns>If elements is null: empty array. Else: ILArray of same size as elements</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Explicit(ILNumerics.ILArray{`0})~`0">
            <summary>
            Explicitly convert ILArray of size 1x1 (scalar) to system value type.
            </summary>
            <param name="val">ILArray of type ILArray <![CDATA[BaseT]]> of size 1x1</param>
            <returns> System type of size scalar holding the only element with value of val.
            </returns>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if input ILArray is not scalar</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_UnaryNegation(ILNumerics.ILArray{`0})">
            <summary>
            negate elements of array - if applicable
            </summary>
            <param name="in1">input array</param>
            <returns>new solid arrray having the elements of in1 negated</returns>
        </member>
        <member name="F:ILNumerics.ILArray`1.m_indexOffset">
            <summary>
            Index mapping for reference arrays. Null if this is not a reference but a solid array.
            </summary>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if these exist.
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(type).</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetLimits(`0@,`0@,System.Boolean)">
            <summary>
            Get minimum and maximum value of all elements - if existing
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(BaseT) then.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateReference">
            <summary>
            Create referencing copy of this array.
            </summary>
            <returns>Reference of the ILArray.</returns>
            <remarks><para>This function is mainly needed for ILCell. Elements of ILCells returned must be 
            detached from their originals in order not to overwrite them on write access. Since an ILCell 
            may store any type of array (ILBaseArrays) and the actual type is not known, ILBaseArrays 
            must be capable of creating a copy of themselves. For generic ILArrays this is done by the 
            <see cref="M:ILNumerics.ILArray`1.CreateReference"/>  member. </para>
            <para>The actual storage type of the object returned depends on the setting of the member <see cref="P:ILNumerics.ILArray`1.MinimumRefDimensions"/>. If the number 
            of dimensions of this array is larger or equal its value, the object returned will be a reference array, otherwise it will be a physical array.
            array anyway. This is especially true for scalars and vectors.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.mustDetach">
            <summary>
            Determine if the referencing ILArray must be detached before writing to it.
            </summary>
            <returns>True: the current instance must be detached before writing to it. 
            False: one may immediately write to elements of the current instance without detaching it.
            </returns>
            <remarks>
            The result depends on the static attribute DetachingBehavior.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Detach">
            <summary>
            Detach this array if it is a referencing array. Change into a solid physical copy.
            </summary>
            <remarks>If this array is a referencing array, it will 
            be detached. Therefore a (shallow) physical copy of the elements is created.
            Keep in mind, for ILArrays of base type 'object', only the references to real 
            objects are copied, not the referenced objects themselves (this is a shallow, not a deep copy!).
            If this storage is already a solid (i.e. physical) storage, the method will have no effect.
            <br>For referencing storage this will lead to a dereferencing copy. This is 
            true for solid ILArrays also. The returned object is always a solid storage. 
            Detaching an object will decrease the reference counter of the array formerly 
            referenced by it. Detach will not check if other references on the storage array exist.
            Therefore it might happen that this storage is the only reference to an storage array and 
            detaching may be unnecessary - or even worse - might increase the memory required to
            store the data (this only becomes true for referencing storages with repeated entries).
            </br></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.zeros(System.Int32[])">
            <summary>
            Create array with all elements initialized to zero.
            </summary>
            <param name="dimensions">Length of each dimension. This may be a comma separated 
            list of int values.</param>
            <returns>Solid ILArray of specified size.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.zeros(ILNumerics.Misc.ILDimension)">
            <summary>
            Create array with all elements initialized to zero.
            </summary>
            <param name="dimension">ILDimension object.</param>
            <returns>Solid ILArray of specified size.</returns>
            <remarks>The ILDimension given will be cloned before being used.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(ILNumerics.Misc.ILDimension)">
            <summary>
            Create empty array, arbitrary size
            </summary>
            <param name="dims">requested size of the array, at least one dimension in dims must be 0.</param>
            <returns>Empty ILArray.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(System.Int32[])">
            <summary>
            Create empty array, arbitrary size
            </summary>
            <param name="dims">requested size of the array, at least one dimension must be 0.</param>
            <returns>Empty ILArray.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToString">
            <summary>
            Write information about the ILArray to string.
            </summary>
            <returns>String containing general information about the current instance of 
            ILArray and the formatted elements' values.</returns>
            <remarks>If the number of elements exceeds 10000 the writing of all elements will 
            be suppressed.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToString(System.String,System.Int32)">
            <summary>
            Formatted output for the ILArray.
            </summary>
            <param name="s">
            predefined string to be appended to the output. This may be an empty String (not null!).
            </param>
            <param name="maxLength">Maxmum number of characters for the output lines.</param>
            <returns>Formatted string holding all values of this storage.
             If the number of values exceeds 10000, the number of elements 
             will be printed only.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.debuggerHeadLineDisplay">
            <summary>
            Here is defined the string displayed in the headline of the objects if displayed in variable windows.
            </summary>
            <returns>String with the headline - value depends on the size of the array.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.ValuesToString(System.Int32)">
            <summary>
            Print formatted values to string (in 'matlab style').
            </summary>
            <param name="maxLength">Maximum number of characters per line. Set 
            to 0 to entirely suppress the limit.</param>
            <returns>StringBuilder object filled with formated values.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj.
            </summary>
            <param name="obj">Typed ILArray containing the values with which to compare this array.</param>
            <returns>True if all elements contained in obj are equal to the 
            elements of this array, false otherwise.</returns>
            <remarks>This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Equals(ILNumerics.ILBaseArray{`0})">
            <summary>
            Test if this ILArray equals another ILBaseArray.
            </summary>
            <param name="obj">ILBaseArray with which to compare this ILArray.</param>
            <returns>True if all elements match, false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetHashCode">
            <summary>
            Get Hash Code of the current instance.
            </summary>
            <returns>Hash code of the current instance.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter values specified by range.
            </summary>
            <param name="range">
            ILRange specifying the dimensions/indices to be altered.
            </param>
            <param name="values">
            ILIterator initialized and pointing to the ILArray 
            holding the new values.
            </param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            found in 'values'. 
            A remarkable situation arises, if this storage is the only 
            reference which is left to an physical storage array and it holds 
            multiple (repeated) entries to single array elements. Due to the 
            nature of a 'reference', altering any values will also update corresponding
            entries in the reference storage, pointing to the same underlying elements. 
            (In fact, those corresponding values will only point to the updated 
            elements also.) Keep in mind that setting a range for a reference which 
            is connected to an array which is referenced by more than one storage, will 
            usually lead to a Detach() process - therefore the storage gets disconnected 
            and the behavior described will not happen. Since for the user the result 
            is not transparent, consider either: 
            <list type="bullet">
            <item>
            checking the state of the storage before calling SetRange() </item>
            <item>Detach() the storage manually, if required, or</item>
            <item>set the static flag ILDetachingBehavior to DetachAlways or DetachWrite (default)
            to detach all reference storages automatically before altering any values on it.</item>
            </list> 
            However there may be situations, where one may want to alter many values by changing only 
            one. Therefore the above mentioned flag might be set to true if needed. 
            <para>If range contains indices outside of the array dimensions, this array will be reshaped (expanded)
            according to those indices. However this might lead to a performance penalty;
            expanding an array by addressing indices outside of the dimensions should therefore be avoided. Consult the reference manual for hints 
            to circumvent this situation.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Double},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Byte},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Char},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.UInt64},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.UInt32},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.UInt16},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Int64},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Int32},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Int16},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Single},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ShiftDimensions(System.Int32)">
            <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            </summary>
            <param name="shift">Number of dimensions to shift the array.</param>
            <returns>Shifted ILArray of the same type.</returns>
            <remarks><para>The type of array returned will (referencing / solid) depends on the size of the array and
            the MinimumRefDimensions member. Shift is to the left.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.S(System.Int32)">
            <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            </summary>
            <param name="shift">Number of dimensions to shift the array.</param>
            <returns>Shifted ILArray of the same type.</returns>
            <remarks><para>The type of array returned will (referencing / solid) depends on the size of the array and
            the MinimumRefDimensions member. Shift is to the left.</para>
            <para>This is an alias or shortcut for <see cref="M:ILNumerics.ILArray`1.ShiftDimensions(System.Int32)"/></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetShifted(System.Int32)">
            <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            </summary>
            <param name="shiftDimensions">Number of dimensions to shift the array (to the left for positive values)</param>
            <returns>Shifted ILArray of the same type.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Reshape(ILNumerics.Misc.ILDimension)">
            <summary>
            Reshape this array.
            </summary>
            <param name="newDimensions">New dimensions of the array.</param>
            <returns>Array after reshaping.</returns>
            <remarks><para>This member changes the current array's dimensions as specified by newDimensions.</para>
            <para>If this is a reference array, it will be detached.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements do not remain the same.</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Reshape(System.Int32[])">
            <summary>
            Reshape this array.
            </summary>
            <param name="dims">New dimensions of the array.</param>
            <returns>Array after reshaping.</returns>
            <remarks><para>This member changes the current arrays dimensions as specified by newDimensions.</para>
            <para>If this is a reference array, it will be detached.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements do not remain the same.</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Concat(ILNumerics.ILArray{`0},System.Int32)">
            <summary>
            Concatenate this array. 
            </summary>
            <param name="inArray">N-dimensional array</param>
            <param name="leadDim">Index of dimension along which to concatenate the arrays.
            If leadDim is larger than the number of dimensions of one of the arrays
            its value will be used in modulus.</param>
            <returns>Array having the size of both input arrays laid beside one 
            another along the leadDims-dimension</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item>Reference storage, if inArray is the same as this array (object references 
            are the same) and ILArray.MinimumRefDimensions is less or equal 
            the number of dimensions of the resulting storage, or a 
            </item>
            <item>Physical storage otherwise. 
            </item></list>
            There are only very few cases where it is possible to reference two arrays in the 
            same reference storage. Not only must the storages point to the same underlying 
            physical System.Array, but the ILIndexOffset must be suited in a particular way. 
            Therefore the restriction was made to always create a solid storage, if 
            both storages are not the same.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Repmat(System.Int32[])">
            <summary>
            Replicate this storage to create a larger array.
            </summary>
            <param name="dims">Dimensions specifier. This may be a 
            list or an array of integer values. If the number of elements in dim is 
            less the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimensions of this array, the result 
            will have its number of dimensions extended accordingly. </param>
            <returns>Large array which is a multiple (dims) copy of this array along 
            arbitrary dimensions.</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item>Referencing array, if the number of resulting dimensions is &lt;= 
            MinimumRefDimensions, or a 
            </item>
            <item>Solid array otherwise. 
            </item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Remove(System.Int32,System.Int32[])">
            <summary>
            Remove the indices of the specified dimension from array.
            </summary>
            <param name="dimension">Index of dimension where the <c>indices</c> are located.</param>
            <param name="indices">Dimension indices to be removed.</param>
            <remarks>After processing, the indices of the dimension specified will be removed 
            from all dimensions of this ILArray. The operation is done by building a reference to the 
            existing ILArray. For the indices specified, the data 
            will be excluded. Depending on the value of the property
            ILSettings.DetachReferences, this ILArray will be left as solid array (i.e. it 
            would be explicitly detached) or left as referencing ILArray - which should be fine for 
            most situations.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.OnSerialize(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Prepare for serialization.
            </summary>
            <param name="context">Streaming Context - provided by the formatter.</param>
            <remarks>If the array is a referencing array, we save memory / traffic by eventually detaching 
            this object (by not having to store unused array element data). However the 
            serialized version will no longer reference any other arrays. It will 
            be the only instance pointing to / using the storage array.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Post operations aftre deserializing is finished.
            </summary>
            <param name="context">Streaming context provided by the formatter.</param>
            <remarks>After the storage is reconstructed, we need to register it 
            for reference counting.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Print values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.exportMatlab(System.IO.BinaryWriter,System.Single)">
            <summary>
            [deprecated] Write data of this ILArray to Matlab .mat file.
            </summary>
            <param name="fileout">Binary stream receiving the data.</param>
            <param name="version">(not used)</param>
            <remarks>This function is deprecated and will soon be removed. 
            Use <see cref="T:ILNumerics.ILMatFile"/> instead!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value.</param>
            <returns>Object in the position pointed to by idx.</returns>
            <remarks>TODO: the interna of this function should be split and seperated 
            to -> ILDimension and -> ILIndexOffset!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetValueSeq(System.Int32,System.Int32[]@)">
            <summary>
            Get single value from this storage by a single sequential access.
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value.</param>
            <param name="dims">Out value: return position mapped to dimensions.</param>
            <returns>Object in the position pointed to by idx.</returns>
            <remarks>dims is the final position into the array for the sequential index specification <c>idx</c>.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at the specified index.
            </summary>
            <param name="value">New value.</param>
            <param name="idx">Index of the element to be altered.</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.getBaseIndex(System.Int32[])">
            <summary>
            Convert index array into sequential index for storage access.
            </summary>
            <param name="idx">int array with dimensions specification.</param>
            <returns>Index of requested value inside the physical storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value return is valid for physical storages as well as for reference 
            storages.
            </returns>
            <remarks>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the behavior
            is undefined. Therefore this function should be enclosed in try, catch blocks 
            to handle this case!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.getBaseIndex(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Convert index array into sequential index for storage access. Ommit any bound checking.
            </summary>
            <param name="idx">int array with dimensions specification.</param>
            <param name="MustExpand">Output parameter. On return determine, if the index 
            specification points outside of the dimensions of this ILArray and the array 
            must be expanded before accessing elements on that position.</param>
            <param name="Dimensions">if the array was found to be expanded, this are the 
            needed dimension sizes for the new array. The sizes are computed from the range 
            specification given.</param>
            <returns>Index of requested value inside the physical storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value returned is valid for physical storages as well as for reference 
            storages.
            </returns>
            <remarks>
            <para>idx must be not null and must contain at least one element.</para>
            <para>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the index of 
            the expanded array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.getBaseIndex(System.Int32)">
            <summary>
            Convert sequential index into sequential index for physical storage access.
            </summary>
            <param name="idx">index for this storage. </param>
            <returns>Index of requested value inside the physical storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value return is valid for physical storages as well as for reference 
            storages.
            </returns>
            <remarks>Since the user normally does not know, 
            if this storage is a reference storage, this function maps the sequential index 
            of this storage to the sequential index of the underlying physical storage (if any).
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="result">System.Array, holding all element values of this ILArray.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            corresponding elements with index lower or equal to i will be overwritten. Here i is the number of elements
            contained in the ILArray. If 'result' is null or has less than i elements, it will be recreated from the ILMemeoryPool.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExtractRemovalParameter(System.Object,System.Int32@,System.Int32[]@,ILNumerics.Misc.ILDimension@)">
            <summary>
            Helper function to prepare parameters for partial removal. 
            </summary>
            <param name="range">Object with index specification. May be of 
            type ILBaseArray[] with numeric arrays or a string array according 
            to the format of <see cref="T:ILNumerics.Storage.ILRange"/>. 
            </param>
            <param name="dimensionIdx">Out parameter: number of dimension the indices to be removed lie in.</param>
            <param name="indices">Indices to be removed.</param>
            <param name="dimensions">Dimension structure, may be used if the array must be 
            reshaped <b>before</b> the removal.</param>
            <remarks>If range comprises a range specification which is smaller than 
            the actual dimension length of this array, the array must also be reshaped in order to remove 
            the data. This reshape proccess will <b>not</b> be done inside this function! However 
            the <c>dimension</c> value returned reflects the size of the array before removing and therefore
            may be used for reshaping the array.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If:<list type="bullet">
            <item>The length of range exceeds the dimensions of this array.</item>
            <item>Greater than or less than one dimension of <c>range</c> was not null.</item>
            <item>The type of range was invalid, or</item>
            <item>Range is of type array of <see cref="T:ILNumerics.ILBaseArray"/>, but the elements are non-numeric ILArrays.</item>
            </list></exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Clone">
            <summary>
            Create full (shallow) copy of this array. 
            </summary>
            <returns>ILArray with solid representation of the array data.</returns>
            <remarks>The ILArray object returned will be of the same size than this object.
            Keep in mind that no reference counters are altered! The new object is just a plain 
            copy of the old one, which remains unchanged. Also: 'copy' means, the m_data array
            will be copied, but (of course) not the objects referenced by the array elements!
            Therefore this is a 'shallow' copy only. This is necessary, since objects stored inside
            ILArray do not have any restrictions (in particular they do not have to support the IClonable()
            interface.) </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateIterator">
            <summary>
            Create iterator, initialized to run from start over the first dimension.
            </summary>
            <returns>Iterator of the same type as the current instance of ILArray, initialized 
            to the first element, ready for counting forwards on 
            the first dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateIterator(ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            Create iterator for the elements of the current instance of ILArray; specify start 
            element and dimension to walk along.
            </summary>
            <param name="pos">Start position. One of the ILIteratorPositions: 
            ILStart, ILMiddle, ILEnd.</param>
            <param name="leadingDimension">The dimension index to walk along.</param>
            <returns>Iterator of the same type as the current instance of ILArray.
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetEnumerator">
            <summary>
            Enumerator creation.
            </summary>
            <returns>Enumerator.</returns>
            <remarks>This function enables the use of ILArray inside 'foreach' constructs. It 
            will rarely be used directly.</remarks>
            <example>ILArray&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (ILArray&lt;T&gt; element in A) {
            // all 'elements are scalar ILArrays
            String.Format("Element: {0} ",element.GetValue(0));
            }
            </example>
            <seealso cref="P:ILNumerics.ILArray`1.Values"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExpandArray(ILNumerics.Storage.ILRange)">
            <summary>
            Expand this storage for addresses outside my dimensions.
            </summary>
            <param name="range">Range to fit inside destination array.</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExpandArray(System.Int32[])">
            <summary>
            Expand this storage for addressed outside my dimensions.
            </summary>
            <param name="indices">Range to fit inside destination array.</param>
            <remarks>The input parameter <c>indices</c> will directly be used to create new
            ILDimension member of the resized array.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.copyUpperTriangle(System.Int32)">
            <summary>
            Copy upper triangular part of this array into new physical array.
            </summary>
            <param name="n">Length of first dimension of destination array.</param>
            <returns>Physical array of size [n x {ThisColumnCount})].</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.copyLowerTriangle">
            <summary>
            Copy lower triangular part of this array into new physical array.
            </summary>
            <returns>Physical array of same size than this array.</returns>
            <remarks>If this is not a 2D array, only the first dimension is referenced.</remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.MinimumRefDimensions">
            <summary>
            Minimum number of dimensions for Reference storage objects.
            </summary>
            <remarks>
            This parameter influences all overloaded versions of the CreateReference members: 
            If the object requested (the reference specified by range and/or dimension shifts)
            is of less than MinimumRefDimensions non singleton dimensions, the 
            "reference" will be created as real copy, i.e. a ILFullArray an physical storage object. For 
            the defaut value of 2 this will result in an matrix object. For the current 
            implementation using referencing ILFullArray's for obejcts with less then 
            2 non singleton dimensions would be of little use, since fast indexing requires them 
            to hold a copy of all dimension specifiers for an object. Therefore they would 
            consume at least half the memory and more performance for creating them then creating a real copy 
            as physical storage. Use this parameter to make ILNumerics.Net actually create 
            <b>copies</b> and not <b>references</b> of all storage objects with non singleton 
            dimensions less then MinimumRefDimensions.
            </remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.IndexOffset">
            <summary>
            Index mapping for reference arrays. Null if this is not a reference but a solid array.
            </summary>
        </member>
        <member name="P:ILNumerics.ILArray`1.IsReference">
            <summary>
            Determine if this instance is a reference to another ILArray or 
            if it is a physical storage actually holding values itself (called a 'solid array').
            </summary>
            <return>
            True if this ILArray holds a reference storage, false otherwise.
            </return>
            <remarks>
            This parameter is readonly. It is useful for estimating the cost for 
            operation. Since referencing storages are less performant than solid arrays, this may 
            helps planning and optimizing algorithms. 
            </remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.T">
            <summary>
            Create transposed version: dimension shift of 1 dimension.
            </summary>
            <remarks>This is an alias for GetShifted(1).
            <para><c>T</c> returns an array of the same size as the original array, but 
            with the dimensions shifted by 1. This array may be a vector, matrix or N-dimensional array.</para>
            <para>For complex arrays the result will <![CDATA[<b>NOT<b/>]]> be the complex conjugate! The 
            content of this array will be copied without alteration.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.C">
            <summary>
            Create solid clone of this object.
            </summary>
            <remarks>This is a casting alias for object <![CDATA[ILArray<BaseT>.Clone()]]>.</remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.R">
            <summary>
            Create full reference of this object.
            </summary>
            <remarks>This is a casting alias for object <![CDATA[ILArray<BaseT>.CreateReference()]]>.</remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.MaxValue">
            <summary>
            Maximum of all the elements of the array (if this exists).
            </summary>
            <remarks>For reference types the original element will be returned. No copy will be made!
            <para>In order to be comparable, the inner type of this array must implement IComparable. If it does not, 
            an exception will be thrown. Note: all numeric System types do implement IComparable.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException">If the inner type BaseT cannot be compared. Inner types 
            must implement IComparable&lt;BaseT&gt; in order to compute the minimum.</exception>
        </member>
        <member name="P:ILNumerics.ILArray`1.MinValue">
            <summary>
            Minmum of all the elements of the array (if this exists).
            </summary>
            <remarks>For reference types the original element will be returned. No copy will be made!
            <para>In order to be comparable, the inner type of this array must implement IComparable. If it does not, 
            an exception will be thrown. Note: all numeric System types do implement IComparable.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException">If the inner type BaseT cannot be compared. Inner types 
            must implement IComparable&lt;BaseT&gt; in order to compute the minimum.</exception>
        </member>
        <member name="P:ILNumerics.ILArray`1.Diagonal">
            <summary>
            Get / set diagonal elements. 
            </summary>
            <value>Vector of the same length as the number of diagonal elements or scalar. If value is scalar, 
            all diagonal elements will be filled with this value.</value>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.String[])">
            <summary>
            Subarray access for get / set / removal. 
            </summary>
            <param name="range">Range specification.</param>
            <returns>Referencing array pointing to the elements of this array specified by range. If used for removal, 
            the array will be changed to a referencing array with the selected parts removed.</returns>
            <remarks>Query access: for N-dimensional arrays with at least 1 dimensions specified, missing trailing dimensions will be defaulted to 0. Therefore these 
            trailing dimensions in range may be omitted.
            <example>
            <code>Having a matrix A =     
            [0, 1, 2, 3
            4, 5, 6, 7];
            So A[":,2"] will lead to 
            [2
             6]; 
            A["1,:"] gives [4, 5, 6, 7]
            A["1"] gives [4]
            A["1,1"] gives [5]
            </code>
            </example>
            <para>The indexer may be used for querying or altering single / any elements 
            in this array. <c>range</c> may contains complex index specifications for one ... any 
            dimension. If more than one dimension is to be specified, the dimensions must be seperated 
            by ';' (semicolon).</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than ";". If <c>range</c> applies 
            to fewer dimensions than the dimensions that exist in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal.</para>
            <para>In case of removal the ILArray returned will be a referencing array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int16,System.String[])">
            <summary>
            Subarray access for ILArray with dimension shift.
            </summary>
            <paramref name="dims" value="Dimension specification."/>
            <value>Returns new ILArray as referencing subarray to this ILBaseArray.</value>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int32[])">
            <summary>
            Get / Set / Remove single element. 
            </summary>
            <param name="indices">The type of access depends on the length of the indices. 
            <list type="bullet">
            <item>If indices is a single value: sequential (linear) index of element to access.</item>
            <item>If indices.Length &gt; 1: index array access.</item></list></param>
            <returns>Scalar ILArray of same type as this array containg the accessed element.</returns>
            <remarks>If indices contains only one element, the array will be accessed via sequential index access. 
            This is sometimes alternatively called 'linear' index access. Sequential index access reflects the indexing of the internal storage: 
            the way in which the data are actually organized in memory. This access method is mainly convenient for vectors where you are not interested in orientation.
            The following example demonstrates sequential index access: 
            <example><code>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);
            A[2] gives: 3.0
            </code>But
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0</code>
            <para>For get access the array returned will be a scalar solid array.</para></example>
            <para>The reason this indexer returns an ILArray is that returning BaseT directly allows
            the use of the convenient syntax: A[2] = null; for removal! There is also the argument of consistency with the indexer.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access
            </summary>
            <param name="range">Range specification.</param>
            <returns>Referencing array pointing to the elements of this array specified by range. If used for removal, 
            the array will be changed to a referencing array with the requested parts removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be defaulted to 0. Therefore 
            these trailing dimensions may be omitted from range.
            <para>The indexer may be used for querying or altering single / any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification which is not null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to fewer dimensions than the dimensions that exist in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal.</para>
            <para>In case of removal, the ILArray returned will be a referencing array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int16,ILNumerics.ILBaseArray[])">
            <summary>
            Ranged subarray access.
            </summary>
            <param name="shiftDim">Number of dimensions to shift the result.</param>
            <param name="range">Range specification.</param>
            <returns>Referencing array pointing to the elements of this array specified by range.</returns>
            <remarks>For N-dimensional arrays, trailing dimensions will be defaulted to 0. Therefore 
            trailing dimensions may be omitted from range. However, if range contains only one array, those indices 
            are interpreted as sequential index access elements. I.e. the elements in the index vector are allowed to 
            range from 0...[NumberOfElements - 1]. A vector containing corresponding elements will be returned in this case.
            <para>The indexer may be used for querying single / any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Values">
            <summary>
            Enumerator returning elements in their natural type.
            </summary>
            <example>ILArray&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A.Values) {
            // all 'elements are scalar double values
            String.Format("Element: {0} ",element);
            }
            </example>
        </member>
        <member name="T:ILNumerics.Native.ILACML4_1">
            <summary>
            LAPACK implementation for AMD processors
            </summary>
            <remarks>By using this module, you will have to make sure,
            you placed all runtime binaries for AMD's performance library 
            into the binary output dir accessable for ILNumerics.Net assemblies. 
            Those modules must be donwloaded seperately, since it is not 
            permitted to distribute them among with LGPL code. However, 
            developing and redistributing of products with ACML is possible though. 
            AMD currently does not charge money for a redistributable 
            license, given that one signs a license agreement with AMD 
            individually.</remarks>
        </member>
        <member name="T:ILNumerics.Native.IILLapack">
            <summary>
            Interface to all LAPACK/BLAS functions available
            </summary>
            <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made virtual by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.BuiltInFunctions.ILMath">ILNumerics.BuiltInFunctions.ILMath</see>).</para>
            <para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            F.e. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para>
            <para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available in the internet: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesdd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesdd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrf(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrf(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrf(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrf(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotri(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotri(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotri(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotri(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetri(System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetri(System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetri(System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetri(System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sorgqr(System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cungqr(System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqp3(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqp3(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqp3(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.strtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ctrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="T:ILNumerics.BuiltInFunctions.ILMath">
            <summary>
            Main math class. provides all explicit static math functions 
            </summary>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorDoubleDouble(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionDoubleDouble)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[ /*!HC:outCls1*/ ILArray<double> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt64OperatorUInt64UInt64(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64},ILNumerics.BuiltInFunctions.ILMath.ILUInt64FunctionUInt64UInt64)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<UInt64> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt32OperatorUInt32UInt32(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32},ILNumerics.BuiltInFunctions.ILMath.ILUInt32FunctionUInt32UInt32)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<UInt32> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt16OperatorUInt16UInt16(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16},ILNumerics.BuiltInFunctions.ILMath.ILUInt16FunctionUInt16UInt16)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<UInt16> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int64OperatorInt64Int64(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64},ILNumerics.BuiltInFunctions.ILMath.ILInt64FunctionInt64Int64)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<Int64> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int32OperatorInt32Int32(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32},ILNumerics.BuiltInFunctions.ILMath.ILInt32FunctionInt32Int32)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<Int32> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int16OperatorInt16Int16(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16},ILNumerics.BuiltInFunctions.ILMath.ILInt16FunctionInt16Int16)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<Int16> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FloatOperatorFloatFloat(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.BuiltInFunctions.ILMath.ILFloatFunctionFloatFloat)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<float> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FcomplexOperatorFcomplexFcomplex(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.BuiltInFunctions.ILMath.ILFcomplexFunctionFcomplexFcomplex)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<fcomplex> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorComplexComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionComplexComplex)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<complex> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.CharOperatorCharChar(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char},ILNumerics.BuiltInFunctions.ILMath.ILCharFunctionCharChar)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<char> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ByteOperatorByteByte(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILByteFunctionByteByte)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<byte> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorDouble(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ /*!HC:outCls1*/ ILArray<double> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FcomplexOperatorFloat(ILNumerics.ILArray{System.Single},ILNumerics.BuiltInFunctions.ILMath.ILFcomplexFunctionFloat)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<fcomplex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorDouble(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<complex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FloatOperatorFcomplex(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.BuiltInFunctions.ILMath.ILFloatFunctionFcomplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<float> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<double> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt64OperatorUInt64(ILNumerics.ILArray{System.UInt64},ILNumerics.BuiltInFunctions.ILMath.ILUInt64FunctionUInt64)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<UInt64> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt32OperatorUInt32(ILNumerics.ILArray{System.UInt32},ILNumerics.BuiltInFunctions.ILMath.ILUInt32FunctionUInt32)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<UInt32> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.UInt16OperatorUInt16(ILNumerics.ILArray{System.UInt16},ILNumerics.BuiltInFunctions.ILMath.ILUInt16FunctionUInt16)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<UInt16> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int64OperatorInt64(ILNumerics.ILArray{System.Int64},ILNumerics.BuiltInFunctions.ILMath.ILInt64FunctionInt64)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<Int64> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int32OperatorInt32(ILNumerics.ILArray{System.Int32},ILNumerics.BuiltInFunctions.ILMath.ILInt32FunctionInt32)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<Int32> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.Int16OperatorInt16(ILNumerics.ILArray{System.Int16},ILNumerics.BuiltInFunctions.ILMath.ILInt16FunctionInt16)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<Int16> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FloatOperatorFloat(ILNumerics.ILArray{System.Single},ILNumerics.BuiltInFunctions.ILMath.ILFloatFunctionFloat)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<float> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.FcomplexOperatorFcomplex(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.BuiltInFunctions.ILMath.ILFcomplexFunctionFcomplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<fcomplex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<complex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.CharOperatorChar(ILNumerics.ILArray{System.Char},ILNumerics.BuiltInFunctions.ILMath.ILCharFunctionChar)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<char> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ByteOperatorByte(ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILByteFunctionByte)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<byte> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Double})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.UInt64})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.UInt32})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.UInt16})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Int64})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Int32})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Int16})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Char})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Byte})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Single})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Double},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts">subscripts</param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Single},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Int16},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Int32},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Int64},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.UInt16},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.UInt32},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.UInt64},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Char},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Byte},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Double})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types: /*!HC:ENUM:inCls1*/ <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>]]> /*!HC:/ENUM*/</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.fcomplex},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types:  <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>]]> </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Single})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Single},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types:  <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>]]> </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.complex},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types:  <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>]]> </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10c(ILNumerics.ILArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10c(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logc(ILNumerics.ILArray{System.Single})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logc(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{System.Single})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{System.Double})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{System.Single})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{System.Single})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{System.Double})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{System.Single})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{System.Double})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Char})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Char})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Char})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Char})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Char})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Int64})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Int64})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Int64})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Int64})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Int64})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Int32})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Int32})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Int32})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Int32})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Int32})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Int16})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Int16})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Int16})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Int16})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Int16})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Single})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Single})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Single})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Single})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Single})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast inverse fourier transform (1D)
            </summary>
            <param name="A">input (frequency domain)</param>
            <returns>inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array</param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">real input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Double},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D, complex hermitian (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Double},System.Int32[])">
            <summary>
            fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])">
            <summary>
            fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])">
            <summary>
            inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])">
            <summary>
            inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">complex hermitian input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Single})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            fast inverse fourier transform (1D)
            </summary>
            <param name="A">input (frequency domain)</param>
            <returns>inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array</param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">real input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Single})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Single},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Single})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D, complex hermitian (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Single},System.Int32[])">
            <summary>
            fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">complex hermitian input array, n-D</param>
            <param name="dims">transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim beeing smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Double,System.Double)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Single})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,System.Single,System.Single)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Single,System.Single)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Double,System.Double)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan2(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{System.Single})">
            <summary>Arctangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{System.Double})">
            <summary>Arctangent of array elements </summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int64})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int32})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int16})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Char})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Single})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum along specified dimension
            </summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Double})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.UInt64})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.UInt32})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.UInt16})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Int64})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Int32})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Int16})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Single})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Char})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Byte})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{System.Single})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{System.Double})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{System.Single})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{ILNumerics.fcomplex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{ILNumerics.complex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int64})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int32})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int16})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Char})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Single})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>minimum value along specified dimension</summary>
            <param name="A">n-dimensional input array</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of same type and size as A, except for dimension 
            'leadDim' which will be reduced to 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise minimum of two input arrays</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with minimum of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Single})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Single}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Single}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Double})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Int64})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Int32})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Int16})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Char})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Byte})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Single})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type float (single precision)
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; float &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type fcomplex
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; fcomplex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type char
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; char &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type Int16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type Int32
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type Int64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; Int64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type UInt 16
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt16 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type UInt32 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt32 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILArray{System.Single})">
            <summary>
            convert numeric array to inner type UInt64
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; UInt64 &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary (numeric) array to other inner type
            </summary>
            <param name="typeName">Numeric type for output</param>
            <param name="X">input array, arbitrary inner type</param>
            <returns>Numeric array with specified inner element type</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint64(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint32(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.touint16(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint64(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint32(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.toint16(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tochar(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tofcomplex(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tosingle(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Double})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt64})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt32})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt16})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int64})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int32})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int16})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Char})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Byte})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Single})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Double})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Single})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Int64})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Int32})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Int16})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Char})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Byte})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.Lapack">
            <summary>
            concrete interface wrapper class providing the native LAPACK functions
            </summary>
            <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics.Net, a generic - not optimized - version of native LAPACK code will
            be used than.</remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.FFT">
            <summary>
            platform specific FFT implementation, <b>internally</b> used to compute fft 
            </summary>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.#cctor">
            <summary>
            main math class providing static builtin functions
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.ILAtlasMinimumElementSize">
            <summary>
            Minimal size of dimensions, expensive operations will be carried out by native LAPACK libs. 
            </summary>
            <remarks>This property is not yet implemented. All computations (unless for scalars) will be using LAPACK.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vertcat``1(ILNumerics.ILArray{``0}[])">
            <summary>
            vertical concatenation for arbitrary arrays
            </summary>
            <param name="inArrays"> arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except the first dimension.</param>
            <returns>large array having all arrays in 'inArrays' placed beneath each other.
            </returns>
            <remarks>The array returned may be a reference array if all elements of 'inArrays' 
            point to the same object instance, or a solid array otherwise. In the case of
            all elements pointing to the same object, the static member 
            ILNumerics.ILSettings.MinimumRefDimensions will be taken into account too.
            
            Vertical concatenation means concatenation along the first dimension.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.prod(ILNumerics.ILArray{System.Double})">
            <summary>
            multiply and fold array elements along first non singleton dimension
            </summary>
            <param name="inArray">N-dimensional double array</param>
            <returns>array having the first non singleton dimension 
            reduced to the length 1 with the result of the products of 
            corresponding elements of inArray in that dimension.
            The result will have the same number of dimensions as 
            inArray, but the first non singleton dimension having the 
            size 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.prod(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Multiply elements of inArray along specified dimension.
            </summary>
            <param name="inArray">N-dimensional double array</param>
            <param name="leadDim">index of dimension to multiply elements along</param>
            <returns>array having the 'leadDim's dimension 
            reduced to the length of 1 with the result of the product of 
            corresponding elements of inArray of that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryDoubleOperator(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryUInt64Operator(ILNumerics.ILArray{System.UInt64},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionUInt64)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryUInt32Operator(ILNumerics.ILArray{System.UInt32},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionUInt32)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryUInt16Operator(ILNumerics.ILArray{System.UInt16},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionUInt16)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryInt64Operator(ILNumerics.ILArray{System.Int64},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionInt64)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryInt32Operator(ILNumerics.ILArray{System.Int32},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionInt32)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryInt16Operator(ILNumerics.ILArray{System.Int16},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionInt16)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryFloatOperator(ILNumerics.ILArray{System.Single},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionFloat)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryFcomplexOperator(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionFcomplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryComplexOperator(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryCharOperator(ILNumerics.ILArray{System.Char},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionChar)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryByteOperator(ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionByte)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.String})">
            <summary>
            Elementwise logical 'equal' operator
            </summary>
            <param name="A">input array 1</param>
            <param name="B">input array 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.String})">
            <summary>
            Elementwise logical 'not equal' operator
            </summary>
            <param name="A">input array 1</param>
            <param name="B">input array 2</param>
            <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.imag(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            imaginary part of complex array elements
            </summary>
            <param name="X">complex input array</param>
            <returns>imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.imag(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            imaginary part of complex array elements
            </summary>
            <param name="X">complex input array</param>
            <returns>imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{System.Single})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{System.Double})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="T:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Double})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Byte})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Char})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt64})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt32})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt16})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int64})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int32})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int16})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Single})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2fcomplex(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must be the same length. Eather one may be a row- or a column vector.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int64})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int32})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int16})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Single})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Char})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt64},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt32},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt16},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int64},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int32},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int16},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Single},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Char},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt64},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.UInt64}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt32},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.UInt32}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.UInt16},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.UInt16}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int64},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Int64}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int32},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Int32}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Int16},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Int16}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Single},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Single}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Char},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Char}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Byte}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diag``1(ILNumerics.ILArray{``0})">
            <summary>
            diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">matrix or vector. If X is matrix, diag returns the 
            elements on the main diagonal as column vector. If X is vector, a square matrix of size 
            [length(X), length(X)] will be created, having the elemrnts of 
            X on the main diagonal.</param>
            <returns>depending on 'X' a matrix or a vector with the elements of/on 
            the main diagonal.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diag``1(ILNumerics.ILArray{``0},System.Int32)">
            <summary>
            diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">matrix or vector. If X is matrix, diag returns the 
            elements on the 'diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the 'diagPosition's diagonal.</param>
            <param name="diagPosition">index of diagonal to extract/ create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>depending on 'X' a matrix or a vector with the elements of/on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.size(ILNumerics.ILBaseArray)">
            <summary>
            size of array A 
            </summary>
            <param name="A">input array</param>
            <returns>double ILArray with the length of each dimension of A.</returns>
            <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.size(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            length of one specific dimension of A
            </summary>
            <param name="A">input array</param>
            <param name="dim">number of dimension to query the length for</param>
            <returns>length of dimension 'dim'</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.length(ILNumerics.ILBaseArray)">
            <summary>
            longest dimension of A
            </summary>
            <param name="A">input array</param>
            <returns>if A is null:0 - length of longest dimension of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.Longest</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ndims(ILNumerics.ILBaseArray)">
            <summary>
            Number of dimensions of A
            </summary>
            <param name="A">input array</param>
            <returns>if A is null: 0 - else number of dimensions of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.NumberOfDimensions</remarks>
            
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.numel(ILNumerics.ILBaseArray)">
            <summary>
            Number of elements of A
            </summary>
            <param name="A">input array</param>
            <returns>number of elements of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.NumberOfElements</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(System.Int32[])">
            <summary>
            Create new ILArray&lt;double&gt;, setting initial element values to one.
            </summary>
            <returns>Physical ILArray&lt;double&gt; with all elements set to one.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(ILNumerics.Misc.ILDimension)">
            <summary>
            Create new ILArray&lt;double&gt;, setting initial element values to one.
            </summary>
            <returns>Physical ILArray&lt;double&gt; with all elements set to one. </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.zeros(System.Int32[])">
            <summary>
            Create array initialized with all elements set to zero.
            </summary>
            <param name="dimensions">Dimension specification.</param>
            <returns>Zeros-filled array.</returns>
            <remarks>The memory for the array is reclaimed from the memory pool, if possible.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.zeros(ILNumerics.Misc.ILDimension)">
            <summary>
            Create array initialized with all elements set to zero.
            </summary>
            <param name="dimensions">Dimension specification.</param>
            <returns>Zeros-filled array.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.empty">
            <summary>
            Create empty array of size 0,0.
            </summary>
            <returns>ILArray of inner type double which is empty.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eye(System.Int32,System.Int32)">
            <summary>
            Create matrix having unity diagonal values.  
            </summary>
            <param name="rows">Number of rows.</param>
            <param name="columns">Number of columns.</param>
            <returns>Diagonal unity matrix.</returns>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.m_randomGenerator">
            <summary>
            Random number generator used for any generation of random numbers.
            </summary>
            <remarks>One may override this value with their own implementation, derived from <c>Random</c>.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rand(System.Int32[])">
            <summary>
            Pseudo random N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks><para>The elements lie within the range 0.0 ... 1.0 and are uniformly 
            distributed.</para>
            <para>The initial seed will be set to Environment.TickCount on the first call.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.randn(System.Int32[])">
            <summary>
            Normal randomly-distributed N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks>The elements lie within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vector(System.Double,System.Double)">
            <summary>
            Create regulary spaced vector.
            </summary>
            <param name="start">Start value.</param>
            <param name="end">End value.</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval 1. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end. If start 
            <![CDATA[>]]> end, the elements in the vector will regularly decrease from 
            start to end. In this case, step must be negative.</returns>
            <remarks>This is the same as vector (start,[-]1,end).</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Int32[])">
            <summary>
            Create N-dimensional array with elements counting from 1.
            </summary>
            <param name="dimensions">Variable int array with dimension specification</param>
            <returns>Array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Double,System.Double,System.Int32[])">
            <summary>
            Create N-dimensional array with elements counting from 1 and specified interval.
            </summary>
            <param name="start">Initial value.</param>
            <param name="increment">Increment for each element.</param>
            <param name="dimensions">Variable int array with dimension specification.</param>
            <returns>Array with elements counting from 1 ... dimensions.NumberOfElements.</returns>
            <remarks><para>Counter is a fast alternative to the creation of arrays via <see cref="M:ILNumerics.BuiltInFunctions.ILMath.ones(System.Int32[])"/>
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.zeros(System.Int32[])"/> with subsequent modification. 
            Counter is more general. It can create arrays of all constants (zeros, ones, twos ...) if <paramref name="increment"/> is 0, regularly 
            incrementing elements if <paramref name="increment"/> is positive or negative.</para>
            This function may also be used for the convenient creation of arrays for testing purposes.
            <para>Keep in mind: in order to distingush this function from the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Int32[])"/>
            you need to specify parameters <paramref name="start"/> and <paramref name="increments"/> explicitly as double value:</para>
            <example><code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // ... but this will (by mistake) call the wrong function:
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1,2,4,3,2); 
            // ... and therefore create an array of size [1,2,4,3,2] with elements counting from one!
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vector(System.Double,System.Double,System.Double)">
            <summary>
            Create regularly spaced vector.
            </summary>
            <param name="start">Start value.</param>
            <param name="step">Step size.</param>
            <param name="end">End value.</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval step. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end. If start 
            <![CDATA[>]]> end, the elements in the vector will regularly decrease from 
            start to end. In this case, step must be negative.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(ILNumerics.NumericType,System.Int32[])">
            <summary>
            Create array initialized with all elements set to one.
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="dimensions">Dimension specification. At least one dimension must be specified.</param>
            <returns>ILArray&lt;BaseT&gt; of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned may be cast to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Char</item>
            <item>Int16</item>
            <item>Int32</item>
            <item>Int64</item>
            <item>UInt16</item>
            <item>UInt32</item>
            <item>UInt64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ccomplex(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Create complex array from real and imaginary parts. 
            </summary>
            <param name="real">Array with real part elements.</param>
            <param name="imag">Array with imaginary part elements.</param>
            <returns>Complex array constructed out of real and imaginary parts given.</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ccomplex(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            Create complex array from real and imaginary parts. 
            </summary>
            <param name="real">Array with real part elements.</param>
            <param name="imag">Array with imaginary part elements.</param>
            <returns>Complex array constructed out of real and imaginary parts supplied.</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linspace(System.Double,System.Double)">
            <summary>
            create linearly spaced row vector of 100 elements 
            </summary>
            <param name="start">first value</param>
            <param name="end">last value</param>
            <returns>row vector with 100 elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linspace(System.Double,System.Double,System.Int32)">
            <summary>
            create linearly spaced row vector
            </summary>
            <param name="start">first value</param>
            <param name="end">last value</param>
            <param name="length">number of elements to create</param>
            <returns>row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{System.Double})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{System.Single})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.horzcat``1(ILNumerics.ILArray{``0}[])">
            <summary>
            horizontal concatenation for arbitrary arrays
            </summary>
            <param name="inArrays"> arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except the second dimension.</param>
            <returns>large array having all arrays in 'inArrays' placed behind each other.
            </returns>
            <remarks>The array returned may be a reference storage if all elements of 'inArrays' 
            point to the same object instance, or a physical storage array otherwise. In the case of
            all elements pointing to the same object, the static member 
            ILNumerics.Settings.ILSettings.MinimumRefDimensions will be taken into account too.
            
            Horizontal concatenation means concatenation along the second dimension.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Exponential of array elements</summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Exponential of array elements</summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{System.Single})">
            <summary>Exponential of array elements</summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{System.Double})">
            <summary>Exponential of array elements </summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Double})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int64})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int32})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int16})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Char})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Byte})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Single})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Double})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt64})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt32})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt16})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int64})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int32})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int16})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Char})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Byte})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Single})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Single})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Single}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyUpperTriangle``1(ILNumerics.ILArray{``0},System.Int32,System.Int32)">
            <summary>
            copy upper triangle from PHYSICAL array A
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <returns>newly created physical array with the upper triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyUpperTriangle``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            copy upper triangle from system array A
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="arrIn">system array, size (m x n), column wise ordered</param>
            <param name="arrInM">number of rows</param>
            <param name="arrInN">number of columns</param>
            <param name="outM">number of rows in output matrix</param>
            <returns>newly created physical array with the upper triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A! copies the main diagonal also.
            the array returned will be of size (min(m,n) x n)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyLowerTriangle``1(ILNumerics.ILArray{``0},System.Int32,System.Int32,``0)">
            <summary>
            copy lower triangle from PHYSICAL array A, set diagonal to val
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <param name="val">value for diagonal entries</param>
            <returns>newly created physical array with the lower triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyLowerTrianglePerm``1(ILNumerics.ILArray{``0},System.Int32,System.Int32,``0,System.Int32[])">
            <summary>
            copy lower triangle from PHYSICAL array A, set diagonal to val, permuted version
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <param name="perm">mapping for rows, must be converted fom LAPACK version to single indices </param>
            <param name="val">value for diagonal entries</param>
            <returns>newly created physical array with the lower triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.perm2indicesForward(System.Int32[])">
            <summary>
            relabel permutation indices from LAPACK ?getrf
            </summary>
            <param name="perm">lapack pivoting permutation array</param>
            <returns>index mapping for direct addressing the rows </returns>
            <remarks>exchange the row labels in the same manner as LAPACK did for pivoting</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.perm2indicesBackward(System.Int32[])">
            <summary>
            relabel permutation indices from LAPACK ?getrf - backward version
            </summary>
            <param name="perm">lapack pivoting permutation array</param>
            <returns>index mapping for direct addressing the rows </returns>
            <remarks>exchange the row labels in the same manner as LAPACK did for pivoting, but backwards</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{System.Double})">
            <summary>
            complex conjugate of A
            </summary>
            <param name="A">input array</param>
            <returns>the array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{System.Single})">
            <summary>
            complex conjugate of A
            </summary>
            <param name="A">input array</param>
            <returns>the array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logspace(System.Double,System.Double)">
            <summary>
            create logathmically spaced row vector of 50 elements 
            </summary>
            <param name="start">first exponent value</param>
            <param name="end">last exponent value</param>
            <returns>row vector with 50 elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logspace(System.Double,System.Double,System.Int32)">
            <summary>
            create logathmically spaced row vector
            </summary>
            <param name="start">first exponent value</param>
            <param name="end">last exponent value</param>
            <param name="length">number of elements to create</param>
            <returns>row vector with 'length' elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Double})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt64})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt32})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt16})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int64})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int32})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int16})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Char})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Byte})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Single})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.powc(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            power function - complex return
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>complex array</returns>
            <remarks>The complex array returned will hold result of power function for corresponding elements of A<sub>i,j,...</sub><sup>exponent</sup></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.powc(ILNumerics.ILArray{System.Single},System.Single)">
            <summary>
            power function - complex return
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>complex array</returns>
            <remarks>The complex array returned will hold result of power function for corresponding elements of A<sub>i,j,...</sub><sup>exponent</sup></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{System.Single},System.Single)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.triu``1(ILNumerics.ILArray{``0})">
            <summary>
            upper triangular part of matrix
            </summary>
            <typeparam name="T">inner type of matrix</typeparam>
            <param name="A">original matrix, size [m x n]</param>
            <returns>physical array of size [m x n], holding upper triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tril``1(ILNumerics.ILArray{``0})">
            <summary>
            lower triangular part of matrix
            </summary>
            <typeparam name="T">inner type of matrix</typeparam>
            <param name="A">original matrix, size [m x n]</param>
            <returns>physical array of size [m x n], holding lower triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt64})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt32})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt16})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int64})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int32})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int16})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Char})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Byte})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Single})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt64},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt32},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.UInt16},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int64},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int32},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Int16},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Char},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{System.Single})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asinc(ILNumerics.ILArray{System.Single})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asinc(ILNumerics.ILArray{System.Double})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{System.Single})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{System.Double})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Single})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Single},System.Single)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrtc(ILNumerics.ILArray{System.Single})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrtc(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{System.Single})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{System.Double})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{System.Single})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Double})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Double})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt64})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt64},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.UInt64})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt32})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt32},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.UInt32})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt16})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.UInt16},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.UInt16})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int64})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int64},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Int64})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int32})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int32},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Int32})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int16})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Int16},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Int16})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Char})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Char},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Char})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Byte})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Byte})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Single})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Single})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{System.Single})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{System.Double})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acosc(ILNumerics.ILArray{System.Double})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acosc(ILNumerics.ILArray{System.Single})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{System.Single})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{System.Double})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt64})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt64},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt64},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt32})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt32},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt32},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt16})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt16},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt16},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int64})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int64},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int32})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int32},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int16})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int16},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int16},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Single})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Single},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Char})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Char},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Char},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/> 
            and <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String})">
            <summary>
            sort strings in A along first non singleton dimension ascending
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},System.Boolean)">
            <summary>
            sort strings in A along first non singleton dimension
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},System.Int32,System.Boolean)">
            <summary>
            sort strings in A along dimension 'dim'
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="dim">dimension to sort along</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
             <summary>
             sort data in A along dimension 'dim'
             </summary>
             <param name="A">input array: empty, scalar, vector or matrix</param>
             <param name="descending">Specifies the direction of sorting</param>
             <param name="dim">dimension to sort along</param>
             <param name="Indices">output parameter: returns permutation matrix also</param>
             <returns>sorted array of the same size as A</returns>
             <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
             in the next row/column.</para>
             <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort``3(ILNumerics.ILArray{``0},ILNumerics.ILArray{``2}@,System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
            <summary>
            generic sort algorithm in A along dimension 'dim' 
            </summary>
            <param name="A">input array: empty, scalar, vector or matrix</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">input/output parameter: the values in Indices will be returned in the same sorted order as the elements in A. This can be used to derive a permutation matrix of the sorting process.</param>
            <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived ILKeyMapper&lt;T,SubelementType&gt; and match the generic argument <typeparamref name="T"/>. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
            <returns>sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are always of type int.</para>
            <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually given to the function on the beginning. The given array's 
            elements will than be sorted in the same order as the input array A and returned.</para>
            <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly get used for the current sorting 
            without looking at their initial order.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.repmat``1(ILNumerics.ILArray{``0},System.Int32,System.Int32[])">
            <summary>
            array replication [deprecated]
            </summary>
            <param name="X">input array to be replicated</param>
            <param name="rows">number of rows</param>
            <param name="sizeEx">number of columns and higher dimensions</param>
            <returns>reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.repmat``1(ILNumerics.ILArray{``0},System.Int32[])">
            <summary>
            array replication 
            </summary>
            <param name="X">input array to be replicated</param>
            <param name="size">dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Double})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Char})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Single})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.polyfit(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Polynomial curve fitting of degree n
            </summary>
            <param name="x">Vector of X values</param>
            <param name="y">Vector of Y values</param>
            <param name="n">Degress of polynomial to fit</param>
            <returns>Vector of polynomial coefficients [p1, p2, .., pn+1], fit is p(x) = p1*x^n + p2*x^(n-1) + ...</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(System.Double)">
            <summary>
            Find finite value elements
            </summary>
            <param name="input">input array or element</param>
            <returns>true for finite values</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(System.Single)">
            <summary>
            Find finite value elements
            </summary>
            <param name="input">input array or element</param>
            <returns>true for finite values</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{System.Double})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{System.Single})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.pi">
            <summary>
            Definition of pi
            </summary>
            <remarks>this is an alias for Math.PI - supplied for convinience only</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Determine machine specific parameter
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Determine machine specific parameter (double precision)
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rank(ILNumerics.ILArray{System.Double})">
            <summary>
            Rank of matrix inArray
            </summary>
            <param name="inArray">Matrix</param>
            <returns>rank of matrix inArray</returns>
            <remarks>The rank is the number of singular values greater than 
            the default tolerance. As tolerance the following equation is used: \\
            tol = length(inArray) * norm(inArray) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(inArray) - the longest dimension of inArray</item>
            <item>norm(inArray) beeing the largest singular value of inArray, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rank(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            Rank of matrix inArray
            </summary>
            <param name="inArray">Matrix</param>
            <param name="tolerance">tolerance used to decide, if a singular value is 
            treated as zero</param>
            <returns>rank of matrix inArray</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(inArray) * norm(inArray) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(inArray) - the longest dimension of inArray</item>
            <item>norm(inArray) beeing the largest singular value of inArray, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{System.Single})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Double})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Single})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Int64})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Int32})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Int16})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Byte})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{System.Single})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{System.Double})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.reshape``1(ILNumerics.ILArray{``0},System.Int32[])">
            <summary>
            array reshaping
            </summary>
            <param name="A">input array A</param>
            <param name="newDimensions">new dimension array. This may be 
            a comma seperated list or an int array</param>
            <returns>reshaped X</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimension specified by newDimensions. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            if the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="newDimensions"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.reshape``1(ILNumerics.ILArray{``0},ILNumerics.Misc.ILDimension)">
            <summary>
            array reshaping
            </summary>
            <param name="A">input array A</param>
            <param name="dim">new dimension</param>
            <returns>reshaped X</returns>
            <remarks>A will not be changed. A new reference array is created, having 
            the size and number of dimension specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            if the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{System.Double})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{System.Single})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{System.Double},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{System.Single},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{ILNumerics.complex},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the 
            other array in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.
            </para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{System.Single})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{System.Double})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{System.Single})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic cosine of array elements </summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Single})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Single}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Single}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.ILArray{ILNumerics.fcomplex}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.fcomplex},ILNumerics.ILArray{ILNumerics.fcomplex}@,ILNumerics.ILArray{ILNumerics.fcomplex}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Double})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt64})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt32})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt16})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int64})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int32})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int16})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Char})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Byte})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Single})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.meshgrid(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Create two 2D arrays for the valuation and visualization of functions of two variables 
            </summary>
            <param name="x">Vector of x values</param>
            <param name="y">Vector of y values</param>
            <returns>A List of two arrays, the x vector values along the first dimension of the first array, 
            and y vector values along the second dimension of the second array</returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.meshgrid(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Create three 3D arrays for the valuation and visualization of functions of three variables 
            </summary>
            <param name="x">Vector of x values</param>
            <param name="y">Vector of y values</param>
            <param name="z">Vector of z values</param>
            <returns>A List of three arrays, the rows of the first comprising the x vector values and the columns of the second comprising the y vector values</returns>
            <remarks></remarks>
        </member>
        <member name="P:ILNumerics.BuiltInFunctions.ILMath.MachineParameterDouble">
            <summary>
            give extensive numerical machine parameter informations - double precision
            </summary>
        </member>
        <member name="P:ILNumerics.BuiltInFunctions.ILMath.MachineParameterFloat">
            <summary>
            give extensive numerical machine parameter informations - single precision
            </summary>
        </member>
        <member name="T:ILNumerics.BuiltInFunctions.ILMath.GenEigenType">
            <summary>
            Specifies the type of eigenproblem 
            </summary>
            <remarks>The enumeration describes possible problem definitions for generelized eigenproblems:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.Ax_eq_lambBx">
            <summary>
            A*V = r*B*V
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.ABx_eq_lambx">
            <summary>
            A*B*V = r*V
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.BAx_eq_lambx">
            <summary>
            B*A*V = r*V
            </summary>
        </member>
        <member name="T:ILNumerics.MatFileType">
            <summary>
            inner types for MATLAB data elements
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUNKNOWN">
            <summary>
            unknown 
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT8">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT16">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT32">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miSINGLE">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miDOUBLE">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miMATRIX">
            <summary>
            matrix type (general)
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miCOMPRESSED">
            <summary>
            compressed
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF8">
            <summary>
            utf8 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF16">
            <summary>
            utf16 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF32">
            <summary>
            utf32 encoded
            </summary>
        </member>
        <member name="T:ILNumerics.MatFileArrayClass">
            <summary>
            types for matrix chunks
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxCELL_CLASS">
            <summary>
            cell
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSTRUCT_CLASS">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxOBJECT_CLASS">
            <summary>
            object
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxCHAR_CLASS">
            <summary>
            char
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSPARSE_CLASS">
            <summary>
            sparse
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxDOUBLE_CLASS">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSINGLE_CLASS">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT8_CLASS">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT8_CLASS">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT16_CLASS">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT16_CLASS">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT32_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT32_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT64_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT64_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile">
            <summary>
            Matlab .mat file wrapper class
            </summary>
            <remarks>This class can read and write Matlab .mat files version 6! 
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported yet.</remarks>
        </member>
        <member name="F:ILNumerics.ILMatFile.ReservedKeywords">
            <summary>
            list of keywords which Matlab disallows for variable names
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.sizeOf(ILNumerics.MatFileType)">
            <summary>
            size of single elements stored in Matlab's *.mat files
            </summary>
            <param name="type">one of Matlab's inner element types</param>
            <returns>size in bytes </returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.typeToString(ILNumerics.MatFileType)">
            <summary>
            Convert MatFileType enumeration member to string representation
            </summary>
            <param name="type">MatFileType enumeration member</param>
            <returns>String representing the Matlab's inner element type</returns>
            <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.Add(ILNumerics.ILBaseArray)">
            <summary>
            add array to collection of arrays in this ILMatFile container
            </summary>
            <param name="A">array to be added to ILMatFile</param>
            <returns>string used to identify the array in the collection of arrays</returns>
            <remarks><para>The internal <code>Name</code> property of array given will be used as identification key.</para>
            <para>Note, the test if elements of A are supported by MatFile specification is done if the MatFile is to be written to stream ('write').</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException"> if the internal name of A does not fullfill the restrictions given by Matlab.</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(System.String)">
            <summary>
            create MatFile object from existing mat file 
            </summary>
            <param name="file2open">path to Matlab mat file to open</param>
            <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create MatFile object from ILBaseArray
            </summary>
            <param name="input">ILBaseArray of arbitrary size/type</param>
            <exception cref="T:System.ArgumentNullException"> if input array was null or one of the names in the input arrays does not fullfill the restrictions made from Matlab</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor">
            <summary>
            create empty MatFile object
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.IO.Stream)">
            <summary>
            Write this mat file into (binary) stream
            </summary>
            <param name="stream">stream to receive data. This will commonly be a FileStream object.</param>
            <remarks>
            <example><code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code></example></remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.read_miMATRIX(System.IO.BinaryReader)">
            <summary>
            read ONE array (arbitrary dimensions/type) from MAT file 
            </summary>
            <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
            <returns>ILBaseArray of size and type originally stored into the mat file.</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.MatFileType,System.Array@,System.Int32@,System.Int32)">
            <summary>
            read array of supported matlab data types 
            </summary>
            <param name="br">binary reader, opened and correctly positioned</param>
            <param name="storageType">actual storage type</param>
            <param name="realData">output: on return, the array read</param>
            <param name="len">input: number of bytes to read, on return: number of elements in array</param>
            <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
        </member>
        <member name="M:ILNumerics.ILMatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
            <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            </summary>
            <param name="arrName">name property</param>
            <param name="type">will be 'miINT8' on return</param>
            <param name="data">return data array </param>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementClass(ILNumerics.ILBaseArray)">
            <summary>
            get mat file array class type corresponding to this arra element type
            </summary>
            <param name="arr">arra with generic system type or complex/fcomplex</param>
            <returns>mat file array class type code (int value)</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementLength(ILNumerics.ILBaseArray)">
            <summary>
            get storage length of inner array elements 
            </summary>
            <param name="arr">base array in question</param>
            <returns>storage length in bytes</returns>
        </member>
        <member name="P:ILNumerics.ILMatFile.Filelocation">
            <summary>
            Path to mat file, if this object was created from an existing mat file.
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Arrays">
            <summary>
            Arrays stored in this mat file
            </summary>
            <remarks>If the mat file was created from an existing ILBaseArray[] 
            array, the property gives access to the stored arrays directly! 
            This means one operates directly on the data and not on a copy!</remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Keys">
            <summary>
            list all key names currently stored with arrays 
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Item(System.String)">
            <summary>
            Get or set arrays to the MatFile array container
            </summary>
            <param name="name">the name of the array to display in Matlab</param>
            <returns>The array currently stored in the MatFile container.</returns>
            <remarks><para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
            <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.ILMatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current array will be removed from the list. If the name does 
            not already exist, the new array will be added and assigned to this name.</para>
            <para>Restrictions on array names: Matlab allowes variables to have names of maximum length 63. Therefore, if the 
            name given was larger than 63, it will be abbreviated. Names must start with a letter and contain only digits, (ASCII) letters or underscores '_'.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the name does not fullfill the restrictions given from Matlab</exception>
        </member>
        <member name="T:ILNumerics.Misc.ILPerformer">
            <summary>
            Measures time spans.
            </summary>
        </member>
        <member name="T:ILNumerics.Untyped.ILUntype">
            <summary>
            Max - experimental implementation
            </summary>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.max(ILNumerics.ILBaseArray[]@,ILNumerics.ILBaseArray[])">
            <summary>
            maximum
            </summary>
            <param name="inParameter"> system.Array of ILBaseArray's. The number of elements 
            in inParams specifies the mode of max: 
            <list type="bullet">
            <item> 1:  Single array element. the function will give the maximum of elements 
            along the first non singleton dimension. If the length of outParamter is 2, the
            indices of the elements with maximum values found is given back as second return 
            value. [Matlab: [i,y] = max(A)]</item>
            <item> 2: first element: input Array. Second element: second input array. Either 
            one may be a scalar. the function gives back the maximum value of corresponding 
            elements of both input arrays as single otuput parameter. [Matlab: y = max(A,B)]</item>
            <item> 3: first element: input array. second element will be ignored, third element 
            will specify the dimension to operate along. If the length of outParameter specified 
            is 2, the indices of maximum elements into the operation dimension will be given back 
            also. [MAtlab: [y,i] = max(A,[],d)]</item>
            </list>  
            </param>
            <param name="outParameter">[output] return maximum value as requested. If the number of outParameter
            equals 2 on entry, the indices of corresponding maximum valued elements are returned also.</param>
            <remarks>Following types are supported: /*!HC:ENUM:TinCls:*/ <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>, ILArray<byte>, ILArray<char>, ILArray<Int16>, ILArray<Int32>, ILArray<Int64>, ILArray<UInt16>, ILArray<UInt32>, ILArray<UInt64>]]> /*!HC:/ENUM*/.
            The dimension specifier may be any positive (including 0) scalar value inside ILArray 
            of type double or int or float. 
            The length of outParameter specifies the number of values returned. 
            The initial content of outParameter argument will be destroyed on return. </remarks>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.min(ILNumerics.ILBaseArray[]@,ILNumerics.ILBaseArray[])">
            <summary>
            maximum
            </summary>
            <param name="inParameter"> system.Array of ILBaseArray's. The number of elements 
            in inParams specifies the mode of min: 
            <list type="bullet">
            <item> 1:  Single array element. the function will give the maximum of elements 
            along the first non singleton dimension. If the length of outParamter is 2, the
            indices of the elements with maximum values found is given back as second return 
            value. [Matlab: [i,y] = min(A)]</item>
            <item> 2: first element: input Array. Second element: second input array. Either 
            one may be a scalar. the function gives back the maximum value of corresponding 
            elements of both input arrays as single otuput parameter. [Matlab: y = min(A,B)]</item>
            <item> 3: first element: input array. second element will be ignored, third element 
            will specify the dimension to operate along. If the length of outParameter specified 
            is 2, the indices of maximum elements into the operation dimension will be given back 
            also. [MAtlab: [y,i] = min(A,[],d)]</item>
            </list>  
            </param>
            <param name="outParameter">[output] return maximum value as requested. If the number of outParameter
            equals 2 on entry, the indices of corresponding maximum valued elements are returned also.</param>
            <remarks>Following types are supported: /*!HC:ENUM:TinCls:*/ <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>, ILArray<byte>, ILArray<char>, ILArray<Int16>, ILArray<Int32>, ILArray<Int64>, ILArray<UInt16>, ILArray<UInt32>, ILArray<UInt64>, ILArray<double>]]> /*!HC:/ENUM*/.
            The dimension specifier may be any positive (including 0) scalar value inside ILArray 
            of type double or int or float. 
            The length of outParameter specifies the number of values returned. 
            The initial content of outParameter argument will be destroyed on return. </remarks>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.mean(ILNumerics.ILBaseArray[],ILNumerics.ILBaseArray[])">
            <summary>
            mean of array A
            </summary>
            <param name="inParameters">variable input parameter of type ILBaseArray. 
            <list type="bullet">
            <item> mean(A), where A is an ILArray of type supported, will give the 
            mean along the first non singleton dimension.</item>
            <item> mean (A, D) where A is a N-D array of type 
            supported and D is s single scalar sized ILArray of type double or int: returnes 
            mean of elements of A along dimension dim.</item>
            </list></param>
            <param name="outParameters"> Output. Depending on the 
            length of A and on the type of its elements the output return value will be a single 
            ILBaseArray with mean of elements along dimension specified 
            or along first non singleton dimension. The type of the single ILArray 
            returned will be the same as the underlying type of A.</param>
            <remarks> This function is supported for all numeric arrays: /*!HC:ENUM:inCls1:*/ <![CDATA[ ILArray<complex>, ILArray<float>, ILArray<fcomplex>, ILArray<byte>, ILArray<char>, ILArray<Int16>, ILArray<Int32>, ILArray<Int64>, ILArray<UInt16>, ILArray<UInt32>, ILArray<UInt64>]]> /*!HC:/ENUM*/. 
            It does return a <![CDATA[ILArray<BaseT>]]> for all input arrays, where BaseT is the inner
            type of the input array.
            </remarks>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.repmat``1(ILNumerics.ILArray{``0},System.Object,System.Object[])">
            <summary>
            array replication _ : TODO : implement correctly! 
            </summary>
            <param name="X">input array to be replicated</param>
            <param name="rows">number of rows</param>
            <param name="sizeEx">number of columns and higher dimensions</param>
            <returns>reference ILArray as replication of X</returns>
        </member>
        <member name="T:ILNumerics.Algorithms.LDA">
            <summary>
            linear discriminant analysis
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithm">
            <summary>
            Base class for all ILAlgorithms. User may derive their own algorithms from this class
            </summary>
            <remarks>ILAlgorithms excecute synchronously. Therefore the callee is responsible for 
            any threading / locking model if nesseccary. You should derive your own algorithms 
            from this class and call the default constructor ILArgorithm() of the base class from within your constructors. 
            ILAlgorithms provide an event handling mechanism for state and prgress information retrieval. 
            Developer of algorithms should frequently call versions of SetState and / or SetProgress which will
            raise the events for registered listeners.
            The actual work is triggered from the Run() method. Therefore this function should be overloaded or at least called 
            from derived classes as well. Since ILAlgorithms themself derive from ILMath, all static ILMath members (the core
            functions if ILNumerics.Net) are directly callable from within the class. </remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_state">
            <summary>
            internal field, holding the current state of algorithm
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_progress">
            <summary>
            internal field holding the current progress of algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetState(ILNumerics.ILAlgorithmState)">
            <summary>
            set the current state for algorithm
            </summary>
            <param name="state">state enumeration value</param>
            <returns>false: if on of the registrars of the StateChanged event wishes to cancel the operation, true otherwise.</returns>
            <remarks><para>calling this method will fire a StateChanged event.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetState(ILNumerics.ILAlgorithmState,System.String)">
            <summary>
            set the current state for algorithm and provide message
            </summary>
            <param name="state">state enumeration value</param>
            <param name="message">additional message with reason of state change</param>
            <returns>false: if on of the registrars of the StateChanged event wishes to cancel the operation, true otherwise.</returns>
            <remarks><para>calling this method will fire a StateChanged event.</para>
            <para>the message will be delivered to registrars of the StateChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetProgress(System.Double)">
            <summary>
            set the progress value
            </summary>
            <param name="progress">progress value in range 0...1.0</param>
            <returns>false: if on user has requested a cancellation, true otherwise.</returns>
            <remarks><para>calling this method will fire a ProgressChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetProgress(System.Double,System.String)">
            <summary>
            set the progress value
            </summary>
            <param name="progress">progress value in range 0...1.0</param>
            <param name="message">additional informational message with reason of progress change or description of current operation</param>
            <returns>false: if on user has requested a cancellation, true otherwise.</returns>
            <remarks><para>calling this method will fire a ProgressChanged event.</para>
            <para>the message given will be carried to registrars of the ProgressChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.OnStateChanged(System.String)">
            <summary>
            helper function firing the state changed event
            </summary>
            <param name="message">string to be send within the 
            <see cref="T:ILNumerics.Algorithms.ILAlgorithmEventArgs"/> </param>
            <returns>false if a handler of the event has attempted to cancel the 
            operation, true if the algorithm should continue normaly.</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.OnProgressChanged(System.String)">
            <summary>
            helper function firing the progress changed event
            </summary>
            <param name="message">string to be send within the 
            <see cref="T:ILNumerics.Algorithms.ILAlgorithmEventArgs"/> </param>
            <returns>false if a handler of the event has attempted to cancel the 
            operation, true if the algorithm should continue normaly.</returns>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_name">
            <summary>
            internal field holding the name of this algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.#ctor">
            <summary>
            Default constructor 
            </summary>
            <remarks>Derived classes must call this base class constructor! This will set all 
            private attributes to default (inital) values. </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.Run">
            <summary>
            Start running this algorithm synchronously.
            </summary>
            <remarks>Derived classes must call this member via base() !</remarks>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAlgorithm.StateChanged">
            <summary>
            Fires on state changes
            </summary>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAlgorithm.ProgressChanged">
            <summary>
            fires on progress changes
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAlgorithm.Progress">
            <summary>
            get the current progress of the running algorithm 
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAlgorithm.Name">
            <summary>
            Name of the algorithm (readonly)
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.#ctor">
            <summary>
            create new LDA algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.TrainLDA(ILNumerics.ILArray{System.Double},ILNumerics.ILLogicalArray)">
            <summary>
            train the LDA 
            </summary>
            <param name="X">data</param>
            <param name="Labels">labels</param>
            <returns>linear hyperplane wich best discriminates both classes</returns>
            <remarks> gamma will be set to 0.0</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.TrainLDA(ILNumerics.ILArray{System.Double},ILNumerics.ILLogicalArray,System.Double)">
            <summary>
            linear discriminant analysis 
            </summary>
            <param name="X">data matrix. Must be of size d x n, having samples arranged in columns </param>
            <param name="Labels">class labels for <paramref name="X"/>. </param>
            <param name="gamma">RLDA regularization parameter, with values between 0 and 1. 
            GAMMA=0 gives normal LDA, GAMMA=1 uses a multiple of the identity matrix instead 
            of the pooled covariance matrix.</param>
            <returns>cell array with discriminant hyperplane description</returns>
            <remarks><para><c>Labels</c> can be a vector of length n, having positive/negative values at indices 
            corresponding to data X. Alternatively it is a 2 row matrix of length n with 1's in the first row at positions 
            of data in the dirst class and 1's in the second row labeling the data in the second class.</para>
            <para>References: <list><item>J.H. Friedman, Regularized Discriminant Analysis, Journal
            of the Americal Statistical Association, vol.84(405), 1989. The method implemented here 
            is Friedman's method with LAMDBA==1. </item>
            <item>The algorithm is base on implementation of Fraunhofer FIRST.IDA (2004)</item></list></para></remarks>    
        </member>
        <member name="T:ILNumerics.Algorithms.LDA.Hyperplane">
            <summary>
            defines hyperplane c by the formula: c = wx + b
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.LDA.Hyperplane.w">
            <summary>
            hyperplane vector
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.LDA.Hyperplane.b">
            <summary>
            offset for hyperplane
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILDimension">
            <summary>
            ILDimension - dimensions for ILArray objects (immutable)
            </summary>
            <remarks>The class internally manages the dimensions of ILArray. 
            The class is immutable. Therefore, once created, it informs the user 
            about all dimension related properties, but cannot get altered.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor(System.Int32[])">
            <summary>
             create new ILDimension 
            </summary>
            <param name="dims">variable length dimensions specifier</param>
            <remarks>trailing singleton dimensions of dims will be kept.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor(System.Boolean,System.Int32[])">
            <summary>
            create new ILDimension, without trimming trailing singleton dimensions
            </summary>
            <param name="trimSingletons">true: trailing singleton 
            dimensions will be trimmed, false: those singleton dimensions will be kept.</param>
            <param name="dims">dimension lenght specifiers</param>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor(ILNumerics.Misc.ILDimension)">
            <summary>		
            [obsolete] copy constructor
            </summary>
            <param name="newDim">ILDimension object to copy this object from</param>
            <remarks>This function is obsolete and will be removed in a future version. Resona: 
            ILDimension objects are immutable and can therefore savely be reused for 
            multiple arrays.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.FirstNonSingleton">
            <summary>
            find first non singleton dimension - if exist
            </summary>
            <returns>index of first non singleton dimension or -1, if this is a scalar.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.SequentialIndexDistance(System.Int32)">
            <summary>
            Marks the number of elements between adjacent elementes of 
            each dimension as if the underlying storage was a dense storage.
            </summary>
            <param name="dim">dimension number to query the element distance for. The
            first dimension has index 0 ('zero')!</param>
            <returns>number of elements between adjacent elements of dimension dim.
            </returns>
            <remarks>if dimension index dim is larger than the number of 
            dimensions inside this ILDimension, the number of elements will 
            be returned (assuming the trailing dimensions to be 1).</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetSequentialIndexDistances(System.Int32)">
            <summary>
            distances between adjacent elements for all dimensions
            </summary>
            <param name="minLength">minimum length of array to be 
            returned. If this is larger than the number of dimensions 
            in this ILDimension, the array will have minLength elements, 
            with elements outside this dimensions repeating the value 
            of the last dimension. The length of the array returned will 
            be equal or greater than max(minLength,NumberOfDimensions).</param>
            <remarks>This is provided for performance reasons and should be 
            used internally only. It enables developer of index access routines 
            to cache the elements distances directly inside their functions 
            without having to query the info on every index access.
            <para>Keep in mind, only the distances for the number of my 
            dimensions are returned. Higher dimensions must be set to 
            NumberOfElements if needed. This is different than querying 
            the distances by SequentialIndexDistance(int), which will assume 
            and return trailing dimensions to be 1.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToIntArray">
            <summary>
            transfer my dimensions to integer array 
            </summary>
            <returns>integer array containing a copy of dimensions length</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToIntArray(System.Int32)">
            <summary>
            transfer my dimensions to integer array 
            </summary>
            <param name="length">minimum length of output array. If length 
            is larger than my dimensions, trailing ones will be added.</param>
            <returns>integer array containing a copy of dimensions length. 
            Trailing elements outside my dims will be one.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Int32[])">
            <summary>
            Translate indices from int[] Array to sequential storage access 
            in my dimensions
            </summary>
            <param name="idx">int array of nrDims length</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Transform dimension position into sequential index, gather expand 
            information
            </summary>
            <param name="idx">int array of arbitrary length</param>
            <param name="MustExpand">[output] true, if the indices 
            given address an element outside of 
            this dimensions size. In this case, the output parameter 
            'Dimensions' carry the sizes 
            of new dimensions needed. False otherwise</param>
            <param name="Dimensions">sizes of dimension if expansion is needed</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
            <remarks>no checks are made for idx to fit inside dimensions! 
            This functions is used for left side assignments. Therefore it 
            computes the destination index also if it lays outside 
            the array bounds.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Int32[],System.Int32)">
            <summary>
            Unshift dimensions of indices from int[] Array 
            and translate to index for sequential storage access 
            in my dimensions </summary>
            <param name="idx">int array of the same length as 
            the number of dimensions of this storage. Indices must 
            lay within my dimensions.</param>
            <param name="unshift">number of dimensions to unshift 
            idx before computing index</param>
            <returns>Index number pointing to the value's position 
            in sequential storage.</returns>
            <remarks> If idx contains elements (indices) larger than 
            my dimension bounds, an exception will be thrown. If unshift 
            is 0, the length of idx may be smaller than the length of 
            my dimensions. However, with unshift &gt; 0 the result 
            is undefined.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Clone">
            <summary>
            Clone ILDimension object. 
            </summary>
            <return>
            New ILDimension object as exact copy of this object.
            </return>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Shift(System.Int32)">
            <summary>
            [deprecated] Shift this ILDimension
            </summary>
            <param name="shift">number of dimensions to shift.</param>
            <remarks>this will not alter this object anymore but return the shifted version!
            The function will be removed in a future release! Use 
            ILDimension.GetShiftedVersion() instead!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetShifted(System.Int32)">
            <summary>
            return shifted version
            </summary>
            <param name="shift">number of dimensions to shift. The value
            will be considered modules the number of dimensions of 
            this ILDimension.</param>
            <returns>shifted version of this ILDimension object.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IsSameSize(ILNumerics.Misc.ILDimension)">
            <summary>
            Compares the size of this dimension to another dimension object. 
            </summary>
            <param name="dim2">ILDimension object to compare this to.</param>
            <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by recognizing singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
            <remarks>The function reutrns true, if the squeezed dimensions of 
            both ILDimensions match.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IsSameShape(ILNumerics.Misc.ILDimension)">
            <summary>
            Compares the shape of this dimension to another dimension object 
            </summary>
            <param name="dim2">ILDimension object to compare this to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than IsSameSize. In order 
            for two dimensions to have the same shape, ALL dimensions must match - 
            even singleton dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetSqueezed">
            <summary>
            [deprecated] Create copy of this ILDimension having all singleton 
            dimensions removed.
            </summary>
            <returns>a squeezed copy</returns>
            <remarks>This function is deprecated. Use the ILDimension.Squeeze()
            memeber instead. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Squeeze">
            <summary>
            Create and return copy without singleton dimensions
            </summary>
            <returns>Copy of this ILDimension having all singleton dimensions removed.</returns>
            <remarks> This function does not alter this object (since ILDimension is 
            immutable).
            <para>All arrays in ILNumerics.Net have at least 2 dimensions. 
            Therefore all but the first two singleton dimensions can be removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Trim">
            <summary>
            Return ILDimension having trailing singleton dimensions removed
            </summary>
            <returns>Copy without trailing singleton dimensions</returns>
            <remarks> this object will NOT be altered. As usual for all ILArrays, 
            the result wil have at least 2 dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToString">
            toString: prints out dimensions 
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NumberOfDimensions">
            <summary>Get number of dimensions.</summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NonSingletonDimensions">
            <summary>
            Number of non singleton dimensions this ILDimension is referencing
            </summary>
            <remarks>non singleton dimensions are dimensions which length is larger than 1. 
            Empty dimensions (length = 0) will not be take into account.</remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NumberOfElements">
            <summary>
            The number of elements the dimensions reference in an array of that size
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.Longest">
            <summary>
            return longest dimension length
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.Item(System.Int32)">
            <summary>
            Get length for dimension specified (Readonly)
            </summary>
            <param name="idx">index of dimension</param>
            <returns>length of dimension specified by idx</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if idx is negative</exception>
            <remarks><para>for idx corresponds to an existing dimension, 
            the length of that dimension is returned. If idx is larger than 
            the number of dimensions 1 is returned. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Misc.ILMemoryPool">
            <summary>
            Memory pool serving as temporary storage for System.Array objects
            </summary>
            <remarks>The pool reduces the pressure on the systems memory done by larger objects.
            <para>Arrays created in ILNumerics.Net will try to reclaim its memory from this pool. If attempt fails, the memory is gathered from the managed heap normally.</para>
            <para>Disposed array objects register their underlying System.Array in the pool for later reusing. The process is triggered by the garbage collector or by the user calling the Dispose function available for all ILArray objects.</para></remarks>
        </member>
        <member name="F:ILNumerics.Misc.ILMemoryPool.Pool">
            <summary>
            The only global ILMemoryPool instance
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinArrayLength">Minimum length for array object to be stored inside the pool</param>
            <param name="PoolSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.DisposeContent">
            <summary>
            Dispose all object currently hold in the pool 
            </summary>
            <remarks>The pool get cleared and continues working with the same parameters after the call has finished. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.RegisterObject``1(``0[])">
            <summary>
            Register an array object of value type in the pool
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="arr">value type array</param>
            <remarks><para>In order to be stored in the pool, the array must meet the minimum array length and must fit into the global pool size.
            Null objects or empty arrays or array not suitable for the pool will be silently ignored.</para>
            <para>If the new array is too large to fit into the remaining pool space, the oldest objects in the pool will be released until the object can get registered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32)">
            <summary>
            Request a System.Array instance
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>There is no way of determining, if the array was recalimed from pool or newly created! If you must be sure, the element values are set to default(T), call the overloaded version <see cref="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32,System.Boolean,System.Boolean@)"/> instead!</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection is triggered and the array is again requested from the pool. If this failes again, another attempt to create the array is done. Exceptions may thrown from this last attempt are not catched and transported back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            Request a System.Array instance and optionally clear the array
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <param name="clear">if true, the elements of the array returned are set to default(T).</param>
            <param name="iscleared">out paramater determining if the array returned has been cleared</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>If the <paramref name="clear">clear </paramref> parameter was set to false, the <paramref name="iscleared">iscleared</paramref> parameter can be used to determine, if the object was returnd from the pool and may need extra clearing.</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection is triggered and the array is again requested from the pool. If this failes again, another attempt to create the array is done. Exceptions eventually thrown from this last attempt are not catched and transported back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean,System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <param name="reset">true: reset internal counter for reclaimed objects/ - bytes</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info">
            <summary>
            Give extended infos about pool state
            </summary>
            <returns>Full info about current and reclaimed pool objects</returns>
            <remarks>For short version infos use the overloaded version <see cref="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean)"/></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Collect(System.Int32)">
            <summary>
            Collect all pending objects waiting for garbage cleaning and finalization
            </summary>
            <param name="generations">collect objects of given generations number only</param>
            <remarks>This function will return, if a garbage collector run and all subsequent finalizers has been completed.
            <para>After the function returns, all pending <code>ILArray</code>s not referenced from anywhere will have been placed 
            into the pool for reusement.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Collect">
            <summary>
            Collect all pending objects waiting for garbage cleaning and finalization
            </summary>
            <remarks>This function will return, if a garbage collector run and all subsequent 
            finalizers has been completed.
            <para>After the function returns, all pending <code>ILArray</code>s 
            not referenced from anywhere will have been placed 
            into the pool for reusement. Therefore this function should only be called, 
            in order to prepare the pool directly <b>before</b> requesting large amounts of memory. 
            </para></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPool.ReclaimedBytesCount">
            <summary>
            Number of reclaimed bytes since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)"/></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPool.ReclaimedObjectsCount">
            <summary>
            Number of reclaimed objects since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)"/></remarks>
        </member>
        <member name="T:ILNumerics.Algorithms.ILKeyMapper`2">
            <summary>
            key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            </summary>
            <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
            <typeparam name="SubelementType">Type of subelements</typeparam>
            <remarks>This class can be overriden to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list>
            <item>colors: number/type of subelements: 1/any (f.e. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item>
            <item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item>
            <item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item>
            <item>...</item></list></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`1)">
            <summary>
            maps subelement types to bucket index
            </summary>
            <param name="inSubelement">item</param>
            <returns>bucket index</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`0,System.Int32,System.Int32)">
            <summary>
            map subelemt - provide fallback on error
            </summary>
            <param name="element">element item</param>
            <param name="position">position of subelement in element item to be mapped</param>
            <param name="fallback">if position is out of range, give back fallback</param>
            <returns>mapped bucket for subelement or fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.SubelementsCount(`0)">
            <summary>
            count subelements in an element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.GetSubelement(`0,System.Int32)">
            <summary>
            get subelement from element item
            </summary>
            <param name="element">element item</param>
            <param name="idx">position of subitem in element</param>
            <returns>subitem referenced</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.#ctor(System.Int32)">
            <summary>
            construct key mapper
            </summary>
            <param name="NumberOfKeys">maximm number of different subitems (keys)</param>
        </member>
        <member name="P:ILNumerics.Algorithms.ILKeyMapper`2.NumberOfKeys">
            <summary>
            maximum number of keys (different subitems)
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILASCIIKeyMapper">
            <summary>
            Concrete implementation of a key mapper for strings
            </summary>
            <remarks>this class is the default key mapper, used for bucket sort on strings</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.Char)">
            <summary>
            map subelement to bucket 
            </summary>
            <param name="inSubelement">subelement to be mapped</param>
            <returns>ASCII code of the subelement character</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
            <summary>
            Map char out of string with fallback
            </summary>
            <param name="element">full string item</param>
            <param name="position">position of character in string</param>
            <param name="fallback">fallback bucket number, if position is out of range</param>
            <returns>ASCII code for character specified, fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
            <summary>
            give one char from string
            </summary>
            <param name="element">full string item</param>
            <param name="idx">character position in string</param>
            <returns>character in string</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.SubelementsCount(System.String)">
            <summary>
            Count numer of characters in string
            </summary>
            <param name="element">element item</param>
            <returns>number of characters in string - length of string</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.#ctor">
            <summary>
            construct ASCII key mapper for 256 buckets
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILIntLimitedKeyMapper">
            <summary>
            Integer key mapper - sample implementation for bucket sort
            </summary>
            <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para>
            <para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
            <summary>
            Gives subelement - i.e. the element itself
            </summary>
            <param name="element">element</param>
            <param name="idx">(ignored)</param>
            <returns>element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
            <summary>
            map element - ignoring position &amp; fallback
            </summary>
            <param name="element">integer element</param>
            <param name="position">(ignored)</param>
            <param name="fallback">(ignored)</param>
            <returns>integer element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32)">
            <summary>
            map (copy) subelement
            </summary>
            <param name="inSubelement">subelement</param>
            <returns>subelement</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.SubelementsCount(System.Int32)">
            <summary>
            number of subelements in an element (Here: always 1)
            </summary>
            <param name="element">element</param>
            <returns>1</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.#ctor(System.Int32)">
            <summary>
            construct integer key mapper
            </summary>
            <param name="limit">maximum number of buckets to be used</param>
        </member>
        <member name="T:ILNumerics.Algorithms.SimpleAsyncSample">
            <summary>
            Sample class for user defined asynchronous algorithm
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAsyncAlgorithm">
            <summary>
            base class for asynchronous algorithms
            </summary>
            <remarks>the abstract class implements an asynchronous algorithm class. It 
            fires events for all state changes and for progress information. Algorithms 
            derived from this class are capable of cancelling on user rewuest and to transparently 
            invoke event signals in the context of a calling System.Windows.Form - even from the internal 
            worker thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.GetResult">
            <summary>
            query algorithm result 
            </summary>
            <remarks><para>if the algorithm has not finished yet, the method waits for the thread to end. 
            If the algorithm has not started yet, null will be returned.</para>
            <para>You may query the state of the algorithm before calling this property, in order to prevent for the lock.</para>
            <para>Class designer of derived classes use this property to get the result object after an algorithm has finnished. The 
            return value is the return value of the abstract method <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)"/>. The type 
            of the result object depends on the actual implementation of the derived class.</para> </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.SetProgress(System.Double,System.String)">
            <summary>
            Set the current progress of the algorithm. 
            </summary>
            <param name="progress">progress value. 0 &lt;= progress &lt;= 1.0</param>
            <param name="message">additional message.</param>
            <remarks><para>Calling this methos will fire an <see cref="E:ILNumerics.Algorithms.ILAsyncAlgorithm.ProgressChanged">ProgressChanged</see> event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.#ctor(System.Windows.Forms.Control)">
            <summary>
            constructor creating a new ILAsyncAlgorithm object.
            </summary>
            <param name="control">if not null, events fired from this class will be 
            executed in the context of the thread owning the control. This is specifically 
            important for Windows.Forms.Control user interfaces, which require this in order to allow 
            direct manipulation of the control from inside the event handlers.</param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Kill(System.Int32)">
            <summary>
            Kills this algorithm thread. 
            </summary>
            <param name="msec">waits for at most <paramref name="msec"/> milliseconds before returning</param>
            <returns>true: the thread has been successfully canceled. false: the thread has acknowledged the 
            cancellation request after msec milliseconds.</returns>
            <remarks><para>This method kills the algorithm thread without waiting for the algorithm to end. It 
            waits for at most msec milliseconds for the algorithm thread to respond and acknowledge the cancellation.</para>
            <para>You should always prefer the Cancel() method for the Kill() method. This gives the algorithm the chance 
            to exit cleanly.</para>
            <para>Calling this function will <b>NOT</b> call any StateChanged events.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Cancel(System.Int32)">
            <summary>
            Cancel the algorithm.
            </summary>
            <param name="timeout">waits for at most msec milliseconds after the cancelation request was published.</param>
            <returns>true: the algorithm has finished/ cancelled successfully. false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Suspend">
            <summary>
            halt the algorithm
            </summary>
            <returns>true if the algorithm was suspended successfully. False otherwise.</returns>
            <remarks>An algorithm which has suspended may later be resumed. Calling this 
            method on an algorithm which is not running will have no effect and return true.
            <para>This method will be called in the context of the algorithm caller thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Resume">
            <summary>
            Resume algorithm
            </summary>
            <remarks>If the algorithm is in state 'Suspended', calling this method will 
            resume execution for this thread. Calling this method for an algorithm which is 
            not in state 'Suspended' will have no effect.
            <para>This method will be called in the context of the algorithm caller thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)">
            <summary>
            this function serves as a placeholder for your derived class method wich does the actual computing 
            </summary>
            <remarks>Algorithm class designer must implement their algorithms in this function. Make sure, to 
            frequently check the CancelPending member of the base class, to determine if a cancellation was requested.
            <para>This method will be called in the context of the algorithm worker thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.CompileParameter">
            <summary>
            assemble parameter object i.o. to overgive to thread worker
            </summary>
            <returns>parameter object</returns>
            <remarks>This function must be implemented by algorithm class designers. It compiles all neccessary 
            input parameter for the computation function. The output of this method will later be the only input 
            parameter for the <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)">AlgorithmFunction</see> 
            on a seperate thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnAlgorithmFinished">
            <summary>
            Additionally clean up after the algorithm has finished successfully.
            </summary>
            <remarks>This method will be called in the context of the algorithm worker thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.RunAsync">
            <summary>
            Start algorithm asynchronously
            </summary>
            <remarks>The algorithm will be started in a new thread. the state of the algorithm will be set to 'Running'.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.RunSync">
            <summary>
            Execute this algorithm and wait for finish 
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnStateChanged">
            <summary>
            Fires the StateChanged event.
            </summary>
            <remarks><para>If the control parameter was given in the constructor of the class, the 
            event is fired in the context of the calling thread and not of the worker thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnProgressChanged">
            <summary>
            Fires the ProgressChanged event.
            </summary>
            <remarks><para>If the control parameter was given in the constructor of the class, the 
            event is fired in the context of the calling thread and not of the worker thread.</para></remarks>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAsyncAlgorithm.StateChanged">
            <summary>
            fires whenever the state of the algorithm changes
            </summary>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAsyncAlgorithm.ProgressChanged">
            <summary>
            fires if the progress of the algorithm changes 
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.State">
            <summary>
            The current state of the algorithm. One out of the enumeration <see cref="T:ILNumerics.ILAlgorithmState"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.CancelPending">
            <summary>
            informs about a pending cancelation
            </summary>
            <remarks>
            <para>This will be set to true, if an algorithm is running and the user of the class called the <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Cancel(System.Int32)"/> method.</para>
            <para>Class designer of derived classes should frequently check this property. If a cancellatioin was 
            requested, the algorithm should close as fast as possible. This is the 'good way' out of the algorithm. If the algorithm 
            does not respond fast enough, the user might kill the thread, which will not give the algorithm the chance to exit cleanly.</para></remarks>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.Progress">
            <summary>
            current progress value.
            </summary>
        </member>
        <member name="T:ILNumerics.Untyped.ILMath">
            <summary>
            general math class. This is in an experimental state! 
            </summary>
        </member>
        <member name="M:ILNumerics.Untyped.ILMath.Find(ILNumerics.ILBaseArray[],ILNumerics.ILBaseArray[])">
            <summary>
            
            </summary>
            <param name="outValue">Array of BaseArray of output parameter. outValue must be 
            at least of lenght 1, at most of length 3. The meanings are: 
            <list type="bullet">
            <item>One parameter: the sequential indices of all nonzero elements of X are returned.</item>
            <item>Two parameter: The first BaseArray returned in 'outValue' will hold the row indices of 
            nonzero elements of X, the second BaseArray will hold the column indices of those nonzero elements.</item>
            <item>If Length of outValue is 3, the rows and columns of nonzero elements are returned as the 
            first and second BaseArray elements. The third array will hold a (shallow) copy of those 
            nonzero elements found.</item>
            </list>
            </param>
            <param name="X">Array of input parameter. This must be at least 1 BaseArray holding 
            the input array for evaluation. If this array has length of 2, the second element must 
            be a scalar array of type <![CDATA[ILArray<double> or ILArray<int> or ILArray<float> or ILArray<byte>]]> 
            specifying the integer number of values to be returned. If this value is smaller 0, Find will 
            return that number of nonzero elements of X from the end of X.</param>
            <remarks>In order to specify the mode of Find, the length of the arrays 'outValue' and 
            'X' will be recognized only. Any initial values of elements in 'outValue' will 
            be destroyed. The elements of X will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sinc(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number og columns</param>
            <param name="periods">influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sinc(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number of columns</param>
            <returns>matrix with sinc data in 2 dimensions</returns>
            <remarks>the function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sincos1D(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data
            </summary>
            <param name="numSamples">number of samples</param>
            <param name="periods">number of (full) periods to be generated, must be &gt; 0</param>
            <returns>matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.waterfall(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number of columns</param>
            <returns>matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sphere(System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Create surface data of a sphere
            </summary>
            <param name="n">number of facettes per angle</param>
            <param name="X">[output] X coords</param>
            <param name="Y">[output] Y coords</param>
            <param name="Z">[output] Z coords</param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Create surface data for a Mbius strip 
            </summary>
            <param name="n">granularity (number of facettes)</param>
            <param name="w">width</param>
            <param name="R">radius</param>
            <param name="X">[output] X coords</param>
            <param name="Y">[output] Y coords</param>
            <param name="Z">[output] Z coords</param>
            <remarks>Mbius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.</remarks>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT">
            <summary>
            Wrapper for FFT interface using FFTW3 libs
            </summary>
        </member>
        <member name="T:ILNumerics.Native.IILFFT">
            <summary>
            Interface for all FFT methods supported
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{System.Single},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FreePlans">
            <summary>
            Clear all currently cached plans
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT.fftw_iodim">
            <summary>
            This struct is used to define (n-dimensional) transform sizes
            </summary>
            <remarks>This struct is only user in C-API. It is NOT used for the Fortran interface (i.e. it's not used in here)!!! </remarks>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.n">
            <summary>
            length of dimension
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.iS">
            <summary>
            input stride
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.oS">
            <summary>
            output stride
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILListItem`2">
            <summary>
            List items to be used in ILQueueList
            </summary>
            <typeparam name="T1">Data type</typeparam>
            <typeparam name="T2">Index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0)">
            <summary>
            construct list item by data
            </summary>
            <param name="item">item data</param>
            <remarks>the indet will be set to its default value</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0,`1)">
            <summary>
            construct list item, takes item data and - index
            </summary>
            <param name="item">item data</param>
            <param name="index">index</param>
        </member>
        <member name="P:ILNumerics.Misc.ILListItem`2.Index">
            <summary>
            index stored for/with this item
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILQueueList`2">
            <summary>
            Queuelist - queue with list properties also
            </summary>
            <typeparam name="T1">data type</typeparam>
            <typeparam name="T2">index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0,`1)">
            <summary>
            add indexed item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0)">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILListItem{`0,`1})">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            add queue list to end of this queue list
            </summary>
            <param name="list">queue list to be added</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Dequeue">
            <summary>
            Remove from start of queue
            </summary>
            <returns>item from start of queue</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(`0)">
            <summary>
            Add to start of queue
            </summary>
            <param name="item">item data to add to start of queue</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            concatenate 2 queuelists
            </summary>
            <param name="qlist">queue list to be added at start of this queuelist</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Sort``1(ILNumerics.Algorithms.ILKeyMapper{`0,``0})">
            <summary>
            sort utilizing bucket sort
            </summary>
            <typeparam name="SubelementType">subelement type</typeparam>
            <param name="mapper">keymapper mapping subelement items to buckets</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.ToArray">
            <summary>
            convert (copy) items to system array
            </summary>
            <returns>system array with items</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Clear">
            <summary>
            Clear this queue list from all elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.GetEnumerator">
            <summary>
            Create enumerator utilizing 'foreach'
            </summary>
            <returns>enumerator for contained elements</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            gives enumerator for internal list items (ILListItem)
            </summary>
            <returns>ILListItem's</returns>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.Count">
            <summary>
            number of items currentliy in the queue (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.ListItems">
            <summary>
            Gives enumerator for contained items (ILListItem)
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.Graphic.Triangularize(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Int32},System.Int32,ILNumerics.ILArray{System.Single}@,ILNumerics.ILArray{System.Int32}@)">
            <summary>
            increase the number of triangles by doubling existing triangles
            </summary>
            <param name="vertices">vertices</param>
            <param name="triangles">triangle index definitions</param>
            <param name="iterations">number of iterations, each iteration will make 4 triangles out of each triangle</param>
            <param name="outVertices">output, vertices.</param>
            <param name="outTriangles">output, triangles</param>
            <remarks><para>Incoming triangles are expected not to be degenerated. This means:
            Every edge is used only twice at most. No triangle shares more than 2
            corners with some other triangle. </para>
            	<para>None of the incoming arrays will get altered</para></remarks>
        </member>
        <member name="T:ILNumerics.Storage.ILIteratorPositions">
            <summary>
            Iterator positions, used for creating ILIterators and specifying initial 
            positions of the current element.
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILStart">
            <summary>
            position the iterator at the first element
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILEnd">
            <summary>
            position the iterator at the last element
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILMiddle">
            <summary>
            position the iterator at the middle element
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILIterator`1">
            <summary>
            High performance iterator for ILArray's 
            </summary>
            <remarks>This iterator is optimized for physical storages as well as 
            for reference storages. However, the iteration for reference storage 
            is (and will always be) couple of times slower than for physical storages.
            <para>This type is marked as <b>deprecated</b> and may be removed in a 
            future release. Use foreach constructs for read access and SetValue(seqIdx) for write 
            access instead. Those functions - however - may not reach the performance of the 
            iterator for write access in certain situations.</para>
            </remarks>
            <typeparam name="BaseT">the base type of the storage's instance.</typeparam>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.#ctor(`0[],ILNumerics.Storage.ILIndexOffset,ILNumerics.Misc.ILDimension)">
            <summary>
            create ILIterator - this is not for public use! Use <see cref="M:ILNumerics.ILArray`1.CreateIterator"/> instead!
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.#ctor(`0[],ILNumerics.Storage.ILIndexOffset,ILNumerics.Misc.ILDimension,ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            create ILIterator - this is not for public use! Use <see cref="M:ILNumerics.ILArray`1.CreateIterator"/> instead!
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
            <param name="startPos">enumeration value where to set the initial element position </param>
            <param name="leadingDimension">the dimension, the iterator is going to walk along</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.commonConstruct(`0[],ILNumerics.Storage.ILIndexOffset,ILNumerics.Misc.ILDimension,ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            this helper function is used from all constructors
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
            <param name="startPos">enumeration value where to set the initial element position </param>
            <param name="leadingDimension">the dimension, the iterator is going to walk along</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.IsAtEnd">
            <summary>
            determine, if the current element is the last element
            </summary>
            <returns>true if the current element is the last element in the array, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.IsAtStart">
            <summary>
            determine, if the current element is the first element
            </summary>
            <returns>true if the current element is the first element in the array, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.Increment">
            <summary>
            increment to next position and return value at new position
            </summary>
            <returns>Value of element at new position</returns>
        </member>
        <member name="P:ILNumerics.Storage.ILIterator`1.IsReadonly">
            <summary>
            readonly state of the storage attached to this iterator
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILIterator`1.Value">
            <summary>
            get/set value at current position
            </summary>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException">if the storage was readonly, while 
            attempting to alter elements</exception>
        </member>
        <member name="T:ILNumerics.Exceptions.ILException">
            <summary>
            generic exception, base class for all exceptions thrown by ILNumerics.Net
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMathException">
            <summary>
            Base class for mathematical exceptions. Needed e.g. in interpreter for propoer error
            messages
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILDimensionMismatchException">
            <summary>
            One of the most common exceptions: The matrix sizes do not match
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentException">
            <summary>
            something was wrong with the arguments overgiven 
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentNumberException">
            <summary>
            a function was called with the wrong number of arguments
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentSizeException">
            <summary>
            a function argument has the wrong size
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentTypeException">
            <summary>
            a function was called with a wrong argument type
            </summary>
            <remarks>this exception might be thrown if the size or inner 
            type of a argument is invalid. (f.e. matrix expected, but 3D array found)
            </remarks>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMemoryException">
            <summary>
            a request could not be completed due to not enough memory available
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILCastException">
            <summary>
            Thrown on illigal casts 
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String)">
            <summary>
            Costructor
            </summary>
            <param name="message">aditional message to be included into the exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String,System.Exception)">
            <summary>
            Costructor
            </summary>
            <param name="message">aditional message to be included into the exception</param>
            <param name="innerException">on cascaded exception handling, the exception catched before</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILOutputException">
            <summary>
            ILOutputException, thrown if an I/O attempt fails
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidOperationException">
            <summary>
            Exception thrown if an operation could not completed
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.ILLogicalArray">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[<byte>]]> and an ILLogicalArray is, the ILLogicalArray 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="F:ILNumerics.ILLogicalArray.m_numberNonZero">
            <summary>
            internal field, caches the number of 'true' elements
            </summary>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Int32[])">
            <summary>
            constructor - create ILLogicalArray of type <code>Byte</code> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <code>bool</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(ILNumerics.ILArray{System.Byte})">
            <summary>
            Constructor creating ILLogicalArray from <![CDATA[ILArray<byte>]]>
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogicalArray</param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Constructor creating ILLogicalArray from <![CDATA[ILArray<byte>]]>
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogicalArray</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create ILLogicalArray of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILLogicalArray of the specified size 
            will be created. The type of storage will be <code>byte</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],ILNumerics.Misc.ILDimension)">
            <summary>
            Constructor creating ILLogicalArray, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],ILNumerics.Misc.ILDimension,System.Int32)">
            <summary>
            Constructor creating ILLogicalArray, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.sumElements">
            <summary>
             sum all elements of this storage. 
            </summary>
            <returns>Number of non zero elements</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Concat(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="inArray">N-dimensional storage. Except for dimensions leadDim 
            the dimensions must match the dimensions of this storage.</param>
            <param name="leadDim">index of dimension to concatenate arrays along.
            If leadDim is larger than the number of dimensions of any of the arrays
            its value will be used in modulus</param>
            <returns>logical array having the size 
            of both input arrays layed behind each other along the leadDim's-dimension</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference storage, if inArray is the same as this array (object references 
            are the same) and ILArray.MinimumRefDimensions is less or equal 
            the number of dimensions of the resulting storage, or a 
            </item>
            <item>physical storage else. 
            </item></list>
            There are only very few cases where it is possible to reference two arrays in the 
            same reference storage. Not only the storages must point to the same underlying 
            physical System.Array, but the ILIndexOffset must be suited in a special way. 
            Therefore the restriction was made always to create a reference storage, if 
            both storages are not the same.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Repmat(System.Int32[])">
            <summary>
            Replicate this ILArray. Make large ILLogicalArray out of it.
            </summary>
            <param name="dims">dimensions specifier. This may be a comma sep.
            list or an array of integer values. If the number of elements in dim is 
            less the number of dimensions in this ILArray, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>large array beeing a multiple (dims) copy of this array along 
            arbitrary dimensions</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference storage, if the number of dimensions resulting is more or equal 
            to ILArray.MinimumRefDimensions, or a 
            </item>
            <item>physical storage else. 
            </item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this ILArray + dimension shift
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> string specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.String[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj
            </summary>
            <param name="obj">typed ILArray containing the values to compare this array with</param>
            <returns>true if all elements contained in obj are equal to the 
            elements of this array. False otherwise.</returns>
            <remarks> This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.GetHashCode">
            <summary>
            give the HashCode for this ILLogicalArray
            </summary>
            <returns>HashCode as given from base class</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Boolean)~ILNumerics.ILLogicalArray">
            <summary>
            Implicitly convert Byte scalar to ILLogicalArray of size 1x1 (scalar).
            </summary>
            <param name="val">Byte scalar</param>
            <returns>New ILLogicalArray of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Byte[])~ILNumerics.ILLogicalArray">
            <summary>
            Implicit cast System.Array of type byte[] to ILLogicalArray
            </summary>
            <param name="vector_elements">predefined elements values</param>
            <returns>new ILLogicalArray using the System.Array given as storage.</returns>
            <remarks><para>Since the System.Type 'byte' can address more then 2 values used by ILLogicalArray (i.e. '0' and '1'), 
            and the given array is directly be used as storage for the newly created array, undefined behavior can result, if 
            the System.Array given contains values other then 0 or 1. No check is made for this!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(ILNumerics.ILLogicalArray)~System.Boolean">
            <summary>
            Implicitly convert ILLogicalArray of size 1x1 to bool/byte (scalar).
            </summary>
            <param name="A">scalar ILLogicalArray</param>
            <returns>true if A is scalar array holding the only element '01', false otherwise 
            </returns>
            <remarks> if A is null, the function will always return false. If 'A' is empty or not scalar,
            an ILArgumentException will be thrown.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> if A is not scalar</exception>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Int32)~ILNumerics.ILLogicalArray">
            <summary>
            Implicitly convert integer scalar to ILLogicalArray of size 1x1 (scalar).
            </summary>
            <param name="val">scalar value</param>
            <returns>New ILLogicalArray of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_LogicalNot(ILNumerics.ILLogicalArray)">
            <summary>
            invert values of array elements 
            </summary>
            <param name="in1">input array</param>
            <returns>new solid ILLogicalArray, inverted element values</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Serialize(System.IO.Stream)">
            <summary>
            Serialize this ILLogicalArray into stream. 
            </summary>
            <param name="outStream">System.IO.Stream to receive/store this objects data</param>
            <returns>true on success, false on error.</returns>
            <remarks>Use this member to convert the data of this array 
            to persistant state. The storage will automatically determine the 
            state wich will consume less memory and detach itself accordingly. 
            </remarks>
            <example>
            <code>
            FileStream fs = new FileStream("filename", FileMode.Create);
            A.Serialize(fs); 
            fs.Close();
            </code></example>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize an ILLogicalArray from stream 
            </summary>
            <param name="inStream">strem to read from</param>
            <returns>ILLogicalArray deserialized from stream</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.GetShifted(System.Int32)">
            <summary>
            get reference to this array having the dimensions shifted by <c>shiftDimensions</c>.
            </summary>
            <param name="shiftDimensions">number of dimensions to shift this array (to the left for positive values)</param>
            <returns>Referencing ILArray of the same type and size with <c>shiftDimensions</c> dimensions shifted to the left.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.CreateReference">
            <summary>
            Create a full reference from this ILLogicalArray
            </summary>
            <returns>object of real type 'ILLogicalArray' as full reference to this ILLogicalArrays.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.ToString(System.String,System.Int32)">
            <summary>
            output information about this ILLogicalArray
            </summary>
            <param name="s">predefined string, to be used as prefix for output</param>
            <param name="maxLength">number of characters in lines of output</param>
            <returns>string representation of this ILLogicalArray</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.ToString">
            <summary>
            output information about this ILLogicalArray
            </summary>
            <returns>string representation of this ILLogicalArray</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.empty(ILNumerics.Misc.ILDimension)">
            <summary>
            [deprecated] create empty ILLogicalArray 
            </summary>
            <returns>empty ILLogicalArray.</returns>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.NumberTrues">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks> this value caches the number of 'true' elements in this ILLogicalArray. 
            It may be used for information purposes but is actually needed for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.String[])">
            <summary>
            Subarray access for ILArray. Get: Create referencing subarray, 
            Set: alter range of this ILArray with new value elements.
            </summary>
            <paramref name="dims" value="Range specification for subarray elements"/>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int16,System.String[])">
            <summary>
            Subarray access for ILArray and dimension shift
            </summary>
            <paramref name="dims" value="dimension specification"/>
            <value>returns new ILArray as reference subarray to this ILBaseArray</value>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(ILNumerics.ILBaseArray[])">
            <summary>
            subarray access
            </summary>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int16,ILNumerics.ILBaseArray[])">
            <summary>
            ranged subarray access
            </summary>
            <param name="shiftdim">number of dimensions to shift the result</param>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. </returns>
            <remarks>For n-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range. However, if range contains only one array, those indices 
            are interpreted as sequential index access elements. I.e. the elements in the index vector are allowed to 
            range from 0...[NumberOfElements-1]. A vector containing corresponding elements will be returned for this case.
            <para>The indexer may be used for querying single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int32[])">
            <summary>
            Single element access
            </summary>
            <param name="dims">dimensions specifier. int array or comma seperated list.
            If this is a single int element only, this will lead to sequential index access. 
            If dims consist out of at least 2 elements, trailing missing dimensions will be replaced by "0". </param>
            <returns>Scalar ILLogicalArray element pointed to by 'dims'</returns>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.T">
            <summary>
            shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.C">
            <summary>
            create solid array as copy of this array 
            </summary>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.R">
            <summary>
            create solid array as reference to this array 
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILQuickSort">
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolid_IT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolid_IT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscSolidIDX_IT(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescSolidIDX_IT(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will implace be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort">
            <summary>
            Bucket sort algorithm (for internal use)
            </summary>
            <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double})"/></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILBucketSort.BucketSort``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Algorithms.ILKeyMapper{``0,``1},ILNumerics.Algorithms.ILBucketSort.SortMethod)">
            <summary>
            Bucket sort algorithm 
            </summary>
            <param name="input"></param>
            <param name="indices">return corresponding source element indices</param>
            <param name="mapper"></param>
            <param name="method"></param>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort.SortMethod">
            <summary>
            sort method for bucket sorts
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.ConstantLength">
            <summary>
            constant length
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.VariableLenth">
            <summary>
            variable length
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILLapackMKL10_0">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Settings.ILSettings">
            <summary>
            General settings for ILNumerics.Net classes
            </summary>
        </member>
        <member name="F:ILNumerics.Settings.ILSettings.DetachReferences">
            <summary>
            Sets the detaching behavior for referencing storages 
            </summary>
            <remarks> 
            This flag controls, how ILArray objects react on write access.
            Possible values are one of the enum values of ILArray.DetachingBehavior:
            <list>
            <item>
            DetachNever - if used, ILArray's will never automatically detach. This can 
            lead to situations, where altering the elements of one storage also change 
            the elements of another storage, if the second is referencing the same physical
            storage array elements. 
            </item>
            <item>
            DetachOnWrite - Referencing storages will automatically detach 
            themself before attempting to alter any values used. The results are self 
            dereferencing storages which act to the outside world, like they would 
            all consist out of physical storages, but internally save memory by not creating 
            any real copies of arrays as long as it is not neccessary. 
            </item>
            <item>
            DetachAlways - Attempts to create a reference of an existing storage will result 
            in copying the values. This is the way other mathematical engines handle 
            their storages (f.e. Matlab). It consumes more memory, but will most probably 
            lead to increased performance for large computations, since physical storages
            are optimized for faster element access.
            </item>
            <item>DetachSave (default) - This value acts like 'DetachOnWrite' except a storage will not 
            be detached, if it is the only reference to the underlying physical storage. 
            </item>
            </list>
            Special attention is to be made for altering ranges on reference storages. There are 
            cases where setting a value may alter other elements as well. this is true
            for elements "pointing" to the same physical array element. If you dont agree with 
            that behavior, set this switch to 'DetachAlways' so you wont have to worry about 
            storages beeing references anymore. This behavior may be known as similar 
            to other mathematical engines (like MATLAB f.e.).
            
            This flag is set to 'DetachSave' by default.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.ILSettings.MinimumRefDimensions">
            <summary>
            Minimum number of dimensions for Reference storage objects.
            </summary>
            <remarks>
            This parameter influences all overloaded versions of the CreateReference members and subarray creation: 
            If the object requested (the reference specified by range and/or dimension shifts)
            is of less than MinimumRefDimensions non singleton dimensions, the 
            "reference" will be created as real copy, i.e. a solid ILArray an physical storage object. For 
            the defaut value of 2 this will result in an matrix object. For the current 
            implementation using referencing for objects with less then 
            2 non singleton dimensions would be of little use, since fast indexing requires them 
            to hold a copy of all dimension specifiers for an object. Therefore they would 
            consume at least half the memory and more performance for creating them then creating a real copy 
            as physical storage. Use this parameter to make ILNumerics.Net actually create 
            <b>copies</b> and not <b>references</b> of all storage objects with non singleton 
            dimensions less then MinimumRefDimensions.
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.ILSettings.MinimumQuicksortLength">
            <summary>
            determine the minimum length for arrays to be sorted via Quicksort algorithm, smaller arrays are sorted via insertion sort
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.ILSettings.MaxSafeQuicksortRecursionDepth">
            <summary>
            maximal depth a quicksort can go. default: 100 (for array length up to 2^100)
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayDebuggerProxy`1">
            <summary>
            This class is for internal use only. Do not instantiate from this class!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ILNumerics.Native.ILLapackGeneric">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Storage.ILIndexOffset">
            <summary>
            Jagged array for 'fast' random access to full physical storages.
            </summary>
            <remarks>m_indexOffset maps the access indices for each dimension 
            of this object to the indices in the dimensions of the physical 
            storage. This is not the same mor has anything to do with the range object! 
            m_indexOffset rather serves as a fast reference for computing the actual index 
            of an element inside the sequential (physical) storage. 
            Therefore m_indexOffset is assembled out of 
            <list type="bullet">
            <item>
            	an array of int arrays reflecting the entries in m_dimension,
            	i.e. the shifted + trimmed dimensions this storage makes public. 
            </item>
            <item>
            	each array element stands for each dimension of THIS 
            	reference storage. Dimensions at the end are abbreviated.
            </item>
            <item>
            	for each dimension there is an int[] array holding the 
            	offsets for each element of that dimension inside the 
            	underlying physical storage.
            </item>
            </list>
            In order to compute the element index for an element of this storage 
            inside the physical storage, it is only neccessary to add all corresponding 
            entries for each dimension of m_indexOffset: 
            <code>
            ILRefStorage b = a.CreateReference();
            ...
            double val = b["1,5,3"]; // will result in: 
            val = a.m_data(  m_indexOffset.Data[0][1] 
            			   + m_indexOffset.Data[1][5] 
            			   + m_indexOffset.Data[2][3]) // to be queried
            </code>
            the dimensions (i.e. int[] array elements) of m_indexOffset 
            are shifted according to the dimensions this storage is shifted 
            in relation to its referenced storage. 
            Therefore they do NOT neccessarily correspond to the order 
            in which the dimension of the physical storage exist. Due to 
            performance reasons there is no need to (un)shift incoming 
            indexing requests in order to map to physical storage indices.
            Those request must always be in the dimension order, which is 
            reflected from this storage to the outside world.
            </remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.#ctor(System.Int32[][],System.Int32[])">
            <summary>
            Constructor creating ILIndexOffset from jagged int[][] array
            </summary>
            <param name="idxOffset">Jagged int[][] array by reference. This parameter 
            will be copied into the internal array. </param>
            <param name="regularySpacing">regulary spacing for each dimension</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.#ctor(ILNumerics.Storage.ILIndexOffset)">
            <summary>
            Copy construcotr
            </summary>
            <param name="idxOffset">ILIndexOffset to be copied</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.RegularySpacing(System.Int32)">
            <summary>
            Are the elements of dimension specified regulary spaced? 
            </summary>
            <param name="dim">Dimension index (zero based)</param>
            <returns>if the elements are regulary spaced, returns the spacing.
            If the elements are unregulary spaced, the return value will be int.MinValue.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.GetDimensions">
            <summary>
            Dimension represented by this ILIndexOffset
            </summary>
            <returns>Dimension object</returns>
            <remarks>This function will introduce a performance penalty, 
            since the dimension object will get reconstructed every time called. 
            One should therefore cache the dimension externally, if needed.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.Map(ILNumerics.Storage.ILRange,System.Int32)">
            <summary>
            Evaluates (maps) ILRange on my IndexOffsets and return shifted version. 
            </summary>
            <param name="range">range object specifying the selection to be addressed 
            relative to my indices. Range's dimensions may be the same size or less than my  
            dimensions. If range is null, the full storage will be addressed. </param>
            <param name="shift">Number of dimensions to shift mapped range</param>
            <returns>Mapped ILIndexOffset object. It may be used for direct addressing the 
            data positions inside the physical storage. </returns>
            <remarks>TODO : prevent the global offset inside physicalStorage, holded in the 
            first dimensions of m_indexOffset 
            to be shifted to another position if shift != 0!!!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.Map(System.Int32)">
            <summary>
            map incoming long index to destination index of physical storage 
            </summary>
            <param name="idxIn">Index relative to this IndexOffset storage. 
            ILIndexOffset reflects an sequential storage to the outside world. 
            Therefore idxIn is as this was an sequential storage too.</param>
            <returns>Index in underlying physical storage.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.IndexFromArray(System.Int32[])">
            <summary>
            Transform dimension position into sequential index
            </summary>
            <param name="idx">int array of arbitrary length</param>
            <returns>Index number pointing to the value's position in sequential storage if it exist. Negative value otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIndexOffset.ToString">
            <summary>
            Give string representation for this ILIndexOffset
            </summary>
            <returns>string representing this ILIndexOffset</returns>
        </member>
        <member name="P:ILNumerics.Storage.ILIndexOffset.Item(System.Int32,System.Int32)">
            <summary>
            index acces for ILIndexOffset
            </summary>
            <param name="dim">dimension. if this is larger than the number of (trimmed)
            dimensions currently referenced by this ILIndexOffset, 0 will be returned. 
            THis corresponds to a singleton dimension. </param>
            <param name="idx"></param>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Storage.ILIndexOffset.Item(System.Int32)">
            <summary>
            Get all index offsets for dimension specified
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Storage.ILIndexOffset.Length">
            <summary>
            number of dimensions this ILIndexOffset is referencing
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILIndexOffset.NonSingleton">
            <summary>
            number of non-singleton dimensions
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILIndexOffset.NumberOfElements">
            <summary>
            give number of elements for arrays described by this ILIndexOffset
            </summary>
        </member>
        <member name="T:ILNumerics.complex">
            <summary>
            floating point complex value data type of double precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex double 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double brings (abs, log, sqrt, tan etc.),
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (f.e. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to complex value into system 
            value types.</remarks>
        </member>
        <member name="F:ILNumerics.complex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.i">
            <summary>
            imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.complex.#ctor(System.Double,System.Double)">
            <summary>
            Constructor creating a new complex value
            </summary>
            <param name="real">real part</param>
            <param name="imag">imagginary part</param>
        </member>
        <member name="M:ILNumerics.complex.Equals(System.Object)">
            <summary>
            are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.complex.GetHashCode">
            <summary>
            Hash code of this system object
            </summary>
            <returns>Hash code of this system object</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Double)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Double)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Double)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Double)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Double)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Double)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Double)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Double)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Single)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Single)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Single)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Single)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Single)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Single)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Single)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Single)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Char)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Char)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Char)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Char)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Char)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Char)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Char)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Char)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Char)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Char)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Byte)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Byte)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Byte)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Byte)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Byte)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Byte)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Double,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Double,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Double,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Double,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Double,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Double,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Double,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Double,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt64,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt64,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt64,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt64,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt64,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt64,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt32,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt32,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt32,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt32,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt32,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt32,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt16,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt16,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt16,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt16,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt16,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt16,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int64,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int64,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int64,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int64,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int64,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int64,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int32,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int32,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int32,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int32,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int32,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int32,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int16,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int16,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int16,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int16,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int16,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int16,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int16,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int16,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int16,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int16,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Single,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Single,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Single,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Single,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Single,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Single,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Single,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Single,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Char,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Char,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Char,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Char,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Char,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Char,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Char,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Char,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Char,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Char,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Byte,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Byte,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Byte,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Byte,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Byte,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Byte,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_UnaryNegation(ILNumerics.complex)">
            <summary>
            unary minus operator
            </summary>
            <param name="in1">complex input</param>
            <returns>complex number similar to in1, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Double)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Single)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as the a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(ILNumerics.fcomplex)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number beeing a copy of the real and imaginary parts of a.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Byte)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Char)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int16)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int32)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int64)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.UInt16)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.UInt32)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.UInt64)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Double">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>double number with the real part of a </returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Single">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast from double to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~ILNumerics.fcomplex">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>float complex number with the real and imaginary parts beeing a copy of a </returns>
            <remarks>The real and imaginary parts are the result of a cast to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Byte">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to byte.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Char">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to char.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int16">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to Int16.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int32">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to Int32.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int64">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to Int64.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.UInt16">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to UInt16.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.UInt32">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to UInt32.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.UInt64">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of input </returns>
            <remarks>the return value is the result of a cast to UInt64.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Abs(ILNumerics.complex)">
            <summary>
            Absolute value of input
            </summary>
            <param name="input">input value</param>
            <returns>The absolute value of the input</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle(ILNumerics.complex)">
            <summary>
            Phase angle of complex number
            </summary>
            <param name="input">input value</param>
            <returns>The phase angle of the input</returns>
            <remarks>For the result the Atan2 function of the <see cref="T:System.Math"/> class is used.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Atan(ILNumerics.complex)">
            <summary>
            Arcus tangens of complex input
            </summary>
            <param name="input">complex input</param>
            <returns>Arcus tangens of complex input</returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.complex.Acos(ILNumerics.complex)">
            <summary>
            Arcus cosinus of complex input
            </summary>
            <param name="input">complex input</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos(System.Double)">
            <summary>
            Arcus cosinus of input
            </summary>
            <param name="input"> input value</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(System.Double)">
            <summary>
            Arcus sinus of complex input
            </summary>
            <param name="input"> input value</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(ILNumerics.complex)">
            <summary>
            Arcus sinus of input
            </summary>
            <param name="input">input value</param>
            <returns>Arcus sinus of  input</returns>
        </member>
        <member name="M:ILNumerics.complex.Ceiling(ILNumerics.complex)">
            <summary>
            round towards positive infinity
            </summary>
            <param name="input">input value</param>
            <returns>result is the next integer value greater then input</returns>
            <remarks>ILMath.Ceiling operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Floor(ILNumerics.complex)">
            <summary>
            round towards negative infinity
            </summary>
            <param name="input">input value</param>
            <returns>result is the next integer value lower then input</returns>
            <remarks>ILMath.Floor operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Round(ILNumerics.complex)">
            <summary>
            rounds towards nearest integer
            </summary>
            <param name="input">input value</param>
            <returns>result is the nearest integer value for input</returns>
            <remarks>ILMath.Round operates in both: real and imaginary parts deperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Sign(ILNumerics.complex)">
            <summary>
            Signum function
            </summary>
            <param name="input">complex input </param>
            <returns>result as input / Abs(input)</returns>
            <remarks>Sign(input) with input beeing complex returns the projection onto
            the unit circle. If input is 0+0i the result will be 0+0i.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Truncate(ILNumerics.complex)">
            <summary>
            truncate a floating point complex value
            </summary>
            <param name="input">input</param>
            <returns>integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Cos(ILNumerics.complex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">input</param>
            <returns>cosinus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Cosh(ILNumerics.complex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>cosinus hyperbolicus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sin(ILNumerics.complex)">
            <summary>
            Sinus
            </summary>
            <param name="input">input</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sinh(ILNumerics.complex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Exp(ILNumerics.complex)">
            <summary>
            complex exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>result of exp(exponent)</returns>
            <remarks>For complex exponents, exp(exponent) is computed by
            <para>complex.FromPol(Math.Exp(exponent.real), exponent.imag)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,System.Double)">
            <summary>
            complex power for real exponent
            </summary>
            <param name="input">basis </param>
            <param name="exponent">exponent</param>
            <returns>result of input power exponent</returns>
            <remarks>the computation will be carried out by 
            <para>exp(log(input) * exponent)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double,System.Double)">
            <summary>
            complex power - real basis, real exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>complex number.</returns>
            <remarks>The result will be a complex number. For negative basis 
            the basis will be converted to a complex number and the power 
            will be computed in the complex plane.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            complex power - complex exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>complex number exp(log(basis) * exponent).</returns>
            <remarks>The result will be the complex number exp(log(basis) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(System.Double)">
            <summary>
            Square root
            </summary>
            <param name="input">input</param>
            <returns>the square root of input</returns>
            <remarks>If input is smaller than 0.0, the computation will be done in the complex plane. </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(ILNumerics.complex)">
            <summary>
            Square root
            </summary>
            <param name="input">input</param>
            <returns>the square root of input</returns>
            <remarks>numerical recipes in C: Appendix C </remarks>
        </member>
        <member name="M:ILNumerics.complex.Tan(ILNumerics.complex)">
            <summary>
            Tangens
            </summary>
            <param name="input">input</param>
            <returns>Tangens of input</returns>
            <remarks>the tangens is 
            <para>sin(input) / cos(input)</para>
            if cos(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Tanh(ILNumerics.complex)">
            <summary>
            Tangens hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>Tangens hyperbolicus</returns>
            <remarks>the tangens hyperbolicus is 
            <para>sinh(input) / cosh(input)</para>
            if cosh(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(ILNumerics.complex)">
            <summary>
            complex logarithm 
            </summary>
            <param name="input">input</param>
            <returns>complex logarithm of input</returns>
            <remarks>the real part of the logarithm is computed by 
            <para>log (abs (input))</para>
            <para>The imaginary part holds the phase of input.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(System.Double)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(System.Double)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.complex.Log2(System.Double)">
            <summary>
            Logarithm of base 2 of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(ILNumerics.complex)">
            <summary>
            Logarithm of base 10
            </summary>
            <param name="input">input</param>
            <returns>logarithm of base 10</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.Log2(ILNumerics.complex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">input</param>
            <returns>logarithm of base 2.</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.FromPol(System.Double,System.Double)">
            <summary>
            convert polar notation into cartesian notation
            </summary>
            <param name="magnitude">magnitude</param>
            <param name="angle">phase</param>
            <returns>complex value having magnitude and phase</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString">
            <summary>
            convert to string
            </summary>
            <returns>string displaying the comlex number (full precision)</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString(System.Int32)">
            <summary>
            print formated output of this number, determine number of digits
            </summary>
            <param name="digits">number of digits</param>
            <returns>formated output</returns>
        </member>
        <member name="M:ILNumerics.complex.Abs">
            <summary>
            magnitude of this complex instance
            </summary>
            <returns>magnitude</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle">
            <summary>
            Phase of this complex instance
            </summary>
            <returns>phase</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos">
            <summary>
            Arcus cosinus of this complex instance
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin">
            <summary>
            Arcus sinus of this complex instance
            </summary>
            <returns>arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Exp">
            <summary>
            exponential / power of base e
            </summary>
            <returns>power of base e</returns>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double)">
            <summary>
            complex power real exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>new complex number with result</returns>
            <remarks>If this instance is a and the exponent is e than 
            the result will be the complex number exp(log(a) * e). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex)">
            <summary>
            complex power - complex exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>complex number exp(log(this) * exponent).</returns>
            <remarks>If this instance is a than 
            the result will be the complex number exp(log(a) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt">
            <summary>
            Square root of this complex value
            </summary>
            <returns>square root of this complex value</returns>
        </member>
        <member name="M:ILNumerics.complex.Log">
            <summary>
            logarithm of base e
            </summary>
            <returns>logarithm of base e</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.IsNaN(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.complex.IsInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsPositiveInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are pos.nfinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsNegativeInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsFinite(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are finite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.complex.iszero">
            <summary>
            test if both of real or imaginary parts are 0
            </summary>
            <returns>true if real and imag part is 0</returns>
        </member>
        <member name="P:ILNumerics.complex.conj">
            <summary>
            complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.complex.INF">
            <summary>
            positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.complex.NaN">
            <summary>
            complex quantity, marked as beeing "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.ILCell">
            <summary>
            ILCell : container base class holding arbitrary ILBaseArray objects 
            </summary>
            <remarks>
            ILCell is derived from <![CDATA[ILArray<ILBaseArray>]]>. Therefore any 
            ILBaseArray may be used as inner element type. No further constraints are made 
            for the elements. All array types used inside ILNumerics.Net (e.g.<![CDATA[ILArray<BaseT>]]>) 
            inherit from ILBaseArray.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.ILBaseArray[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.ILArray{ILNumerics.ILBaseArray})">
            <summary>
            constructor creating ILCell from base type
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(System.Int32[])">
            <summary>
            Create empty cell object 
            </summary>
            <param name="size">dimensions. This may be a comma separeted list
            or a int array holding dimension lengths.</param>
        </member>
        <member name="M:ILNumerics.ILCell.CreateReference">
            <summary>
            Deep reference from this ILCell
            </summary>
            <returns>ILCell having all elements replaced with references to their originals.</returns>
            <remarks>For all elements of supported types (ILBaseArray,ILCell), the reference creation will be done 
            recursively. </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.DeepReferenceElements">
            <summary>
            walk through all elements of this ILCell and replace them with references to their original
            </summary>
            <returns>this object having alle elements "referenced"</returns>
            <remarks>This may be seen as a deep reference (in distinction to deep copy). Elements 
            of type ILCell will recursevely get changed into references. </remarks>
        </member>
        <member name="P:ILNumerics.ILCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.Int32[])">
            <summary>
            get/set/remove single element 
            </summary>
            The type of access depends on the length of indices. 
            <paramref name="indices" value="index to element"/>
            <value>inner element, new inner element or null</value>
            <remarks>If indices contains only one element, the array will be accessed via sequential index access. 
            This is sometimes called "linear" index access also. Sequential index access reflects the index of internal storage 
            the way the data are actually organized in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example><code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A[2] gives: 3.0
            </code>But the transpose 
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>For get access the array returned will be a reference to the element addressed.</para>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;BaseT&gt; the array returned will be a reference to the original array (same type and size).</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original element stored.</item>
            <item>for other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to elements of elements of this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vector(10,200); 
            innerCell[1] = ILArray&lt;int&gt;(-10,-20,-30);
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new ILArray&lt;string&gt;("foobla"); 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para>
            <para>For set access the element <code>value</code> will directly be stored in the ILCell. No copy/reference will be done for it!</para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">address range</param>
            <returns>reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore an empty array 
            (of the same type) or null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than null for this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[null,2] = null;  // &gt;- will remove the third column (index '2') from the cell.
            C[null,ILMath.vector(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not null! 
            </code></example></para>
            <para>In case of removal the object will be changed into a reference array having the only removal dimension decreased.</para>
            <para>The general behaviors of this acces methods are compatible with corresponding Matlab access: a(:) = []. </para>
            <para></para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.String[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">address range. String array with each element holding a comma seperated list of indices for each dimension. </param>
            <returns>reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks><para>The colon ':' is used, to identify the whole dimension. If used, the colon must be the only char in the dimension string.</para>
            <para><c>indices</c> may be a single string having dimension strings seperated by semicolon ';'</para>
            Query access: for N-dimensional cell arrays missing trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contain index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore an empty array 
            (of the same type) or null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than ":" for this case. If <c>indices</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":;2"] = null;  // &gt;- will remove the third column (index '2') from the cell.
            C[":;2,5"] = null;  &gt;- will remove columns 3...6
            C["1;1"] = null; &gt;- will produce an error. Only one dimension can be specified not null! 
            </code></example></para>
            <para>In case of removal the object will be changed into a reference array having the only removal dimension decreased.</para>
            <para>The general behaviors of this access methods are compatible with corresponding Matlab access: a(:) = []. </para>
            <para></para></remarks>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithmEventArgs">
            <summary>
            Information arguments for events to be fired from within ILAlgorithms
            </summary>
            <remarks>ILAlgorithmEventArgs carry some additional parameter to inform 
            clients of ILAlgorithms in case of state changes. </remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Progress">
            <summary>
            current progess state. This number is in the range 0 ... 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Message">
            <summary>
            A textual message associated with the current event
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.State">
            <summary>
            The state of the ILAlgorithm. This is a constant out of the enum ILAlgorithmRunningStates
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Cancel">
            <summary>
            Cancel the excecution of the sender of the event. 
            </summary>
            <remarks>If set to true, the sender (a ILAlgorith) will cancel and return from excecution.</remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Parameter">
            <summary>
            Additional user defined data to be transferred to event registrar
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithmEventArgs.#ctor(System.Double,System.String,ILNumerics.ILAlgorithmState)">
            <summary>
            Construct a new ILAlgorithmEventArgs object for delivery
            </summary>
            <param name="progress">Current progress</param>
            <param name="message">A message to be included for the receiver of the event.</param>
            <param name="state">The state of the algorithm. Must be one out of the enum <typeparamref name="ILAlgorithmRunningState"/></param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithmEventArgs.#ctor(System.Double,System.String,ILNumerics.ILAlgorithmState,System.Object)">
            <summary>
            Construct a new ILAlgorithmEventArgs object for delivery
            </summary>
            <param name="progress">Current progress</param>
            <param name="message">A message to be included for the receiver of the event.</param>
            <param name="parameter">Additional user defined data to be transferred to event registrar</param>
            <param name="state">The state of the algorithm. Must be one out of the enum <typeparamref name="ILAlgorithmRunningState"/></param>
        </member>
        <member name="T:ILNumerics.ILDetachingBehavior">
            <summary>
            Switches to set the detaching behavior for referencing storages. 
            </summary>
            <remarks>
            Special attention is to be made for altering ranges on reference storages. There are 
            cases where setting a value may alter other elements as well. This is true
            for elements "pointing" to the same physical array elements. If you dont want 
            this behavior, set this switch to 'DetachAlways' so you wont have to worry about 
            storages beeing references anymore. This behavior may be known as similar 
            to other mathematical engines (like Matlab f.e.).
            
            The default switch is 'DetachOnWrite'.</remarks>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachNever">
            <summary>
            if used, ILArray's will never automatically detach. This can 
            lead to situations, where altering the elements of one array also change 
            the elements of another array, if the second is referencing the same solid
            array elements. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachOnWrite">
            <summary>
            (default) - Referencing arrays will automatically detach 
            themself before attempting to alter any values used. The results are self 
            dereferencing arrays which act to the outside world, like they would 
            all consist out of solid storages, but internally save memory by not creating 
            any real copies of arrays as long as it is not absolutely neccessary.
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachAlways">
            <summary>
            Attempts to create a reference of an existing array will result 
            in copying the values. This is the way other (native) mathematical engines usually handle 
            their storages. It consumes more memory, but will sometimes 
            lead to increased performance for large computations, since physical storages
            are optimized for faster element access.
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachSave">
            <summary>
            This value acts like 'DetachOnWrite' except a storage will not 
            be detached, if it is the only reference to the underlying physical storage.
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayStreamSerializationFlags">
            <summary>
            Defines the way ILArrays are serialized to stream. Used by function ToStream. 
            </summary>
            <seealso cref="M:ILNumerics.ILArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)"/>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Serial">
            <summary>
            print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Formatted">
            <summary>
            print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. ILArray's are capable of constructing from streams containing this type of 
            output. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Matlab">
            <summary>
            export whole array instance to matlab 5.0 format
            </summary>
        </member>
        <member name="T:ILNumerics.FFTModes">
            <summary>
            [deprecated]
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT3DReal">
            <summary>
            3-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT3DComplex">
            <summary>
            3-dim fft, complex input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT2DReal">
            <summary>
            2-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT2DComplex">
            <summary>
            2-dim fft, complex input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT1DReal">
            <summary>
            1-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT1DComplex">
            <summary>
            1-dim fft, complex input
            </summary>
        </member>
        <member name="T:ILNumerics.MatrixProperties">
            <summary>
            possible properties for matrices 
            </summary>
            <remarks><para>These properties may be returned by function overloads receiving a MatrixProperties parameter by reference. The properties must be checked inside the function, the result is returned also.</para>
            <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para></remarks>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hermitian">
            <summary>
            hermitian matrix 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
            <summary>
            positive definite
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
            <summary>
            upper triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
            <summary>
            lower triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Square">
            <summary>
            square matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Diagonal">
            <summary>
            diagonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Singular">
            <summary>
            the matrix is singular 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hessenberg">
            <summary>
            hessenberg matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Householder">
            <summary>
            householder matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unitary">
            <summary>
            unitary matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthogonal">
            <summary>
            orthogonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthonormal">
            <summary>
            orthonormal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.RankDeficient">
            <summary>
            the matrix has deficient rank
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.None">
            <summary>
            the matrix has no special properties
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unknown">
            <summary>
            no specific properties known (default)
            </summary>
        </member>
        <member name="T:ILNumerics.ILAlgorithmState">
            <summary>
            Possible states for <see cref="T:ILNumerics.Algorithms.ILAsyncAlgorithm"/>
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Initialized">
            <summary>
            The algorithm was newly created
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Running">
            <summary>
            the algorithm is running normally 
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Suspended">
            <summary>
            the algorithm was temporarily suspended
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Finished">
            <summary>
            the algorithm finished successfully
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Canceled">
            <summary>
            the algorithm was cancelled
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLParameter">
            <summary>
            MKL configuration parameters (constant definitions)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLValues">
            <summary>
            MKL configuration values (constant definitions) 
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLImports">
            <summary>
            import functions (pinvoke)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILMKLFFT">
            <summary>
            Wrapper for FFT interface using MKL 10_03
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterSingle">
            <summary>
            Extensive numerical machine parameter infos - single precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ibeta">
            <summary>
            radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.it">
            <summary>
            number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.irnd">
            <summary>
            rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>under-/ overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ngrd">
            <summary>
            number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.machep">
            <summary>
            exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.negep">
            <summary>
            exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.iexp">
            <summary>
            number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.minexp">
            <summary>
            smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.maxexp">
            <summary>
            smalles power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.eps">
            <summary>
            distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.epsneg">
            <summary>
            alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmin">
            <summary>
            smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmax">
            <summary>
            largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterDouble">
            <summary>
            Extensive numerical machine parameter infos - double precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ibeta">
            <summary>
            radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.it">
            <summary>
            number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.irnd">
            <summary>
            rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>under-/ overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ngrd">
            <summary>
            number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.machep">
            <summary>
            exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.negep">
            <summary>
            exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.iexp">
            <summary>
            number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.minexp">
            <summary>
            smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.maxexp">
            <summary>
            smalles power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.eps">
            <summary>
            distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.epsneg">
            <summary>
            alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmin">
            <summary>
            smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmax">
            <summary>
            largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILLapackGenLinux">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Storage.RangeSide">
            <summary>
            Helper class defining ranges for subarray access (internal use only)
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RangeSide.Right">
            <summary>
            Right side range for subarray creation. limited to dimension length 
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RangeSide.Left">
            <summary>
            left side range for assignment. may exeeds dimension length.
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILRange">
            <summary>
            ILRange specify the dimensions for an ILArray object if it is a reference.
            </summary>
            <description>ILRange is used to specify the parts of the original dimensions
            the ILArray objects referes to if it is a reference to another ILArray object. 
            ILRange objects do not know about a 'maximum size'. They dont know the dimensions of the objects,
            they get applied to. Therefore the 'colon' specifier will get stored and evaluated at the 
            time, the range gets assigned to an ILArray Object. </description>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_nrDims">
            <summary>
            number of dimensions defined by this range
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_regularSpaced">
            <summary>
            array defining, if the dimensions of this range are regulary spaced and which spacing the have
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_expanding">
            <summary>
            internal field, stores expanding flag
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_expandDimensions">
            <summary>
            internal field, stores sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_numberOfElements">
            <summary>
            internal field stores the number of elements addressed by this ILRange 
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_nonSingletonDimensions">
            <summary>
            internal field, caches the number of non singleton dimensions
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_range">
            <summary>
            hold ranges as a simple Array of int[] Arrays.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Storage.ILRange)">
            <summary>
            Copy Constructor
            </summary>
            <param name="oldRange">Create new instance from existing ILRange</param>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Misc.ILDimension,ILNumerics.Storage.RangeSide,ILNumerics.ILBaseArray[])">
            <summary>
            Construct ILRange from arrays of indices.
            </summary>
            <param name="ranges">Array of indices. Each element of ranges corresponds to
            one dimension for the new range. ranges must be vector or scalar arrays.</param>
            <param name="side">specifies if the range is intended for left side (assignment) 
            or ride side (subarray creation).</param>
            <param name="dimensions">dimension for destination array. Needed for limit information. </param>
            <remarks>the elements of ranges must either be scalar or vectors (row- or column doesn't matter) or 'null'. Elements 
            inside the ILBaseArrays will be interpreted as indices into the dimension with the same 
            index number. The indices may be of any numeric value type.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Misc.ILDimension,ILNumerics.Storage.RangeSide,System.String[])">
            <summary>
            Creates ILRange from string array. Replace all occurences of "end" with corrensponding 
            dimension length. Replace all dimensions consisting only out off ":" with "1:end"
            </summary>
            <param name="dims">dimension specification</param>
            <param name="rng">String array with range specification (may contains "end")</param>
            <param name="side">determine, if this range is applied to left side or right side expressions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Map(System.Int32[],System.Int32[]@)">
            <summary>
            Evaluates (maps) index array on my range. 
            </summary>
            <param name="idx">int array indexing location inside this range</param>
            <param name="retIdx">(output) also return the result into array given</param>
            <returns>Mapped int[] array. It can be used for direct addressing the physical storage object.</returns>
            <remarks>retIdx must be at least of length m_nrDims. No check is made for that!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Copy">
            <summary>
            copy constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.GetDimensions">
            <summary>
            Create trimmed ILDimension from indices in ILRange object
            </summary>
            <returns>new ILDimension object with the neccessary size to 
            hold all indices in this range</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.BuildSequentialArray">
            <summary>
            built a plain physical copy of the ranges stored in m_range in sequential order
            </summary>
            <returns>int array holding the whole m_range information in sequential order</returns>
            <remarks>This reordering is convinient for "marshaling" the multidimensional array to C.
            The format of the returned (1 dim.) array is: 
            <list type="bullet">
            <item>1 int : the number of dimensions</item>
            <item>X int : [nrOfDimensions] int holding the number of int for each dimension</item>
            <item>Y int : all the int values for each dimension after each other </item></list> 
            The overall size of the returned array is therefore: nrOfElements + nrOfDimensions + 1, 
            where nrOfElements is the sum of all elements in each dimension of m_range.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Spacing(System.Int32)">
            <summary>
            Distance between adjecent samples for this range
            </summary>
            <param name="dimIdx">dimension index to get spacing for</param>
            <returns>Spacing of samples inside the dimension if range would be applyied to 
            it or negative value if the range cannot produce an 
            "BLAS-able" reference storage.</returns>
            <remarks><para>For solid arrays, this always reflects the storage 
            structure of the array. I.e. 1  will be returned for the first 
            dimension (dimIdx = 0), for the second (dimIdx = 1) etc.</para> 
            <para>For reference storages this may or may not hold. It does 
            however only hold, if the range the array was constructed of 
            was regulary spaced.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Resize(System.Int32)">
            <summary>
            resize the number of dimensions this ILRange holds
            </summary>
            <param name="nrDims">new number of dimensions</param>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Expanding">
            <summary>
            true for left side ranges, if at least one dimension must be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.ExpandDimensions">
            <summary>
            array with sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.NumberOfDimensions">
            <summary>
            Get number of dimensions described by this ILRange
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.NumberOfElements">
            <summary>
            Number of elements addressed by this ILRange
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.nonSingletonDimensions">
            <summary>
            Number of non singleton Dimensions in this range object 
            </summary>
            <remarks>may be used to verify the space needed to store values referenced by this range</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.RangeArray">
            <summary>
            for performance reasons: give reference to internal array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32)">
            <summary>
            Index access for ILRange objects. Set/returns Index array for specifyied dimension.
            </summary>
            <remarks>the reference of the internal onject will be returned!</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32,System.Int32)">
            <summary>
            Index access for ILRange objects. returns the destIndex destination dimension for dimension specifyied by dimNr.
            </summary>
            <remarks>This acces is readonly!</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Limits">
            <summary>
            length of all dimensions of this range
            </summary>
            <remarks>This property is readonly. Keep in mind, it does not cache the values.</remarks>
        </member>
        <member name="T:ILNumerics.Storage.RegularSpacedList">
            <summary>
            helper class used to collect range entries for one dimension and 
            check for regular spacing while adding items
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_regularSpacing">
            <summary>
            internal field, stored the current value of regular spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_isRegularSpaced">
            <summary>
            internal field, stores flag on regular spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_lastValue">
            <summary>
            internal field, keeps the last value for comparison
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.#ctor">
            <summary>
            Constructor creating emtpy ILRegularSpacedList
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.#ctor(System.Int32)">
            <summary>
            Constructor creating emtpy ILRegularSpacedList, given capacity
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.Add(System.Int32)">
            <summary>
            Add elements to this list
            </summary>
            <param name="value">new element</param>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.Clear">
            <summary>
            reset / clear this list
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.RegularSpacedList.RegularSpacing">
            <summary>
            Give the spacing between elements of this list
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.RegularSpacedList.IsRegularSpaced">
            <summary>
            Get if all elements of this list are regulary spaced (in incoming order)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILCPUID">
            <summary>
            CPUID class - determine machine properties, wraps ILCPUID binary with C/assembler helper
            </summary>
            <remarks>This class will determine extended processor properties once classes of 
            ILNumerics.Net are first time used. It helps choosing the right processor 
            specific binaries for LAPACK and BLAS. 
            </remarks>
        </member>
        <member name="M:ILNumerics.Native.ILCPUID.check_IDProc(System.String@,System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            interop call to ILCPUID binary, get machine properties
            </summary>
            <param name="vendorString">[output] vendor string</param>
            <param name="eax">[output] register a</param>
            <param name="ebx">[output] register b</param>
            <param name="ecx">[output] register c</param>
            <param name="edx">[output] register d</param>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_vendor">
            <summary>
            internal field, caches vendor string
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_family">
            <summary>
            internal field, caches processor familiy name
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_extFamily">
            <summary>
            internal field, caches extended processor familiy name
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_model">
            <summary>
            internal field, caches model
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_brand">
            <summary>
            internal field, caches brand
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_cpuCount">
            <summary>
            internal field, caches number of processors
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_MMX">
            <summary>
            internal field, caches if MMX extension is available
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_SSE">
            <summary>
            internal field, caches if SSE extension is available
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_SSE2">
            <summary>
            internal field, caches if SSE2 extensions are available
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILCPUID.m_SSE3">
            <summary>
            Get, if SSE3 extensions are available
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILCPUID.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILCPUID.ToString">
            <summary>
            write most important information gathered for this CPU
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.vendor">
            <summary>
            Vendor string
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.family">
            <summary>
            Processor family name
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.ExtFamily">
            <summary>
            extended processor familiy description
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.Model">
            <summary>
            Processor model
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.Brand">
            <summary>
            Processor brand
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.CPUCount">
            <summary>
            Number of processors
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.MMX">
            <summary>
            Get, if MMX extensions are available
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.SSE">
            <summary>
            Get, if SSE extensions are available
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.SSE2">
            <summary>
            Get, if SSE2 extensions are available
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILCPUID.SSE3">
            <summary>
            internal field, caches if SSE3 extensions are available
            </summary>
        </member>
        <member name="T:ILNumerics.fcomplex">
            <summary>
            floating point complex value data type of float (single) precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex float 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double (!) brings (abs, log, sqrt, tan etc.) for 
            float precision complex,
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (f.e. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to fcomplex value into system 
            value types. </remarks>
        </member>
        <member name="F:ILNumerics.fcomplex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.i">
            <summary>
            imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.fcomplex.#ctor(System.Single,System.Single)">
            <summary>
            Construct new float complex number
            </summary>
            <param name="real">real part</param>
            <param name="imag">imaginary part</param>
        </member>
        <member name="M:ILNumerics.fcomplex.Equals(System.Object)">
            <summary>
            are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.GetHashCode">
            <summary>
            Give HashCode of this system object
            </summary>
            <returns>HashCode of this system object</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.UInt64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.UInt32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.UInt16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Single)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Single)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Single)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Single)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Char)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Char)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Char)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Char)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Char)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Char)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Char)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Char)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Char)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Char)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Double)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Double)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Double)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Double)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.UInt64,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.UInt32,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.UInt16,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int16,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Single,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Single,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Single,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Single,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Char,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Char,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Char,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Char,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Char,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Char,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Char,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Char,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Char,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Char,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_UnaryNegation(ILNumerics.fcomplex)">
            <summary>
            unary minus operator
            </summary>
            <param name="in1">fcomplex input</param>
            <returns>fcomplex number similar to in1, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs(ILNumerics.fcomplex)">
            <summary>
            Magnitude value of float complex number
            </summary>
            <param name="input">complex number</param>
            <returns>magnitude of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle(ILNumerics.fcomplex)">
            <summary>
            angle of complex number
            </summary>
            <param name="input">complex number to compute angle of</param>
            <returns>angle of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)">
            <summary>
            Arcus cosinus for float complex number
            </summary>
            <param name="input">input</param>
            <returns>arcus cosinus of input</returns>
            <remarks>The arcus cosinus of a complex number is computed by
            <para>Log(Sqrt(input^2 - 1) + input) * i </para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(System.Single)">
            <summary>
            arcus cosinus of real number
            </summary>
            <param name="input"></param>
            <returns>arcus cosinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(System.Single)">
            <summary>
            arcus sinus of real number
            </summary>
            <param name="input"></param>
            <returns>arcus sinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)">
            <summary>
            Arcus sinus for complex number
            </summary>
            <param name="input">input</param>
            <returns>arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)">
            <summary>
            Power of base e for float complex number
            </summary>
            <param name="input">float complex input</param>
            <returns>result of Exp(input)</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,System.Double)">
            <summary>
            fcomplex power real exponent
            </summary>
            <param name="input">basis </param>
            <param name="exponent">exponent</param>
            <returns>new fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double,System.Double)">
            <summary>
            complex power - real basis, real exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>complex number.</returns>
            <remarks>The result will be a fcomplex number. For negative basis 
            the basis will be converted to a fcomplex number and the power 
            will be computed in the fcomplex plane.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Power: complex base, complex exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>result of basis^exponent</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(System.Single)">
            <summary>
            Square root of real input
            </summary>
            <param name="input">input</param>
            <returns>square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(ILNumerics.fcomplex)">
            <summary>
            Square root of complex number
            </summary>
            <param name="input">input</param>
            <returns>square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)">
            <summary>
            Tangens of float complex number
            </summary>
            <param name="input">input</param>
            <returns>Tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)">
            <summary>
            Tangens hyperbolicus of float complex input
            </summary>
            <param name="input">input</param>
            <returns>Tangens hyperbolicus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(ILNumerics.fcomplex)">
            <summary>
            Logarithm of complex input
            </summary>
            <param name="input">input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(ILNumerics.fcomplex)">
            <summary>
            Logarithm to base 10
            </summary>
            <param name="input">input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(ILNumerics.fcomplex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(System.Single)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(System.Single)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(System.Single)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">input</param>
            <returns>complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.FromPol(System.Single,System.Single)">
            <summary>
            convert from polar to cartesian form
            </summary>
            <param name="magnitude">magnitude</param>
            <param name="angle">angle</param>
            <returns>float complex number with magnitude <c>magnitude</c> 
            and phase <c>angle</c></returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString">
            <summary>
            Convert this float complex number to string 
            </summary>
            <returns>string representation of this float complex number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString(System.Int32)">
            <summary>
            print formated output of this number, determine number of digits
            </summary>
            <param name="digits">number of digits</param>
            <returns>formated output</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs">
            <summary>
            Magnitude of this float complex number
            </summary>
            <returns>Magnitude</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle">
            <summary>
            Phase angle of this float complex number
            </summary>
            <returns>Phase angle </returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos">
            <summary>
            Arcus cosinus of this float complex number
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin">
            <summary>
            Arcus sinus of this float complex number
            </summary>
            <returns>Arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)">
            <summary>
            Arcus tangens of float complex number
            </summary>
            <param name="input">input</param>
            <returns>Arcus tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)">
            <summary>
            Round towards next greater integer
            </summary>
            <param name="input">float complex input</param>
            <returns>rounded float complex number</returns>
            <remarks>real and imaginary parts are independently rounded 
            towards the next integer value towards positive infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Floor(ILNumerics.fcomplex)">
            <summary>
            Round towards next lower integer
            </summary>
            <param name="input">float complex input</param>
            <returns>rounded float complex number</returns>
            <remarks>real and imaginary parts are independently rounded 
            towards the next integer value towards negative infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Round(ILNumerics.fcomplex)">
            <summary>
            Round mercantilistic
            </summary>
            <param name="input">float complex number</param>
            <returns>rounded number</returns>
            <remarks>real and imaginaty parts are rounded independently. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sign(ILNumerics.fcomplex)">
            <summary>
            Signum function
            </summary>
            <param name="input">float complex input</param>
            <returns> Signum of input</returns>
            <remarks>
            For numbers a = 0.0 + 0.0i, sign(a)'s real and imag parts are 0.0. 
            For all other numbers sign(a) is the projection onto the unit circle.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Truncate(ILNumerics.fcomplex)">
            <summary>
            truncate a floating point complex value
            </summary>
            <param name="input">input</param>
            <returns>integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">input</param>
            <returns>cosinus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>cosinus hyperbolicus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sin(ILNumerics.fcomplex)">
            <summary>
            Sinus
            </summary>
            <param name="input">input</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sinh(ILNumerics.fcomplex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp">
            <summary>
            exponential / power of base e
            </summary>
            <returns>power of base e</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double)">
            <summary>
            power of fcomplex number, real exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>new fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex)">
            <summary>
            power of fcomplex number, complex exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>new fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt">
            <summary>
            square root of fcomplex number
            </summary>
            <returns>square root</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log">
            <summary>
            logarithm of fcomplex number
            </summary>
            <returns>natural logarithm</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNaN(ILNumerics.fcomplex)">
            <summary>
            test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsInfinity(ILNumerics.fcomplex)">
            <summary>
            test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsPositiveInfinity(ILNumerics.fcomplex)">
            <summary>
            test if any of real or imaginary parts are pos. infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNegativeInfinity(ILNumerics.fcomplex)">
            <summary>
            test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsFinite(ILNumerics.fcomplex)">
            <summary>
            test if any of real or imaginary parts are finite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Double)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Single)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Byte)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Char)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int16)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int32)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int64)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt16)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt32)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt64)~ILNumerics.fcomplex">
            <summary>
            implicit cast real number into complex number
            </summary>
            <param name="a">real number</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Double">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Single">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Byte">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Char">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int16">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int32">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int64">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt16">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt32">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt64">
            <summary>
            explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.iszero">
            <summary>
            test if real and imag part are zero
            </summary>
            <returns>true if real and imag parts are zero, false else</returns>
        </member>
        <member name="P:ILNumerics.fcomplex.conj">
            <summary>
            complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.INF">
            <summary>
            positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.NaN">
            <summary>
            fcomplex quantity, marked as beeing "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithmStateChangedEventHandler">
            <summary>
            delegate type definition for handler handling algorithms state or progress change events
            </summary>
            <param name="sender">sender</param>
            <param name="e">parameter carrying extended algorithm state informations</param>
        </member>
        <member name="T:ILNumerics.Native.ILACMLFFT">
            <summary>
            Wrapper for FFT interface using ACML ver. 3.6
            </summary>
        </member>
        <member name="T:ILNumerics.Data.ILProrityQueue`1">
            <summary>
            experimental performant priority queue implementation (WORK IN PROGRESS!)
            </summary>
            <typeparam name="T">inner type for elements (arbitrary)</typeparam>
        </member>
        <member name="M:ILNumerics.Data.ILProrityQueue`1.Add(`0)">
            <summary>
            add an element to the queue
            </summary>
            <param name="element"></param>
        </member>
        <member name="T:ILNumerics.NumericType">
            <summary>
            Enumerate all numeric type names used by ILNumerics.Net
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Double">
            <summary>
            double element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Single">
            <summary>
            float element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Complex">
            <summary>
            complex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.FComplex">
            <summary>
            fcomplex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Byte">
            <summary>
            byte element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Char">
            <summary>
            char element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int16">
            <summary>
            Int16 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int32">
            <summary>
            Int32 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int64">
            <summary>
            Int64 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt16">
            <summary>
            unsigned UInt16 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt32">
            <summary>
            unsigned UInt32 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt64">
            <summary>
            unsigned UInt64 element type.
            </summary>
        </member>
    </members>
</doc>
