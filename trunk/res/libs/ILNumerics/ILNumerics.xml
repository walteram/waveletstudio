<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.Native.ILLapackGenLinux">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="T:ILNumerics.Native.IILLapack">
            <summary>
            Interface to all LAPACK/BLAS functions available
            </summary>
            <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made virtual by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.BuiltInFunctions.ILMath">ILNumerics.BuiltInFunctions.ILMath</see>).</para>
            <para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            F.e. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para>
            <para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available in the internet: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrf(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrf(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotri(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotri(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetri(System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetri(System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqp3(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.complex">
            <summary>
            floating point complex value data type of double precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex double 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double brings (abs, log, sqrt, tan etc.),
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (f.e. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to complex value into system 
            value types.</remarks>
        </member>
        <member name="F:ILNumerics.complex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.i">
            <summary>
            imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.complex.#ctor(System.Double,System.Double)">
            <summary>
            Constructor creating a new complex value
            </summary>
            <param name="real">real part</param>
            <param name="imag">imagginary part</param>
        </member>
        <member name="M:ILNumerics.complex.Equals(System.Object)">
            <summary>
            are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.complex.GetHashCode">
            <summary>
            Hash code of this system object
            </summary>
            <returns>Hash code of this system object</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Double)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Double)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Double)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Double)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Double)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Double)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Double)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Double)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.UInt16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.UInt16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.UInt16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.UInt16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.UInt16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.UInt16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.UInt16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int64)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int64)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int64)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int64)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int64)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int64)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int32)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int32)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int32)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int32)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int32)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int32)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int16)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int16)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int16)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int16)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int16)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int16)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int16)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int16)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int16)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int16)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Single)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Single)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Single)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Single)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Single)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Single)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Single)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Single)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Char)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Char)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Char)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Char)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Char)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Char)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Char)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Char)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Char)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Char)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Byte)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Byte)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Byte)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Byte)">
            <summary>
            Operator dividing the specified inputs.
            </summary>
            <param name="in1">The divident.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Byte)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Byte)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Double,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Double,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Double,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Double,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Double,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Double,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Double,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Double,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt64,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt64,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt64,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt64,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt64,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt64,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt64,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt32,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt32,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt32,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt32,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt32,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt32,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt32,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.UInt16,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.UInt16,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.UInt16,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.UInt16,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.UInt16,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.UInt16,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.UInt16,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int64,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int64,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int64,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int64,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int64,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int64,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int32,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int32,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int32,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int32,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int32,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int32,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int16,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int16,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int16,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int16,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int16,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int16,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int16,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int16,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int16,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int16,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Single,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Single,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Single,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Single,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Single,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Single,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Single,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Single,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Char,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Char,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Char,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Char,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Char,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Char,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Char,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Char,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Char,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Char,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Byte,ILNumerics.complex)">
            <summary>
            Operator adding the values specified.
            </summary>
            <param name="in1">The first summand.</param>
            <param name="in2">The second summand.</param>
            <returns>Result of operation in1 + in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Byte,ILNumerics.complex)">
            <summary>
            Operator subtracting the values specified.
            </summary>
            <param name="in1">The minuend.</param>
            <param name="in2">The subtrahend.</param>
            <returns>Result of operation in1 - in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Byte,ILNumerics.complex)">
            <summary>
            Operator multiplicating the values specified.
            </summary>
            <param name="in1">The first factor.</param>
            <param name="in2">The second factor.</param>
            <returns>Result of operation in1 * in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Byte,ILNumerics.complex)">
            <summary>
            Operator dividing a real by a complex.
            </summary>
            <param name="in1">The dividend.</param>
            <param name="in2">The divisor.</param>
            <returns>Result of operation in1 / in2</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Byte,ILNumerics.complex)">
            <summary>
            Equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are the same. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Byte,ILNumerics.complex)">
            <summary>
            Un-equality comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real and imaginary parts of both inputs are not equal. False otherwise.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the greater than operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is greater than or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than or equal comparison for 2 complex numbers.
            </summary>
            <param name="in1">The first complex number.</param>
            <param name="in2">The 2nd complex number.</param>
            <returns>true if real part of in1 is lower then or equals the real part of in2. False otherwise.</returns>
            <remarks>Keep in mind, since the lower than comparison operator is not defined for complex values, only the real parts are compared.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_UnaryNegation(ILNumerics.complex)">
            <summary>
            unary minus operator
            </summary>
            <param name="in1">complex input</param>
            <returns>complex number similar to in1, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Double)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Byte)~ILNumerics.complex">
            <summary>
            cast value to complex number
            </summary>
            <param name="a">value to cast</param>
            <returns>complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Double">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>double number with the real part of a </returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Byte">
            <summary>
            cast value from complex number
            </summary>
            <param name="a">complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to byte.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Abs(ILNumerics.complex)">
            <summary>
            Absolute value of input
            </summary>
            <param name="input">input value</param>
            <returns>The absolute value of the input</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle(ILNumerics.complex)">
            <summary>
            Phase angle of complex number
            </summary>
            <param name="input">input value</param>
            <returns>The phase angle of the input</returns>
            <remarks>For the result the Atan2 function of the <see cref="T:System.Math"/> class is used.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Atan(ILNumerics.complex)">
            <summary>
            Arcus tangens of complex input
            </summary>
            <param name="input">complex input</param>
            <returns>Arcus tangens of complex input</returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.complex.Acos(ILNumerics.complex)">
            <summary>
            Arcus cosinus of complex input
            </summary>
            <param name="input">complex input</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos(System.Double)">
            <summary>
            Arcus cosinus of input
            </summary>
            <param name="input"> input value</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(System.Double)">
            <summary>
            Arcus sinus of complex input
            </summary>
            <param name="input"> input value</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(ILNumerics.complex)">
            <summary>
            Arcus sinus of input
            </summary>
            <param name="input">input value</param>
            <returns>Arcus sinus of  input</returns>
        </member>
        <member name="M:ILNumerics.complex.Ceiling(ILNumerics.complex)">
            <summary>
            round towards positive infinity
            </summary>
            <param name="input">input value</param>
            <returns>result is the next integer value greater then input</returns>
            <remarks>ILMath.Ceiling operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Floor(ILNumerics.complex)">
            <summary>
            round towards negative infinity
            </summary>
            <param name="input">input value</param>
            <returns>result is the next integer value lower then input</returns>
            <remarks>ILMath.Floor operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Round(ILNumerics.complex)">
            <summary>
            rounds towards nearest integer
            </summary>
            <param name="input">input value</param>
            <returns>result is the nearest integer value for input</returns>
            <remarks>ILMath.Round operates in both: real and imaginary parts deperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Sign(ILNumerics.complex)">
            <summary>
            Signum function
            </summary>
            <param name="input">complex input </param>
            <returns>result as input / Abs(input)</returns>
            <remarks>Sign(input) with input beeing complex returns the projection onto
            the unit circle. If input is 0+0i the result will be 0+0i.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Truncate(ILNumerics.complex)">
            <summary>
            truncate a floating point complex value
            </summary>
            <param name="input">input</param>
            <returns>integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Cos(ILNumerics.complex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">input</param>
            <returns>cosinus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Cosh(ILNumerics.complex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>cosinus hyperbolicus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sin(ILNumerics.complex)">
            <summary>
            Sinus
            </summary>
            <param name="input">input</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sinh(ILNumerics.complex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Exp(ILNumerics.complex)">
            <summary>
            complex exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>result of exp(exponent)</returns>
            <remarks>For complex exponents, exp(exponent) is computed by
            <para>complex.FromPol(Math.Exp(exponent.real), exponent.imag)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,System.Double)">
            <summary>
            complex power for real exponent
            </summary>
            <param name="input">basis </param>
            <param name="exponent">exponent</param>
            <returns>result of input power exponent</returns>
            <remarks>the computation will be carried out by 
            <para>exp(log(input) * exponent)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double,System.Double)">
            <summary>
            complex power - real basis, real exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>complex number.</returns>
            <remarks>The result will be a complex number. For negative basis 
            the basis will be converted to a complex number and the power 
            will be computed in the complex plane.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            complex power - complex exponent
            </summary>
            <param name="basis">basis</param>
            <param name="exponent">exponent</param>
            <returns>complex number exp(log(basis) * exponent).</returns>
            <remarks>The result will be the complex number exp(log(basis) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(System.Double)">
            <summary>
            Square root
            </summary>
            <param name="input">input</param>
            <returns>the square root of input</returns>
            <remarks>If input is smaller than 0.0, the computation will be done in the complex plane. </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(ILNumerics.complex)">
            <summary>
            Square root
            </summary>
            <param name="input">input</param>
            <returns>the square root of input</returns>
            <remarks>numerical recipes in C: Appendix C </remarks>
        </member>
        <member name="M:ILNumerics.complex.Tan(ILNumerics.complex)">
            <summary>
            Tangens
            </summary>
            <param name="input">input</param>
            <returns>Tangens of input</returns>
            <remarks>the tangens is 
            <para>sin(input) / cos(input)</para>
            if cos(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Tanh(ILNumerics.complex)">
            <summary>
            Tangens hyperbolicus
            </summary>
            <param name="input">input</param>
            <returns>Tangens hyperbolicus</returns>
            <remarks>the tangens hyperbolicus is 
            <para>sinh(input) / cosh(input)</para>
            if cosh(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(ILNumerics.complex)">
            <summary>
            complex logarithm 
            </summary>
            <param name="input">input</param>
            <returns>complex logarithm of input</returns>
            <remarks>the real part of the logarithm is computed by 
            <para>log (abs (input))</para>
            <para>The imaginary part holds the phase of input.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(System.Double)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(System.Double)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.complex.Log2(System.Double)">
            <summary>
            Logarithm of base 2 of real input 
            </summary>
            <param name="input">input value - may be negative</param>
            <returns>complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(ILNumerics.complex)">
            <summary>
            Logarithm of base 10
            </summary>
            <param name="input">input</param>
            <returns>logarithm of base 10</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.Log2(ILNumerics.complex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">input</param>
            <returns>logarithm of base 2.</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.FromPol(System.Double,System.Double)">
            <summary>
            convert polar notation into cartesian notation
            </summary>
            <param name="magnitude">magnitude</param>
            <param name="angle">phase</param>
            <returns>complex value having magnitude and phase</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString">
            <summary>
            convert to string
            </summary>
            <returns>string displaying the comlex number (full precision)</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString(System.Int32)">
            <summary>
            print formated output of this number, determine number of digits
            </summary>
            <param name="digits">number of digits</param>
            <returns>formated output</returns>
        </member>
        <member name="M:ILNumerics.complex.Abs">
            <summary>
            magnitude of this complex instance
            </summary>
            <returns>magnitude</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle">
            <summary>
            Phase of this complex instance
            </summary>
            <returns>phase</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos">
            <summary>
            Arcus cosinus of this complex instance
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin">
            <summary>
            Arcus sinus of this complex instance
            </summary>
            <returns>arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Exp">
            <summary>
            exponential / power of base e
            </summary>
            <returns>power of base e</returns>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double)">
            <summary>
            complex power real exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>new complex number with result</returns>
            <remarks>If this instance is a and the exponent is e than 
            the result will be the complex number exp(log(a) * e). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex)">
            <summary>
            complex power - complex exponent
            </summary>
            <param name="exponent">exponent</param>
            <returns>complex number exp(log(this) * exponent).</returns>
            <remarks>If this instance is a than 
            the result will be the complex number exp(log(a) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt">
            <summary>
            Square root of this complex value
            </summary>
            <returns>square root of this complex value</returns>
        </member>
        <member name="M:ILNumerics.complex.Log">
            <summary>
            logarithm of base e
            </summary>
            <returns>logarithm of base e</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.IsNaN(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.complex.IsInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsPositiveInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are pos.nfinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsNegativeInfinity(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsFinite(ILNumerics.complex)">
            <summary>
            test if any of real or imaginary parts are finite
            </summary>
            <param name="input">complex number to test</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.complex.iszero">
            <summary>
            test if both of real or imaginary parts are 0
            </summary>
            <returns>true if real and imag part is 0</returns>
        </member>
        <member name="P:ILNumerics.complex.conj">
            <summary>
            complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.complex.INF">
            <summary>
            positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.complex.NaN">
            <summary>
            complex quantity, marked as beeing "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.BuiltInFunctions.ILMath">
            <summary>
            Main math class. provides all explicit static math functions 
            </summary>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(System.Int32[])">
            <summary>
            create new ILArray&lt;double&gt;, set initial element values to one.
            </summary>
            <returns>Physical ILArray&lt;double&gt; having all elements set to one. </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(ILNumerics.Misc.ILDimension)">
            <summary>
            create new ILArray&lt;double&gt;, set initial element values to one.
            </summary>
            <returns>Physical ILArray&lt;double&gt; having all elements set to one. </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.zeros(System.Int32[])">
            <summary>
            create array initialized with all zeros
            </summary>
            <param name="dimensions">dimension specification</param>
            <returns>zeros array</returns>
            <remarks>The memory for the array is reclaimed from the memory pool, if possible.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.zeros(ILNumerics.Misc.ILDimension)">
            <summary>
            create array initialized with all zeros
            </summary>
            <param name="dimensions">dimension specification</param>
            <returns>zeros array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.empty">
            <summary>
            create empty array of size 0,0
            </summary>
            <returns>ILArray of inner type double which is empty. </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eye(System.Int32,System.Int32)">
            <summary>
            create matrix having unity diagonal values  
            </summary>
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
            <returns>diagonal unity matrix</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.setseed(System.Int32)">
            <summary>
            Set seed to both rand and randn functions
            </summary>
            <param name="seed">Any ole' number will do</param>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.m_randomGenerator">
            <summary>
            Random number generator used by all rand functions
            </summary>
            <remarks>One may override this value with her own implementation, derived from <c>Random</c>.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rand(System.Int32[])">
            <summary>
            pseudo random n-dimensional array elements
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created</param>
            <returns>n-dimensional array filled with random numbers.</returns>
            <remarks><para> the elements lay within the range 0.0 ... 1.0 and are uniformly 
            distributed.</para>
            <para>The initial seed will be set to Environment.TickCount on the first call</para></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.m_nrandomGenerator">
            <summary>
            Random number generator used by all randn functions
            </summary>
            <remarks>One may override this value with her own implementation, derived from <c>Random</c>.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.randn(System.Int32[])">
            <summary>
            normal random distributed n-dimensional array elements
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created</param>
            <returns>n-dimensional array filled with random numbers.</returns>
            <remarks>the elements lay within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vector(System.Double,System.Double)">
            <summary>
            Create regulary spaced vector
            </summary>
            <param name="start">start value</param>
            <param name="end">end value</param>
            <returns>row vector of size 1xN</returns>
            <remarks>N is the number of elements 
            between start and end, all equally spaced of distance 1. the last element 
            in vector returned will be less or equal end, if start <![CDATA[<]]> end. If start 
            <![CDATA[>]]> end, the elements in the vector will be in decreasing order - ranging from 
            start ... end. This is the same as vector (start,[-]1,end).</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Int32[])">
            <summary>
            Create N-d array with elements counting from 1
            </summary>
            <param name="dimensions">variable int array with dimension specification</param>
            <returns>array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>this function may be used for easy and convinient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Double,System.Double,System.Int32[])">
            <summary>
            Create N-d array with elements, arbitrary limits
            </summary>
            <param name="start">initial value</param>
            <param name="increment">increment for each element</param>
            <param name="dimensions">variable int array with dimension specification</param>
            <returns>array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks><para>counter is a fast alternative to the creation of arrays via <see cref="M:ILNumerics.BuiltInFunctions.ILMath.ones(System.Int32[])"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.zeros(System.Int32[])"/> and following modifications. 
            Counter is more general. It can creates arrays of all constants (zeros, ones, twos ...) if <paramref name="increment"/> is 0, constantly 
            incrementing elements if <paramref name="increment"/> is positive or negative.</para>
            This function may also be used for easy and convinient creation of arrays for testing purposes.
            <para>Keep in mind: in order to distingush this function from the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.counter(System.Int32[])"/>
            you need to specify parameter <paramref name="start"/> and <paramref name="increments"/> explicitly as double value:</para>
            <example><code>
            // this will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // this will create elements counting from 1...48 with spaces of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // ... but this will (by mistake) call the wrong function:
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1,2,4,3,2); 
            // ... and therefore create an array of size [1,2,4,3,2] with elements counting from one!
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vector(System.Double,System.Double,System.Double)">
            <summary>
            Create regulary spaced vector
            </summary>
            <param name="start">start value</param>
            <param name="step">step size</param>
            <param name="end">end value</param>
            <returns>row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced of distance step. the last element 
            in vector returned will be less or equal end, if start <![CDATA[<]]> end. If start 
            <![CDATA[>]]> end, the elements in the vector will be decreasing - ranging from 
            start ... to end. In this case, step must be negative. </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ones(ILNumerics.NumericType,System.Int32[])">
            <summary>
            Create array innitialized with ones
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="dimensions">Dimension specification. At least one dimension must be specified.</param>
            <returns>ILArray&lt;BaseT&gt; of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned may be casted to the actual type accordingly afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Char</item>
            <item>Int16</item>
            <item>Int32</item>
            <item>Int64</item>
            <item>UInt16</item>
            <item>UInt32</item>
            <item>UInt64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ccomplex(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Create complex array from real and imaginary parts 
            </summary>
            <param name="real">array with real part elements</param>
            <param name="imag">array with imaginary part elements</param>
            <returns>complex array constructed out of real and imaginary parts given.</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the size of both arguments is not the same</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Double})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sign(ILNumerics.ILArray{System.Byte})">
            <summary>Signum of array elements</summary>
            <param name="A">input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rank(ILNumerics.ILArray{System.Double})">
            <summary>
            Rank of matrix inArray
            </summary>
            <param name="inArray">Matrix</param>
            <returns>rank of matrix inArray</returns>
            <remarks>The rank is the number of singular values greater than 
            the default tolerance. As tolerance the following equation is used: \\
            tol = length(inArray) * norm(inArray) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(inArray) - the longest dimension of inArray</item>
            <item>norm(inArray) beeing the largest singular value of inArray, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.rank(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            Rank of matrix inArray
            </summary>
            <param name="inArray">Matrix</param>
            <param name="tolerance">tolerance used to decide, if a singular value is 
            treated as zero</param>
            <returns>rank of matrix inArray</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(inArray) * norm(inArray) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(inArray) - the longest dimension of inArray</item>
            <item>norm(inArray) beeing the largest singular value of inArray, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">general matrix. Size [m x n]</param>
            <returns>triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para> The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
             or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">general matrix to be decomposed. Size [m x n]</param>
            <param name="U">[output] reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <code>ILMath.multiply(L,U) == A</code></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">general input matrix. Size [m x n]</param>
            <param name="U">[output] reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[output] reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <code>ILMath.multiply(L,U) == ILMath.multiply(P,A)</code> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.lu(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyUpperTriangle``1(ILNumerics.ILArray{``0},System.Int32,System.Int32)">
            <summary>
            copy upper triangle from PHYSICAL array A
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <returns>newly created physical array with the upper triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyUpperTriangle``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            copy upper triangle from system array A
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="arrIn">system array, size (m x n), column wise ordered</param>
            <param name="arrInM">number of rows</param>
            <param name="arrInN">number of columns</param>
            <param name="outM">number of rows in output matrix</param>
            <returns>newly created physical array with the upper triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A! copies the main diagonal also.
            the array returned will be of size (min(m,n) x n)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyLowerTriangle``1(ILNumerics.ILArray{``0},System.Int32,System.Int32,``0)">
            <summary>
            copy lower triangle from PHYSICAL array A, set diagonal to val
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <param name="val">value for diagonal entries</param>
            <returns>newly created physical array with the lower triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.copyLowerTrianglePerm``1(ILNumerics.ILArray{``0},System.Int32,System.Int32,``0,System.Int32[])">
            <summary>
            copy lower triangle from PHYSICAL array A, set diagonal to val, permuted version
            </summary>
            <typeparam name="T">arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">number of rows</param>
            <param name="n">number of columns</param>
            <param name="perm">mapping for rows, must be converted fom LAPACK version to single indices </param>
            <param name="val">value for diagonal entries</param>
            <returns>newly created physical array with the lower triangle of A</returns>
            <remarks>no checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.perm2indicesForward(System.Int32[])">
            <summary>
            relabel permutation indices from LAPACK ?getrf
            </summary>
            <param name="perm">lapack pivoting permutation array</param>
            <returns>index mapping for direct addressing the rows </returns>
            <remarks>exchange the row labels in the same manner as LAPACK did for pivoting</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.perm2indicesBackward(System.Int32[])">
            <summary>
            relabel permutation indices from LAPACK ?getrf - backward version
            </summary>
            <param name="perm">lapack pivoting permutation array</param>
            <returns>index mapping for direct addressing the rows </returns>
            <remarks>exchange the row labels in the same manner as LAPACK did for pivoting, but backwards</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{System.Double})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isposinf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ind2sub(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            convert sequential index into subscript indices
            </summary>
            <param name="A">input array</param>
            <param name="seqindex">sequential index</param>
            <returns>subscript indices</returns>
            <remarks><para>the length of the value returned will be the number of dimensions of A</para>
            <para>if A is null or empty array, the return value will be of length 0</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">if seqindex is &lt; 0 or &gt; numel(A)</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Exponential of array elements</summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.exp(ILNumerics.ILArray{System.Double})">
            <summary>Exponential of array elements </summary>
            <param name="A">input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Double})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{System.Byte})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert arbitrary numeric array to arbitrary numeric type
            </summary>
            <param name="X">input array</param>
            <param name="outputType">type description for return type</param>
            <returns>converted array</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to double
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; double &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type complex 
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; complex &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type byte
            </summary>
            <param name="X">input array </param>
            <returns>ILArray &lt; byte &gt;</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tological(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            convert numeric array to inner type logical
            </summary>
            <param name="X">input array </param>
            <returns>ILLogicalArray</returns>
            <remarks> The newly created array will be converted to the type requested. 
            <para>Important note: if X matches the type requested, NO COPY will be made for it and the SAME array will be returned!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.convert(ILNumerics.NumericType,ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary (numeric) array to other inner type
            </summary>
            <param name="typeName">Numeric type for output</param>
            <param name="X">input array, arbitrary inner type</param>
            <returns>Numeric array with specified inner element type</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.todouble(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tobyte(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tocomplex(ILNumerics.ILBaseArray)">
            <summary>
            Convert arbitrary numeric array to specific type
            </summary>
            <param name="X">numeric array, arbitrary numeric type</param>
            <returns>Array of specific inner type</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if X is not numeric</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{System.Double},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.chol(ILNumerics.ILArray{ILNumerics.complex},System.Boolean)">
            <summary>
            cholesky factorization 
            </summary>
            <param name="A">hermitian matrix A. A must be a symmetric matrix. 
            Therefore the upper triangular part of A must be 
            <param name="throwException">throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            the (complex conjugate) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <returns>cholesky factorization</returns>
            <remarks><para>if <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para> If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not pos.def. the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A which was found to be not positive definite.  </para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.vertcat``1(ILNumerics.ILArray{``0}[])">
            <summary>
            vertical concatenation for arbitrary arrays
            </summary>
            <param name="inArrays"> arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except the first dimension.</param>
            <returns>large array having all arrays in 'inArrays' placed beneath each other.
            </returns>
            <remarks>The array returned may be a reference array if all elements of 'inArrays' 
            point to the same object instance, or a solid array otherwise. In the case of
            all elements pointing to the same object, the static member 
            ILNumerics.ILSettings.MinimumRefDimensions will be taken into account too.
            
            Vertical concatenation means concatenation along the first dimension.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="!:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="!:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <returns> solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="!:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linsolve(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">'rigth hand side' B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>the solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>depending on the <paramref name="props"/> parameter the equation system will be solved differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved beeing reference arrays! ]]></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>if during the cholesky factorization A was found to be <b>not positive definite</b> - the corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>otherwise if A is square only, it will be decomposed into upper and lower triangular matrices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), the eps member from <see cref="!:ILNumerics.Settings.ILSettings"/> class is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveUpperTriangularSystem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a upper triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.solveLowerTriangularSystem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A beeing a lower triangular matrix
            </summary>
            <param name="A">input matrix of Size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">solution vector. Size [n x 1]</param>
            <param name="singularityDetect">output: this value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(System.Double)">
            <summary>
            Find finite value elements
            </summary>
            <param name="input">input array or element</param>
            <returns>true for finite values</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(System.Single)">
            <summary>
            Find finite value elements
            </summary>
            <param name="input">input array or element</param>
            <returns>true for finite values</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{System.Double})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isfinite(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds finite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cosh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic cosine of array elements </summary>
            <param name="A">input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp1D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Linear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into Y.</param>
            <param name="Y">The table values: Y = f(X). Must have the same number of elements as X.</param>
            <param name="XI">X components of points to interpolate.</param>
            <returns>Values YI interpolated at each XI: YI ~= f(XI). Will be the same size as XI.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp1D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Double)">
            <summary>Linear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into Y.</param>
            <param name="Y">The table values: Y = f(X). Must have the same number of elements as X.</param>
            <param name="XI">X component of point to interpolate.</param>
            <returns>Scalar value interpolated at XI: YI ~= f(XI).</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp2D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Bilinear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into Z.</param>
            <param name="Y">Vector representing possible Y lookups into Z.</param>
            <param name="Z">The table values: Z = f(X,Y).
            Must be a 2D matrix with X.Count Columns and Y.Count Rows.</param>
            
            <param name="XI">X components of points to interpolate.</param>
            <param name="YI">Y components of points to interpolate.</param>
            
            <returns>Values ZI interpolated at each XI,YI: ZI ~= f(XI,YI).
            Will be the same size as XI.Count and YI.Count.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp2D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Double,System.Double)">
            <summary>Bilinear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into Z.</param>
            <param name="Y">Vector representing possible Y lookups into Z.</param>
            <param name="Z">The table values: Z = f(X,Y).
            Must be a 2D matrix with X.Count Columns and Y.Count Rows.</param>
            
            <param name="XI">X component of point to interpolate.</param>
            <param name="YI">Y component of point to interpolate.</param>
            <returns>Scalar value ZI interpolated at XI,YI: ZI ~= f(XI,YI).</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp3D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Trilinear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into V.</param>
            <param name="Y">Vector representing possible Y lookups into V.</param>
            <param name="Z">Vector representing possible Z lookups into V.</param>
            <param name="V">The table values: V = f(X,Y,Z). Must be a 3D matrix with
            X.Count Rows, Y.Count Columns, and Z.Count Slabs.</param>
            
            <param name="XI">X components of points to interpolate.</param>
            <param name="YI">Y components of points to interpolate.</param>
            <param name="ZI">Z components of points to interpolate.</param>
            
            <returns>Values VI interpolated at each XI,YI,ZI: VI ~= f(XI,YI,ZI).
            Will be the same size as XI.Count, YI.Count, and ZI.Count.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp3D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},System.Double,System.Double,System.Double)">
            <summary>Trilinear Interpolation</summary>
            <param name="X">Vector representing possible X lookups into V.</param>
            <param name="Y">Vector representing possible Y lookups into V.</param>
            <param name="Z">Vector representing possible Z lookups into V.</param>
            <param name="V">The table values: V = f(X,Y,Z). Must be a 3D matrix with
            X.Count Rows, Y.Count Columns, and Z.Count Slabs.</param>
            
            <param name="XI">X component of point to interpolate.</param>
            <param name="YI">Y component of point to interpolate.</param>
            <param name="ZI">Z component of point to interpolate.</param>
            
            <returns>Scalar value VI interpolated at XI,YI,ZI: VI ~= f(XI,YI,ZI).</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Double})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types: /*!HC:ENUM:inCls1*/ <![CDATA[]]> /*!HC:/ENUM*/</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <returns> for matrices: </returns>
            <remarks>this internally calls: norm(X,2)</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.norm(ILNumerics.ILArray{ILNumerics.complex},System.Double)">
            <summary>
            vector or matrix norm
            </summary>
            <param name="X">matrix/ vector</param>
            <param name="degree">degree of norm. For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(X),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(X))</item>
            <item>System.double.NegativeInfinity: return Min(abs(X))</item>
            </list>
            For matrices this must be one of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(X, X[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(X)))</item>
            <item>2: returns the largest singular value of X, max(svd(X))</item>
            <item>PositiveInfinity: returns max(sum(abs(X), 2)), the largest value of the sums along the rows.</item>
            </list>
            </param>
            <returns>new solid Array of same type as input array X with the norm.
            This function is supported for the following ILArray<![CDATA[<>]]> types:  <![CDATA[]]> </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Double})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt64})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt32})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.UInt16})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int64})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int32})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Int16})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Char})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Byte})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.maxall(ILNumerics.ILArray{System.Single})">
            <summary>
            maximum for all elements of A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar maximum of all elements for A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{System.Double})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isinf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Double})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Byte})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.any(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>determine, if any elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having the 'leadDim's dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Byte})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sum array elements along first non singleton dimension
            </summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array having the first non singleton dimension 
            reduced to the length 1 with the sum of 
            all elements along that dimension.</para>
            <para>The result will have the same number of dimensions as 
            A, but the first non singleton dimension will have the 
            size 1.</para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements of A along dimension specified.
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>array, same size as A, but having the 'leadDim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiplyElem(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Multiply elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.invert(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            invert elements of A, return result as out argument
            </summary>
            <param name="A"></param>
            <param name="outArray"></param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.horzcat``1(ILNumerics.ILArray{``0}[])">
            <summary>
            horizontal concatenation for arbitrary arrays
            </summary>
            <param name="inArrays"> arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except the second dimension.</param>
            <returns>large array having all arrays in 'inArrays' placed behind each other.
            </returns>
            <remarks>The array returned may be a reference storage if all elements of 'inArrays' 
            point to the same object instance, or a physical storage array otherwise. In the case of
            all elements pointing to the same object, the static member 
            ILNumerics.Settings.ILSettings.MinimumRefDimensions will be taken into account too.
            
            Horizontal concatenation means concatenation along the second dimension.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pchip(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Polynomial interpolation, first derivative continuity</summary>
            <param name="X">Vector representing possible X lookups into Y.</param>
            <param name="Y">The table values: Y = f(X). Must have the same number of elements as X.</param>
            <param name="XI">X components of points to interpolate.</param>
            <returns>Values YI interpolated at each XI: YI ~= f(XI). Will be the same size as XI.</returns>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.linearInterp1D(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})"/>
            <remarks>
            Smoother than linearInterp1D since continuity is achieved on the first derivative; however,
            continutiy is not guarenteed on the second derivative. (Note: It's possible to make this faster
            by lazily evaluating slopes, but it probably wouldn't make much difference seeings how it is
            linear time to evaluate them all.)
            
            Reference:
            -Moler, Cleve B. Numerical Computing with Matlab.
             Society for the Industrial and Applied Mathematics:
             Philadelphia, PA, 2004. Interpolation, Chapter 3.
             http://www.mathworks.com/moler/index_ncm.html
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.triu``1(ILNumerics.ILArray{``0})">
            <summary>
            upper triangular part of matrix
            </summary>
            <typeparam name="T">inner type of matrix</typeparam>
            <param name="A">original matrix, size [m x n]</param>
            <returns>physical array of size [m x n], holding upper triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tril``1(ILNumerics.ILArray{``0})">
            <summary>
            lower triangular part of matrix
            </summary>
            <typeparam name="T">inner type of matrix</typeparam>
            <param name="A">original matrix, size [m x n]</param>
            <returns>physical array of size [m x n], holding lower triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan(ILNumerics.ILArray{System.Double})">
            <summary>Arctangent of array elements </summary>
            <param name="A">input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tanh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.repmat``1(ILNumerics.ILArray{``0},System.Int32,System.Int32[])">
            <summary>
            array replication
            </summary>
            <param name="X">input array to be replicated</param>
            <param name="rows">number of rows</param>
            <param name="sizeEx">number of columns and higher dimensions</param>
            <returns>reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{System.Double})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isneginf(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.pi">
            <summary>
            Definition of pi
            </summary>
            <remarks>this is an alias for Math.PI - supplied for convinience only</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Determine machine specific parameter
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Determine machine specific parameter (double precision)
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Double})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Char})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.single(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert numerical ILArray to single precision floating point precision
            </summary>
            <param name="X">numeric input array</param>
            <returns><![CDATA[ILArray<float>]]> of same size as X having all elements converted to 
            single precision floating point format.</returns>
            <remarks>All overloads of this function will return a solid physical copy 
            of the input array X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sin(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.prod(ILNumerics.ILArray{System.Double})">
            <summary>
            multiply and fold array elements along first non singleton dimension
            </summary>
            <param name="inArray">N-dimensional double array</param>
            <returns>array having the first non singleton dimension 
            reduced to the length 1 with the result of the products of 
            corresponding elements of inArray in that dimension.
            The result will have the same number of dimensions as 
            inArray, but the first non singleton dimension having the 
            size 1.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.prod(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Multiply elements of inArray along specified dimension.
            </summary>
            <param name="inArray">N-dimensional double array</param>
            <param name="leadDim">index of dimension to multiply elements along</param>
            <returns>array having the 'leadDim's dimension 
            reduced to the length of 1 with the result of the product of 
            corresponding elements of inArray of that dimension.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            power function - returns same type
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>array of same type as A, with corresponding elements filled with: A<sub>i,j,...</sub><sup>exponent</sup>.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pow(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.imag(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            imaginary part of complex array elements
            </summary>
            <param name="X">complex input array</param>
            <returns>imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.cos(ILNumerics.ILArray{System.Double})">
            <summary>Cosine of array elements</summary>
            <param name="A">input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">general input matrix A</param>
            <returns>orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This mean that it contains 
            the decomposition factors Q and R, but they are cmbined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            instead, which returns those factors seperately.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' denotes 
            matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] (see remarks). </param>
            <param name="economySize">if true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.) 
            <para>Q and R will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. I.e. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.  
            <para>Q, R and E will be solid ILArray's.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">general input matrix A of size [m x n]</param>
            <param name="R">output parameter. Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks). </param>
            <param name="economySize"><para>if true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>if false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.qr(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)"/></para>
            </param>
            <param name="E">permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds except 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[null,E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para>
            <para>Q, R and E will be solid ILArray's.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find nonzero elements of X
            </summary>
            <param name="X">N-dimensional double array</param>
            <returns>vector with sequential indices of X elements 
            having a value not equal to 0.0. 
            </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Double},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{ILNumerics.complex},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.find(ILNumerics.ILArray{System.Byte},System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Byte}@)">
            <summary>
            Find nonzero elements in X
            </summary>
            <param name="X">input array to be evaluated</param>
            <param name="limit">number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array.</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If X
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">if not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in X. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array X. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (f.e. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diag``1(ILNumerics.ILArray{``0})">
            <summary>
            diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">matrix or vector. If X is matrix, diag returns the 
            elements on the main diagonal as column vector. If X is vector, a square matrix of size 
            [length(X), length(X)] will be created, having the elemrnts of 
            X on the main diagonal.</param>
            <returns>depending on 'X' a matrix or a vector with the elements of/on 
            the main diagonal.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diag``1(ILNumerics.ILArray{``0},System.Int32)">
            <summary>
            diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">matrix or vector. If X is matrix, diag returns the 
            elements on the 'diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the 'diagPosition's diagonal.</param>
            <param name="diagPosition">index of diagonal to extract/ create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>depending on 'X' a matrix or a vector with the elements of/on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.divide(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Divide elements</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.size(ILNumerics.ILBaseArray)">
            <summary>
            size of array A 
            </summary>
            <param name="A">input array</param>
            <returns>double ILArray with the length of each dimension of A.</returns>
            <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.size(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            length of one specific dimension of A
            </summary>
            <param name="A">input array</param>
            <param name="dim">number of dimension to query the length for</param>
            <returns>length of dimension 'dim'</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.length(ILNumerics.ILBaseArray)">
            <summary>
            longest dimension of A
            </summary>
            <param name="A">input array</param>
            <returns>if A is null:0 - length of longest dimension of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.Longest</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ndims(ILNumerics.ILBaseArray)">
            <summary>
            Number of dimensions of A
            </summary>
            <param name="A">input array</param>
            <returns>if A is null: 0 - else number of dimensions of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.NumberOfDimensions</remarks>
            
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.numel(ILNumerics.ILBaseArray)">
            <summary>
            Number of elements of A
            </summary>
            <param name="A">input array</param>
            <returns>number of elements of A</returns>
            <remarks>this is an alias/abreviation for A.Dimensions.NumberOfElements</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.unique(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>Unique and sorted elements of a vector.</summary>
            <param name="X">Elements from which to extract unique values (treated as a vector).</param>
            <param name="whereResultInX">Indices (same size as retValue) such that x[whereResultInX] = retValue.</param>
            <param name="whereXInResult">Indices (same size as x) such that retValue[whereXInResult] = x.</param>
            <returns>Sorted row vector with size less than or equal to x where no 2 elements have the same value.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.unique(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>Unique and sorted elements of a vector.</summary>
            <param name="X">Elements from which to extract unique values (treated as a vector).</param>
            <param name="whereResultInX">Indices (same size as retValue) such that x[whereResultInX] = retValue.</param>
            <returns>Sorted row vector with size less than or equal to x where no 2 elements have the same value.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.unique(ILNumerics.ILArray{System.Double})">
            <summary>Unique and sorted elements of a vector.</summary>
            <param name="X">Elements from which to extract unique values (treated as a vector).</param>
            <returns>Sorted row vector with size less than or equal to x where no 2 elements have the same value.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.stablesort(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            Sorts along first non-singleton dimension in ascending order
            </summary>
            <param name="toSort">Matrix of items to sort</param>
            <param name="indices">Index positions such that sortedArray[indices] = 
            originalArray. Most importantly, indices belonging to elements of equivalent
            value will be sorted from low to high.</param>
            <remarks>This is a stable sort, using a stable Merge Sort algorithm. Use sort
            function instead if preservation of order is unnecessary.</remarks>
            <returns>Input array sorted along first non-singleton dimension</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Double})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{System.Byte})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sumall(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            sum all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.sum(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.round(ILNumerics.ILArray{System.Double})">
            <summary>Round to nearest integer</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Double})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt64})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt32})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.UInt16})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int64})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int32})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Int16})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Char})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Byte})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.minall(ILNumerics.ILArray{System.Single})">
            <summary>
            minimum of all elements of array A
            </summary>
            <param name="A">n-dim array</param>
            <returns><para>scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null.</exception>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logc(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{System.Double})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.isnan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fix(ILNumerics.ILArray{System.Double})">
            <summary>Round towards zero</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.quadl(System.MulticastDelegate,System.Double,System.Double)">
            <summary>Find integral using Lobatto Rule</summary>
            <param name="f">Function to integrate. Must be of the
            form y = f(x) where x and y are of type "double".</param>
            <param name="a">Lower bound of integral</param>
            <param name="b">Upper bound of integral</param>
            <returns>Area under funciton curve with an error of +- 1e-6</returns>
            
            <remarks>
            Derived from "W. Gander and W. Gautschi: Adaptive Quadrature - 
            Revisited, BIT Vol. 40, No. 1, March 2000, pp. 84--101. CS technical 
            report: Report (gzipped, 82K). Programs: adaptsim.m, adaptlob.m", which
            can be found at: http://www.inf.ethz.ch/personal/gander/.
            
            The defualt error of 1e-6 was chosen in order to give results
            comparible in speed and precision to Matlab R2009a.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.quadlStep(System.MulticastDelegate,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Recursive component of quadl</summary>
            <remarks>This funciton was also taken from Gander and Gautschi,
            http://www.inf.ethz.ch/personal/gander/ .</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.reshape``1(ILNumerics.ILArray{``0},System.Int32[])">
            <summary>
            array reshaping
            </summary>
            <param name="A">input array A</param>
            <param name="newDimensions">new dimension array. This may be 
            a comma seperated list or an int array</param>
            <returns>reshaped X</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimension specified by newDimensions. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            if the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="newDimensions"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.polyval(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Evaluate the polynomial c*x^n + c*x^n-1 + ... + c</summary>
            <param name="coeffs">Coefficients of polynomial</param>
            <param name="x">Variable of polynomial</param>
            <returns>Array same size as x with result of polynomial evaluation at x</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Double})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Byte})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>mean of elements along first non singleton dimension</returns>
            <remarks>the array returned will be a physical array. The number 
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.mean(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean 
            </summary>
            <param name="A">N-dimensional array</param>
            <param name="dim">dimension index to gather the mean along</param>
            <returns>mean of elements along dimension dim</returns>
            <remarks>the array returned will be a new solid physical array. The number
            of its dimensions will be the number of dimensions of A minus 1. If A is scalar,
            the value returned will be scalar. The type will be the same type as A.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (1D)
            </summary>
            <param name="A">input array</param>
            <returns>transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast inverse fourier transform (1D)
            </summary>
            <param name="A">input (frequency domain)</param>
            <returns>inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array</param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">real input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part beeing even and the imaginary part beeing odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftsym(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <param name="dim">dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">complex hermitian input array (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{System.Double},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fft2(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifft2sym(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            inverse fast fourier transform (2D)
            </summary>
            <param name="A">complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">transformation column length</param>
            <param name="n">transformation row length</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions beeing singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Double})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            inverse fast fourier transform (n-D)
            </summary>
            <param name="A">input array, n-D, complex hermitian (frequency domain)</param>
            <returns>transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A beeing hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics.Net startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{System.Double},System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.BuiltInFunctions.ILMath.fftn(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.BuiltInFunctions.ILMath.ifftn(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:ILNumerics.BuiltInFunctions.ILMath.ifftnsym(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])" -->
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Double,System.Double)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            compute eigenvalues of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <returns>vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@)"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">input matrix A. Size [n x n]</param>
            <param name="V">output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">input: square matrix, size [n x n]</param>
            <param name="V">output (optional): eigenvectors</param>   
            <param name="propsA">matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not equaled null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double})"/> 
            or <see cref="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double})"/>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.eig(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Int32,System.Int32)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Double,System.Double)">
            <summary>
            find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eigSymm(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.BuiltInFunctions.ILMath.GenEigenType,System.Boolean)">
            <summary>
            compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="V">(output) if on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B beeing hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{System.Double})">
            <summary>
            complex conjugate of A
            </summary>
            <param name="A">input array</param>
            <returns>the array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{System.Single})">
            <summary>
            complex conjugate of A
            </summary>
            <param name="A">input array</param>
            <returns>the array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.conj(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find max value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.max(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linspace(System.Double,System.Double)">
            <summary>
            create linearly spaced row vector of 100 elements 
            </summary>
            <param name="start">first value</param>
            <param name="end">last value</param>
            <returns>row vector with 100 elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.linspace(System.Double,System.Double,System.Int32)">
            <summary>
            create linearly spaced row vector
            </summary>
            <param name="start">first value</param>
            <param name="end">last value</param>
            <param name="length">number of elements to create</param>
            <returns>row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{System.Double})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.det(ILNumerics.ILArray{ILNumerics.complex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">square input matrix</param>
             <returns>determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part. Therefore LAPACK function ?getrf is used. <br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U beeing an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorDoubleDouble(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionDoubleDouble)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[ /*!HC:outCls1*/ ILArray<double> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorComplexComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionComplexComplex)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<complex> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ByteOperatorByteByte(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILByteFunctionByteByte)">
            <summary>
            operate on elements of both storages by the given function -> relational operations 
            </summary>
            <param name="inArray1">First storage array</param>
            <param name="inArray2">Second storage array</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns><![CDATA[  ILArray<byte> ]]> with result of operation for corresponding 
            elements of both arrays.</returns>
            <remarks>The values of inArray1 nor inArray2 will not be altered.The dimensions 
            of both arrays must match.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorDouble(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ /*!HC:outCls1*/ ILArray<double> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorDouble(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<complex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.DoubleOperatorComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILDoubleFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<double> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ComplexOperatorComplex(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILComplexFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<complex> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ByteOperatorByte(ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILByteFunctionByte)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[  ILArray<byte> ]]> with result of operation</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <returns>vector with min(M,N) singular values of X as column vector</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors VT will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.svd(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex}@,ILNumerics.ILArray{ILNumerics.complex}@,System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="X">matrix X. The elements of X will not be altered.</param>
            <param name="U">(return value) left singular vectors of X as columns of matrix U. 
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="V">right singular vectors of X as rows of matrix V.
            If this parameter is set, it must be not null. It might be an empty array. On return
            it will be set to a physical array accordingly.</param>
            <param name="small">if true: return only first min(M,N) columns of U and S will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">if true: the matrix given will not be checked for infinte or NaN values. If such elements 
            are contained nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib. Use with care! </param>
            <returns>singluar values as diagonal matrix of same size as X</returns>
            <remarks>the right singular vectors V will be returned as reference array.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sinh(ILNumerics.ILArray{System.Double})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Find min value elements along first non singleton dimension
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32)">
            <summary>
            maximum
            </summary>
            <param name="A">input array, N-dimensional</param>
            <param name="I">return value. If this is an instance of an ILArray 
            (f.e. 'empty'), on return I will hold the indices into leadDim of  
            the maximum values. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns>ILArray of type double. If I was empty  having the dimension 'leadDim' 
            reduced to 1 and holding maximum values </returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.min(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Double})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istrilow(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is lower triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.istriup(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishesslow(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishessup(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ishermitian(ILNumerics.ILArray{System.Byte})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10c(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.log10(ILNumerics.ILArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.floor(ILNumerics.ILArray{System.Double})">
            <summary>Round towards negative infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asinc(ILNumerics.ILArray{System.Double})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.asin(ILNumerics.ILArray{System.Double})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Double})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Byte})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">n-dimensional array</param>
            <returns><para>array of same size as A, having the first non singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.all(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>determine, if all elements are nonzero</summary>
            <param name="A">N-dimensional array</param>
            <param name="leadDim">index of dimension to operate along</param>
            <returns><para>array of same size as A, having 'leadDim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.add(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Double})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.abs(ILNumerics.ILArray{System.Byte})">
            <summary>Absolute values of array elements</summary>
            <param name="A">input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryDoubleOperator(ILNumerics.ILArray{System.Double},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionDouble)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryComplexOperator(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionComplex)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.LogicalUnaryByteOperator(ILNumerics.ILArray{System.Byte},ILNumerics.BuiltInFunctions.ILMath.ILLogicalFunctionByte)">
            <summary>
            Applys the function (delegate) given to all elements of the storage
            </summary>
            <param name="inArray">storage array to be apply the function to</param>
            <param name="operation">operation to apply to the elements of inArray. This
            acts like a function pointer.</param>
            <returns>new <![CDATA[ILArray<>]]> with result</returns>
            <remarks> the values of inArray will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.eq(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.String})">
            <summary>
            Elementwise logical 'equal' operator
            </summary>
            <param name="A">input array 1</param>
            <param name="B">input array 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.String})">
            <summary>
            Elementwise logical 'not equal' operator
            </summary>
            <param name="A">input array 1</param>
            <param name="B">input array 2</param>
            <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.neq(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A not equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.le(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ge(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.lt(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'lower than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing lower than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.gt(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns>Logical array having '1' for elements in A beeing greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.and(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            elementwise logical 'and' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'and'.</returns>
            <remarks>A and B must have the same size or either one may be scalar. If one of A or B is empty, 
            an empty array of the same inner element type is returned.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.or(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            elementwise logical 'or' operator 
            </summary>
            <param name="A">input array A</param>
            <param name="B">input array B</param>
            <returns>logical array of same size as A and B, elements with result of logical 'or'.</returns>
            <remarks>A and B must have the same size or either one may be scalar.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Double},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts">subscripts</param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{ILNumerics.complex},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sub2ind(ILNumerics.ILArray{System.Byte},System.Int32[])">
            <summary>
            convert subscript indices to sequential index
            </summary>
            <param name="A">input array</param>
            <param name="subscripts"></param>
            <returns>sequential index for subscript indices</returns>
            <remarks>the function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices. <br />This is an alias for A.getBaseIndex(in[])</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrtc(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sqrt(ILNumerics.ILArray{System.Double})">
            <summary>
            Sinus of array elements 
            </summary>
            <param name="A">input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            pseudo - inverse of input argument M
            </summary>
            <param name="M">Matrix M</param>
            <returns>pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.pinv(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            pseudo inverse of input matrix M
            </summary>
            <param name="M">matrix M</param>
            <param name="tolerance">tolerance, see remarks</param>
            <returns>pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) beeing the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Double})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Double})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Byte})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{System.Byte})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            numeric derivative and differences 
            </summary>
            <param name="A">N-dimensional array</param>
            <returns>derivative of elements along first non singleton dimension</returns>
            <remarks>The array returned will: 
            <list type="bullte">
            <item>have the same inner type as A,</item>
            <item>be of the same size as A, but the first non singleton dimension decreased by 1.</item>
            </list>
            <para>For A beeing scalar or empty, an empty result will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Nth - derivative along specified dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimension to create derivative along</param>
            <param name="N">degree of derivates</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[leadDim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.diff(System.Int32,ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="leadDim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <code>lieadDim</code></returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.ceil(ILNumerics.ILArray{System.Double})">
            <summary>Round towards positive infinity</summary>
            <param name="A">input array</param>
            <returns>Array of same size as A with elements rounded up to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acosc(ILNumerics.ILArray{System.Double})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.acos(ILNumerics.ILArray{System.Double})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.Lapack">
            <summary>
            concrete interface wrapper class providing the native LAPACK functions
            </summary>
            <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics.Net, a generic - not optimized - version of native LAPACK code will
            be used than.</remarks>
            
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.FFT">
            <summary>
            platform specific FFT implementation, <b>internally</b> used to compute fft 
            </summary>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.#cctor">
            <summary>
            main math class providing static builtin functions
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.ILAtlasMinimumElementSize">
            <summary>
            Minimal size of dimensions, expensive operations will be carried out by native LAPACK libs. 
            </summary>
            <remarks>This property is not yet implemented. All computations (unless for scalars) will be using LAPACK.
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.powc(ILNumerics.ILArray{System.Double},System.Double)">
            <summary>
            power function - complex return
            </summary>
            <param name="A">input array</param>
            <param name="exponent">real exponent</param>
            <returns>complex array</returns>
            <remarks>The complex array returned will hold result of power function for corresponding elements of A<sub>i,j,...</sub><sup>exponent</sup></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.multiply(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            GEneral Matrix Multiply this array
            </summary>
            <overloads>General Matrix Multiply for double, float, complex and fcomplex arrays</overloads>
            <param name="A"><![CDATA[ILArray<>]]> matrix A</param>
            <param name="B"><![CDATA[ILArray<>]]> matrix B</param>
            <returns><![CDATA[ILArray<double>]]> new array - result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices. The matrix will be multiplied only 
            if dimensions match accordingly. Therefore B's number of rows must 
            equal A's number of columns. An Exception will be thrown otherwise. 
            The multiplication will carried out on BLAS libraries, if availiable and the 
            storage memory structure meets BLAS's requirements. If not it will be done inside .NET's 
            framework 'by hand'. This is especially true for referencing storages with 
            irregular dimensions. However, even GEMM on those reference storages linking into 
            a physical storage can (an will) be carried out via BLAS dll's, if the spacing 
            into dimensions matches the requirements of BLAS. Those are: 
            <list>
            <item>the elements of one dimension will be adjecently layed out, and</item>
            <item>the elements of the second dimension must be regular (evenly) spaced</item>
            </list>
            <para>For reference arrays where the spacing between adjecent elements do not meet the 
            requirements above, the matrix multiplication will be made without optimization and  
            therefore suffer from low performance in relation to solid arrays. See <a href="http://ilnumerics.net?site=5142">online documentation: referencing for ILNumerics.Net</a></para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">if at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.tan(ILNumerics.ILArray{System.Double})">
            <summary>Tangens of array elements</summary>
            <param name="A">input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logspace(System.Double,System.Double)">
            <summary>
            create logathmically spaced row vector of 50 elements 
            </summary>
            <param name="start">first exponent value</param>
            <param name="end">last exponent value</param>
            <returns>row vector with 50 elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.logspace(System.Double,System.Double,System.Int32)">
            <summary>
            create logathmically spaced row vector
            </summary>
            <param name="start">first exponent value</param>
            <param name="end">last exponent value</param>
            <param name="length">number of elements to create</param>
            <returns>row vector with 'length' elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.atan2(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Double})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.trace(ILNumerics.ILArray{System.Byte})">
            <summary>
            trace of matrix
            </summary>
            <param name="A">input matrix, size [m x n]</param>
            <returns>scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{ILNumerics.complex})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.subtract(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary> sum two arrays elementwise</summary>
            <param name="A">input 1</param>
            <param name="B">input 2</param>
            <returns> Array with elementwise sum of A and B </returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix also</param>
            <returns>sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix also</param>
            <returns>sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte})">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},System.Boolean)">
            <summary>
            sort data in A along first non singleton dimension
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <returns>sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
            <summary>
            sort data in A along dimension 'dim'
            </summary>
            <param name="A">input array, n-dimensional</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">output parameter: returns permutation matrix also</param>
            <returns>sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String})">
            <summary>
            sort strings in A along first non singleton dimension ascending
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},System.Boolean)">
            <summary>
            sort strings in A along first non singleton dimension
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},System.Int32,System.Boolean)">
            <summary>
            sort strings in A along dimension 'dim'
            </summary>
            <param name="A">input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="dim">dimension to sort along</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using bucket sort algorithm. Data 
            along the first non singleton dimension will therefore get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings will get determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.String},ILNumerics.ILArray{System.Double}@,System.Int32,System.Boolean)">
             <summary>
             sort data in A along dimension 'dim'
             </summary>
             <param name="A">input array: empty, scalar, vector or matrix</param>
             <param name="descending">Specifies the direction of sorting</param>
             <param name="dim">dimension to sort along</param>
             <param name="Indices">output parameter: returns permutation matrix also</param>
             <returns>sorted array of the same size as A</returns>
             <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
             in the next row/column.</para>
             <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.sort``3(ILNumerics.ILArray{``0},ILNumerics.ILArray{``2}@,System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
            <summary>
            generic sort algorithm in A along dimension 'dim' 
            </summary>
            <param name="A">input array: empty, scalar, vector or matrix</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">dimension to sort along</param>
            <param name="Indices">input/output parameter: the values in Indices will be returned in the same sorted order as the elements in A. This can be used to derive a permutation matrix of the sorting process.</param>
            <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived ILKeyMapper&lt;T,SubelementType&gt; and match the generic argument <typeparamref name="T"/>. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
            <returns>sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are always of type int.</para>
            <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually given to the function on the beginning. The given array's 
            elements will than be sorted in the same order as the input array A and returned.</para>
            <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly get used for the current sorting 
            without looking at their initial order.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Double})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{System.Double})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Byte})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{System.Byte})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Char})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Char},ILNumerics.ILArray{System.Char})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt64})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt64},ILNumerics.ILArray{System.UInt64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt32})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt32},ILNumerics.ILArray{System.UInt32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt16})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.UInt16},ILNumerics.ILArray{System.UInt16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int64})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int64},ILNumerics.ILArray{System.Int64})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int32})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int32},ILNumerics.ILArray{System.Int32})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int16})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Int16},ILNumerics.ILArray{System.Int16})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Single})">
            <summary>
            convert real array to complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
            <remarks> the newly created array will have a imaginary part of zero.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real2complex(ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single})">
            <summary>
            create complex array out of real and imaginary part
            </summary>
            <param name="real">real array for real part</param>
            <param name="imag">real array for imaginary part</param>
            <returns>complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will be the same size as real.</remarks>
        </member>
        <member name="M:ILNumerics.BuiltInFunctions.ILMath.real(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            real part of complex array
            </summary>
            <param name="X">complex input array</param>
            <returns>real part of complex array</returns>
        </member>
        <member name="P:ILNumerics.BuiltInFunctions.ILMath.MachineParameterDouble">
            <summary>
            give extensive numerical machine parameter informations - double precision
            </summary>
        </member>
        <member name="P:ILNumerics.BuiltInFunctions.ILMath.MachineParameterFloat">
            <summary>
            give extensive numerical machine parameter informations - single precision
            </summary>
        </member>
        <member name="T:ILNumerics.BuiltInFunctions.ILMath.GenEigenType">
            <summary>
            Specifies the type of eigenproblem 
            </summary>
            <remarks>The enumeration describes possible problem definitions for generelized eigenproblems:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list></remarks>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.Ax_eq_lambBx">
            <summary>
            A*V = r*B*V
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.ABx_eq_lambx">
            <summary>
            A*B*V = r*V
            </summary>
        </member>
        <member name="F:ILNumerics.BuiltInFunctions.ILMath.GenEigenType.BAx_eq_lambx">
            <summary>
            B*A*V = r*V
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithmStateChangedEventHandler">
            <summary>
            delegate type definition for handler handling algorithms state or progress change events
            </summary>
            <param name="sender">sender</param>
            <param name="e">parameter carrying extended algorithm state informations</param>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithm">
            <summary>
            Base class for all ILAlgorithms. User may derive their own algorithms from this class
            </summary>
            <remarks>ILAlgorithms excecute synchronously. Therefore the callee is responsible for 
            any threading / locking model if nesseccary. You should derive your own algorithms 
            from this class and call the default constructor ILArgorithm() of the base class from within your constructors. 
            ILAlgorithms provide an event handling mechanism for state and prgress information retrieval. 
            Developer of algorithms should frequently call versions of SetState and / or SetProgress which will
            raise the events for registered listeners.
            The actual work is triggered from the Run() method. Therefore this function should be overloaded or at least called 
            from derived classes as well. Since ILAlgorithms themself derive from ILMath, all static ILMath members (the core
            functions if ILNumerics.Net) are directly callable from within the class. </remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_state">
            <summary>
            internal field, holding the current state of algorithm
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_progress">
            <summary>
            internal field holding the current progress of algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetState(ILNumerics.ILAlgorithmState)">
            <summary>
            set the current state for algorithm
            </summary>
            <param name="state">state enumeration value</param>
            <returns>false: if on of the registrars of the StateChanged event wishes to cancel the operation, true otherwise.</returns>
            <remarks><para>calling this method will fire a StateChanged event.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetState(ILNumerics.ILAlgorithmState,System.String)">
            <summary>
            set the current state for algorithm and provide message
            </summary>
            <param name="state">state enumeration value</param>
            <param name="message">additional message with reason of state change</param>
            <returns>false: if on of the registrars of the StateChanged event wishes to cancel the operation, true otherwise.</returns>
            <remarks><para>calling this method will fire a StateChanged event.</para>
            <para>the message will be delivered to registrars of the StateChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetProgress(System.Double)">
            <summary>
            set the progress value
            </summary>
            <param name="progress">progress value in range 0...1.0</param>
            <returns>false: if on user has requested a cancellation, true otherwise.</returns>
            <remarks><para>calling this method will fire a ProgressChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.SetProgress(System.Double,System.String)">
            <summary>
            set the progress value
            </summary>
            <param name="progress">progress value in range 0...1.0</param>
            <param name="message">additional informational message with reason of progress change or description of current operation</param>
            <returns>false: if on user has requested a cancellation, true otherwise.</returns>
            <remarks><para>calling this method will fire a ProgressChanged event.</para>
            <para>the message given will be carried to registrars of the ProgressChanged event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.OnStateChanged(System.String)">
            <summary>
            helper function firing the state changed event
            </summary>
            <param name="message">string to be send within the 
            <see cref="T:ILNumerics.Algorithms.ILAlgorithmEventArgs"/> </param>
            <returns>false if a handler of the event has attempted to cancel the 
            operation, true if the algorithm should continue normaly.</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.OnProgressChanged(System.String)">
            <summary>
            helper function firing the progress changed event
            </summary>
            <param name="message">string to be send within the 
            <see cref="T:ILNumerics.Algorithms.ILAlgorithmEventArgs"/> </param>
            <returns>false if a handler of the event has attempted to cancel the 
            operation, true if the algorithm should continue normaly.</returns>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithm.m_name">
            <summary>
            internal field holding the name of this algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.#ctor">
            <summary>
            Default constructor 
            </summary>
            <remarks>Derived classes must call this base class constructor! This will set all 
            private attributes to default (inital) values. </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithm.Run">
            <summary>
            Start running this algorithm synchronously.
            </summary>
            <remarks>Derived classes must call this member via base() !</remarks>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAlgorithm.StateChanged">
            <summary>
            Fires on state changes
            </summary>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAlgorithm.ProgressChanged">
            <summary>
            fires on progress changes
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAlgorithm.Progress">
            <summary>
            get the current progress of the running algorithm 
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAlgorithm.Name">
            <summary>
            Name of the algorithm (readonly)
            </summary>
        </member>
        <member name="T:ILNumerics.ILArray`1">
            <summary>
            Main rectangular generic array type. Objects of this class are able to build references.
            </summary>
            <typeparam name="BaseT">inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks> This class serves as the main rectangular array holding arbitrary elements 
            in arbitrary dimensions. The most common specialisation will be a numeric array of arbitrary size. 
            <para>The most significant property of ILArray's is the ability to create, hold and handle references of other 
            ILArray's. Those references act like a solid array to the outside world but consume only a very little 
            memory itself. Therefore they directly use the elements of the original array for computations and only 
            store access rules in a very economical yet performant way. Write access to any arrays involved is 
            controlled by internal reference counting. The references are detached accordingly. That behavior 
            may also get flexible adjusted by the user of the library due to the 
            <see cref="T:ILNumerics.ILDetachingBehavior">ILDetachingBehavior</see> property. </para>
            <para>The inner type of the elements (specified through the generic parameter BaseT)
            does not change the general behavior of the ILArray<![CDATA[<>]]>. However, if it comes 
            to mathematical operations there is a limited number 
            of inner types common mathematical functions and operators are defined for. All basic 
            operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are defined for all ILArray's having 
            the inner type BaseT of a numeric type (system defined like 'double','int' - or complex, fcomplex).
            Some functions are defined for even less types. This is the case mostly for all linear algebraic functions 
            explicilty involving matrices or vectors (LAPACK) and for trigonometric functions and those, 
            wich explicitly return floating point values (cos, atan etc.). Therefore you may create ILArrays 
            of arbitrary types, but might not be able to use them afterwards in other then some basic 
            operations defined for all ILArrays - regardless of the inner type - like concatenation, (de)serialization and 
            string exports. </para>
            </remarks>
            <seealso cref="T:ILNumerics.ILBaseArray"/>
        </member>
        <member name="T:ILNumerics.ILBaseArray`1">
            <summary>
            Typed base class for all ILNumerics.Net data storage classes for any storage type. 
            </summary>
            <remarks><para>You should not use this type directly. It serves as a base class 
            for all typed storages only and will be used be derived classes like ILArray<![CDATA[<>]]>.</para>
            <para>If you are looking for an (untyped) base class to be used as generic class for any ILArray types, you should use ILBaseArray instead!</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILBaseArray">
            <summary>
            The base type for all array datatypes of ILNumerics.Net
            </summary>
            <remarks>All numerical arrays must derive from ILBaseArray. ILBaseArrays itself 
            cannot be instanciated. By now only ILArray<![CDATA[<>]]> exist, which describes 
            a rectangular array as full (solid) or referencing array. There are plans to 
            extend the collection of derived types by triangular and sparse arrays. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;complex></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Byte)~ILNumerics.ILBaseArray">
            <summary>
            cast scalar to ILBaseArray
            </summary>
            <param name="input">system value type</param>
            <returns>ILBaseArray</returns>
            <remarks>The ILBaseArray returned will be scalar of type ILArray&lt;byte></remarks>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_name">
            <summary>
            	Name of this object.
            </summary>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_dimensions">
            <summary>
            dimension specification for this storage object
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Clone">
            <summary>
            Create full (shallow) copy of this storage. 
            </summary>
            <returns>ILArray as new (physical) representation of this storages data.</returns>
            <remarks>The ILArray object returned will be of the same size than this object.
            Keep in mind, no reference counters are altered! The new object is just a plain 
            copy of the old one which remains unchanged. Also: "copy" means, the m_data array
            will be copied, but (of course) not (!) the objects referenced by the array elements!
            Therefore this is a 'shallow' copy only! This is necessary, since objects stored inside
            ILArray do not have any restrictions. (Especially they do not have to support the IClonable()
            interface.) </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ValuesToString(System.Int32)">
            <summary>
            Convert values of elements into string representation.
            </summary>
            <param name="maxLength">0: all columns will be printed behind each other. 
            Other than 0: The columns will be split after 'maxLength' characters. </param>
            <returns>Formated string representation</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            print values of this instance to stream 
            </summary>
            <param name="outStream">Stream to write the values into</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial' </param>
            <param name="method">a constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If for method 'Formated' is used, any occourences of a NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is due to 
            prevent the format from breaking the 'page' style for the output. </para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream than. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Name">
            <summary>
            	Set/Get name for this object.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Dimensions">
            <summary>
            Dimension for this storage. 
            </summary>
            <value>This is a read only property. Only derived types are allowed to alter the dimensions object directly.</value>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Length">
            <summary>
            Length of longest dimension in this instance
            </summary>
            <remarks>This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsScalar">
            <summary>
            Determine if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Dimension.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsMatrix">
            <summary>
            Determine if this array is a matrix.
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly. </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsVector">
            <summary>
            Determine if this array is a vector.
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind, all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly. </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsEmpty">
            <summary>
            true if array is empty (number of elements stored is 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsComplex">
            <summary>
            Determine if this array is of complex inner type
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsNumeric">
            <summary>
            Determine if this array is of numeric inner type
            </summary>
        </member>
        <member name="F:ILNumerics.ILBaseArray`1.m_data">
            <summary>
            The actual storage array. 
            </summary>
            <remarks> The derived type is responsible for the implementation, which way 
            the storage is used. So far, this is only an 1D-System.Array of arbitrary size 
            and type.This is hidden for framework users since direct public access 
            to the storage is not intended for public users. </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.ShiftDimensions(System.Int32)">
            <summary>
            Create shifted version of this array
            </summary>
            <param name="shift">number of dimensions to shift this storage.</param>
            <returns>storage as shifted version of this storage.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray to this storage
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Subarray(System.String[])">
            <summary>
            Subarray to this array
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter values specified by range
            </summary>
            <param name="range">
            ILRange specifying the dimensions/indices to alter
            </param>
            <param name="values">
            ILArray holding the new values.
            </param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            coming from vals. If the underlying 
            ILArray pointed to by vals is of another size then specified 
            by range, only a part of the vals-storaged will be used or respectivly 
            those values will repeatedly get inserted. One may use this as a 
            feature for filling the range with a sequence of values repeatedly. 
            On the other hand this may cause the problem of not recognizing 
            differences in the size between vals and range!
            Another remarkable situation arises, if this storage is the only 
            reference wich is left to an physical storage array and it holds 
            multiple (repeated) entries to single array elements. Due to the 
            nature of a "reference", altering any values will also update corresponding
            entries in the reference storage, pointing to the same underlying elements. 
            (In fact, those corresponding values will only point to the updated 
            elements also.) Keep in mind, that setting a range for a reference which 
            is connected to an array which is referenced by more than one storage, will 
            usually lead to a Detach() process - therefore the storage gets disconnected 
            and the behavior described will not happen. Since for the user the result 
            is not transparent, consider to eather 
            <list type="bullet">
            <item>
            check the state of the storage before calling SetRange() </item>
            <item>Detach() the storage manually, if required, or</item>
            <item>set the static flag DetachReferences to true to detach all reference storages 
            automatically before altering any values on it.</item></list> Hoever there might be 
            situations, where one may want to alter many values by altering only 
            one. Therefore the above mentioned flag might be set to true if needed. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into binary stream.
            </summary>
            <param name="outStream">Sysem.IO.Stream to receive the byte sttream 
            for this ILBaseArray</param>
            <returns>true on success, false on error</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize / restore ILArray from binary stream 'inStream'
            </summary>
            <param name="inStream">System.IO.Stream to reconstruct the 
            ILArray from</param>
            <returns><![CDATA[ILArray<BaseT>]]> reconstructed from Stream. If 
            the ILArray could not get restored, an SerializationException 
            will be thrown. </returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.CreateIterator">
            <summary>
            Create iterator for the elements of the current instance of ILBaseArray
            </summary>
            <returns>Iterator of the same type as the current instance of ILBaseArray, initialized 
            to the first element, ready for counting forwards on 
            the first dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.CreateIterator(ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            Create iterator for the elements of the current instance of ILBaseArray, specify start 
            element and dimension to walk along
            </summary>
            <param name="pos">start position. One out of the ILIteratorPositions: 
            ILStart, ILMiddle, ILEnd</param>
            <param name="leadingDimension">The dimension index to walk along</param>
            <returns>Iterator of the same type as the current instance of ILBaseArray
            </returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value. This can be a comma seperated list 
            or a System.Array.</param>
            <returns>Object on the position pointed to by idx</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified.
            </summary>
            <param name="value">new value</param>
            <param name="idx">index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetEnumerator">
            <summary>
            create enumerator returning skalar <![CDATA[ILArray<BaseT>]]>
            </summary>
            <returns>enumerator</returns>
            <remarks>This makes objects of type <![CDATA[ILBaseArray<BaseT>]]> usable in a foreach loop.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            create enumerator 
            </summary>
            <returns>generic enumerator of inner base type as IEnumerator interface</returns>
            <remarks>This makes objects of type <![CDATA[ILBaseArray<BaseT>]]> usable in a foreach loop.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Iterator(System.Int32)">
            <summary>
            create enumerator capable of walking along arbitrary dimensions 
            </summary>
            <param name="leaddim">leading dimension</param>
            <returns>enumerator of inner base type</returns>
            <remarks>This makes the return value usable in a foreach loop.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.Data">
            <summary>
            Give direct reference for this data array
            </summary>
            <remarks>This property is only used by C++ derivate (copy constructor)</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values
            </summary>
            <remarks>An ILArray is stated to be 'numeric' as long as its inner type is one of the 
            following: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.Values">
            <summary>
            create enumerator returning elements of inner base type
            </summary>
            <value>enumerator walking along the first dimension</value>
            <remarks>This makes the return value usable in a foreach loop.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if exist
            </summary>
            <param name="minValue">output: minimum value</param>
            <param name="maxValue">output: maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. The output parameter will be found as default(type).</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.zeros(System.Int32[])">
            <summary>
            Create array with all elements initialized to zero
            </summary>
            <param name="dimensions">length of each dimension. This may be a comma separated 
            list of int values</param>
            <returns>Solid ILArray of specified size.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.zeros(ILNumerics.Misc.ILDimension)">
            <summary>
            Create array with all elements initialized to zero
            </summary>
            <param name="dimension">ILDimension object</param>
            <returns>Solid ILArray of specified size.</returns>
            <remarks>The ILDimension given will be cloned before used.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty">
            <summary>
            create empty array, size (0 x 0)
            </summary>
            <returns>Empty ILArray</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(System.Int32[])">
            <summary>
            create empty array, size dims
            </summary>
            <returns>Empty ILArray</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(ILNumerics.Misc.ILDimension)">
            <summary>
            create empty array, size dims
            </summary>
            <returns>Empty ILArray</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToString">
            <summary>
            write informations about this ILArray to string
            </summary>
            <returns>String containing general information about the current instance of 
            ILArray and the formated elements values.</returns>
            <remarks>If the number of elements exceeds 10000 the writing of all elements will 
            be ommitted.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToString(System.String,System.Int32)">
            <summary>
             formated output for this ILArray
            </summary>
            <param name="s">
            predefined string to be prepended to the output. This may be an empty String (not null!).
            </param>
            <param name="maxLength">maxmum number of characters for the output lines.</param>
            <returns>Formated string holding all values of this storage.
             If the number of values exceeds 10.000, the number of elements 
             will be printed only.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.debuggerHeadLineDisplay">
            <summary>
            here is created, what will be displayed in the headline of the objects if displayed in variable windows
            </summary>
            <returns>string with the headline - value is depending on the size of the array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.ValuesToString(System.Int32)">
            <summary>
            print formated values to string (in the 'matlab style')
            </summary>
            <param name="maxLength">maximum number of characters per line. Set 
            to 0 to not limit this length at all.</param>
            <returns>StringBuilder object filled with formated value's </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj
            </summary>
            <param name="obj">typed ILArray containing the values to compare this array with</param>
            <returns>true if all elements contained in obj are equal to the 
            elements of this array. False otherwise.</returns>
            <remarks> This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Equals(ILNumerics.ILBaseArray{`0})">
            <summary>
            test if this ILArray equals another ILBaseArray
            </summary>
            <param name="obj">ILBaseArray to compare this ILArray with</param>
            <returns>true if all elements match, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetHashCode">
            <summary>
            Get Hash Code of the current instance.
            </summary>
            <returns>Hash code of the current instance</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter values specified by range
            </summary>
            <param name="range">
            ILRange specifying the dimensions/indices to be altered
            </param>
            <param name="values">
            ILIterator initialized and pointing to the ILArray 
            holding the new values.
            </param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            found in 'values'. 
            A remarkable situation arises, if this storage is the only 
            reference wich is left to an physical storage array and it holds 
            multiple (repeated) entries to single array elements. Due to the 
            nature of a "reference", altering any values will also update corresponding
            entries in the reference storage, pointing to the same underlying elements. 
            (In fact, those corresponding values will only point to the updated 
            elements also.) Keep in mind, that setting a range for a reference which 
            is connected to an array which is referenced by more than one storage, will 
            usually lead to a Detach() process - therefore the storage gets disconnected 
            and the behavior described will not happen. Since for the user the result 
            is not transparent, consider to eather 
            <list type="bullet">
            <item>
            check the state of the storage before calling SetRange() </item>
            <item>Detach() the storage manually, if required, or</item>
            <item>set the static flag ILDetachingBehavior to DetachAlways or DetachWrite (default)
            to detach all reference storages automatically before altering any values on it.</item>
            </list> 
            However there may be situations, where one may want to alter many values by changing only 
            one. Therefore the above mentioned flag might be set to true if needed. 
            <para>If range contains indices outside of the my dimensions, this array will be reshaped (expanded)
            yccording to those indices. However this might lead to a performance penalty. So you better not 
            expand an array by addressing indices outside of my dimensions! Consult the reference manual for hints 
            to circumvent this situation.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Double},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILArray{System.Byte},ILNumerics.ILBaseArray{`0})">
            <summary>
            Alter elements of this array adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match 
            number of elements of indices. The only exception to this rule is if storage is scalar. The 
            single value of storage is than used to set all elements addressed by indices.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ShiftDimensions(System.Int32)">
            <summary>
            Create Reference of the current instance of ILArray and simultanously shift 
            dimensions
            </summary>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>ILArray pointing to the current instance</returns>
            <remarks> <para> the type of array returned will depend on the size of the array and
            the setting of the MinimumRefDimensions member.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.S(System.Int32)">
            <summary>
            Get shifted version of this array
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>ILArray of the same type having its dimensions shifted accordingly.</returns>
            <remarks><paramref name="shift"/> may be any integer value. It will be used in modulus 
            the number of my dimensions.
            <para>This is an alias or shortcut for <see cref="M:ILNumerics.ILArray`1.ShiftDimensions(System.Int32)"/> </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetShifted(System.Int32)">
            <summary>
            get reference to this array having the dimensions shifted by <c>shiftDimensions</c>.
            </summary>
            <param name="shiftDimensions">number of dimensions to shift this array (to the left for positive values)</param>
            <returns>Referencing ILArray of the same type and size with <c>shiftDimensions</c> dimensions shifted to the left.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Reshape(ILNumerics.Misc.ILDimension)">
            <summary>
            Reshape this array
            </summary>
            <param name="newDimensions">new dimension object</param>
            <returns>This array after reshaping.</returns>
            <remarks><para>This member changes the current objects dimension. The ILArray will have the 
            size and number of dimension specified by newDimensions. </para>
            <para>If this is a reference array, it is beeing detached.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the number of elements dont stay the same</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Reshape(System.Int32[])">
            <summary>
            Reshape this array
            </summary>
            <param name="dims">new dimension length</param>
            <returns>this array after reshaping</returns>
            <remarks><para>This member changes the current objects dimension. The ILArray will have the 
            size and number of dimension specified by newDimensions. </para>
            <para>If this is a reference array, it is beeing detached.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the number of elements dont stay the same</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Concat(ILNumerics.ILArray{`0},System.Int32)">
            <summary>
            Concatenate this array 
            </summary>
            <param name="inArray">N-dimensional array</param>
            <param name="leadDim">index of dimension to concatenate arrays along.
            If leadDim is larger than the number of dimensions of one of the arrays
            its value will be used in modulus</param>
            <returns>array having the size of both input arrays layed behind each 
            other along the leadDim's-dimension</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference storage, if inArray is the same as this (object references 
            are the same) and ILArray.MinimumRefDimensions is less or equal 
            the number of dimensions of the resulting storage, or a 
            </item>
            <item>physical storage else. 
            </item></list>
            There are only very few cases where it is possible to reference two arrays in the 
            same reference storage. Not only the storages must point to the same underlying 
            physical System.Array, but the ILIndexOffset must be suited in a special way. 
            Therefore the restriction was made always to create a solid storage, if 
            both storages are not the same.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Repmat(System.Int32[])">
            <summary>
            Replicate this storage. Make large storage out of this
            </summary>
            <param name="dims">dimensions specifier. This may be a 
            list or an array of integer values. If the number of elements in dim is 
            less the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension of this array - the result 
            will get its number of dimensions extended accordingly. </param>
            <returns>large array beeing a multiple (dims) copy of this array along 
            arbitrary dimensions</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference array, if the number of resulting dimensions is &lt;= 
            MinimumRefDimensions, or a 
            </item>
            <item>dense array else. 
            </item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.Remove(System.Int32,System.Int32[])">
            <summary>
            Remove dimension indices specified from array
            </summary>
            <param name="dimension">index of dimension where the <c>indices</c> are located.</param>
            <param name="indices">dimension indices to be removed</param>
            <remarks>after processing, the dimensions indices specified will be removed 
            from all dimensions of this ILArray. The operation is done by building a reference for the 
            existing ILArray. For the indices specified by range, the data 
            will be excluded. Depending on the value of the property
            ILSettings.DetachReferences, this ILArray will be left as solid array (i.e. it 
            would be explicitely detached) or left as referencing ILArray - which should be fine for 
            most situations.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            print values of this instance to stream 
            </summary>
            <param name="stream">Stream to write the values into</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial' </param>
            <param name="method">a constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If for method 'Formated' is used, any occourences of a NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is due to 
            prevent the format from breaking the 'page' style for the output. </para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream than. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.exportMatlab(System.IO.BinaryWriter,System.Single)">
            <summary>
            [deprecated] Write data of this ILArray to MATLAB .mat file
            </summary>
            <param name="fileout">Binary stream receiving the data</param>
            <param name="version">(not used)</param>
            <remarks>This function is deprecated and will soon be removed. 
            Use <see cref="T:ILNumerics.ILMatFile"/> instead!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value</param>
            <returns>Object on the position pointed to by idx</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetValueSeq(System.Int32,System.Int32[]@)">
            <summary>
            Get single value from this storage by single sequential access
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value</param>
            <param name="dims">out value: return mapped position in dimensions</param>
            <returns>Object on the position pointed to by idx</returns>
            <remarks>dims is the final position into the array for the sequential index specification <c>idx</c>.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified.
            </summary>
            <param name="value">new value</param>
            <param name="idx">index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.getBaseIndex(System.Int32[])">
            <summary>
            Convert index array into sequential index for storage access.
            </summary>
            <param name="idx">int array with dimensions specification</param>
            <returns>Index of requested value inside the physical storage. This 
            value may directly be used to query the value via m_data[return_value].
            </returns>
            <remarks>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the behavior
            is undefined. Therefore this function should be enclosed in try,catch blocks 
            to handle this case!</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.getBaseIndex(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Convert index array into sequential index for storage access. Ommit any bound checking.
            </summary>
            <param name="idx">int array with dimensions specification</param>
            <param name="MustExpand">Output parameter. On return determine, if the index 
            specification points outside of the dimensions of this ILArray and the array 
            must be expanded before accessing elements on that position</param>
            <param name="Dimensions">if the array was found to be expanded, this are the 
            needed dimension sizes for the new array. The sizes are computed from the range 
            specification given.</param>
            <returns>Index of requested value inside the physical storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value returned is valid for physical storages as well as for reference 
            storages.
            </returns>
            <remarks>
            <para>idx must be not null and must contain at least one element.</para>
            <para>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the index of 
            the expanded array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array
            </summary>
            <param name="result">System.Array returned, holding all element values of this ILArray</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            corresponding elements with index lower or equal to i will be overwritten. Here i is the number of elements
            contained in the ILArray. If 'result' is null or has less than i elements, it will be recreated from the ILMemeoryPool.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExtractRemovalParameter(System.Object,System.Int32@,System.Int32[]@,ILNumerics.Misc.ILDimension@)">
            <summary>
            helper function to prepare parameters for partial removal 
            </summary>
            <param name="range">object with index specification.May be of 
            type ILBaseArray[] with numeric arrays or a string array according 
            to the format of <see cref="T:ILNumerics.Storage.ILRange"/>. 
            </param>
            <param name="dimensionIdx">out parameter: number of dimension the indices to be removed lay in</param>
            <param name="indices">indices to be removed</param>
            <param name="dimensions">dimension structure, may be used if the array must be 
            reshaped <b>before</b> the removal.</param>
            <remarks>if range consists out of a range specification wich is smaller than 
            the actual dimension length of this array, the array must also be reshaped in order to remove 
            the data accordingly. This reshape proccess will <b>not</b> be done inside of this function! However 
            ther <c>dimension</c> value returned reflect the size of the array before removing and therefore
            may comfortable be used for reshaping the array.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <list type="bullet">
            <item>the length of range exceeds the dimensions of this array</item>
            <item>more or less than exactly one dimension of <c>range</c> was not null</item>
            <item>the type of range was invalid, or</item>
            <item>range is of type array of <see cref="T:ILNumerics.ILBaseArray"/>, but the elements are non numeric ILArray's</item>
            </list></exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.Clone">
            <summary>
            Create full (shallow) copy of this storage. 
            </summary>
            <returns>ILFullArray as new (physical) representation of this storages data.</returns>
            <remarks>The ILFullArray object returned will be of the same size than this object.
            Keep in mind, no reference counters are altered! The new object is just a plain 
            copy of the old one which remains unchanged. Also: "copy" means, the m_data array
            will be copied, but (of course) not (!) the objects referenced by the array elements!
            Therefore this is a 'shallow' copy only! This is necessary, since objects stored inside
            ILArray do not have any restrictions. (Especially they do not have to support the IClonable()
            interface.) </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateIterator">
            <summary>
            Create iterator, initialized to run from start over first dimension
            </summary>
            <returns>Iterator of the same type as the current instance of ILArray, initialized 
            to the first element, ready for counting forwards on 
            the first dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreateIterator(ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            Create iterator for the elements of the current instance of ILArray, specify start 
            element and dimension to walk along
            </summary>
            <param name="pos">start position. One out of the ILIteratorPositions: 
            ILStart, ILMiddle, ILEnd</param>
            <param name="leadingDimension">The dimension index to walk along</param>
            <returns>Iterator of the same type as the current instance of ILArray
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.GetEnumerator">
            <summary>
            Enumerator creation
            </summary>
            <returns>Enumerator</returns>
            <remarks>This function enables the use of ILArray inside 'foreach' constructs. You 
            barely will use it directly.</remarks>
            <example>ILArray&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (ILArray&lt;T&gt; element in A) {
            // all 'element's are scalar ILArray's
            String.Format("Element: {0} ",element.GetValue(0));
            }
            </example>
            <seealso cref="P:ILNumerics.ILArray`1.Values"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExpandArray(ILNumerics.Storage.ILRange)">
            <summary>
            Expand this storage for addresses outside my dimensions
            </summary>
            <param name="range">range to fit inside destination array</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.ExpandArray(System.Int32[])">
            <summary>
            Expand this storage for addressed outside my dimensions
            </summary>
            <param name="indices">range to fit inside destination array</param>
            <remarks>The input parameter <c>indices</c> will directly be used to create new
            ILDimension member of the resized array.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.copyUpperTriangle(System.Int32)">
            <summary>
            copy upper triangular part of this array into new physical array
            </summary>
            <param name="n">length of first dimension of destination array </param>
            <returns>physical array of size [n x {ThisColumnCount})]</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.copyLowerTriangle">
            <summary>
            copy lower triangular part of this array into new physical array
            </summary>
            <returns>physical array of same size than this array</returns>
            <remarks>if this is not a 2D array, only the first dimension is referenced.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Addition(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Overloads plus operator for ILArrays of numeric type
            </summary>
            <param name="in1">First summand</param>
            <param name="in2">Second summand</param>
            <returns>New solid ILArray of same type as input array with sum of elements of 
            <code>in1 + in2 </code>
            </returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Subtraction(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Overloads minus operator for subtracting two ILArrays of numeric type elementwise
            </summary>
            <param name="in1">Minuend</param>
            <param name="in2">Subtrahend</param>
            <returns>New ILArray of same type as in1 with difference of elements for 
            <code>in1 - in2</code></returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Multiply(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <summary>
            Elementwise multiplication
            </summary>
            <param name="in1">first factor</param>
            <param name="in2">second factor</param>
            <returns>New ILArray of same type as the first input array of the same size than in1 and in2 holding 
            the elementwise products of both arrays</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Double},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{ILNumerics.complex},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Division(ILNumerics.ILArray{System.Byte},ILNumerics.ILArray{`0})">
            <overloads>This operator is overloaded for all numeric types.</overloads>
            <summary>
            Elementwise division
            </summary>
            <param name="in1">dividend</param>
            <param name="in2">divisor</param>
            <returns>New ILArray of same type as in1 of the same size than in1 and in2 holding 
            the elementwise division of both arrays: (return array = dividend ./ in2)</returns>
            <remarks>This operator is overloaded for all numeric datatypes: <![CDATA[ILArray<double>,ILArray<float>,ILArray<complex>,ILArray<fcomplex>,ILArray<byte>,ILArray<char>,ILArray<Int16>,ILArray<Int32>,ILArray<Int64>,ILArray<UInt16>,ILArray<UInt32>,ILArray<UInt64>,]]></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Equality(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Equalty operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1">first input array</param>
            <param name="in2">second input array</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 equal in2's elements, false if they are not equal.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is valid for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException">thrown if the types 
            of input arguments do not match or the operator does not support the ILArray inner type.
            </exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Inequality(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Unequalty operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 and in2 beeing unequal, false if they are equal.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThanOrEqual(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            Greater or equal operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 are greater or equal in2's elements, false else.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThanOrEqual(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            smaller or equal operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 smaller or equal in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThan(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            greater operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 greater in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThan(ILNumerics.ILArray{`0},ILNumerics.ILArray{`0})">
            <summary>
            smaller operator of <![CDATA[ILArray<>]]> with <![CDATA[ILArray<>]]>
            </summary>
            <param name="in1"><![CDATA[ILArray<>]]></param>
            <param name="in2"><![CDATA[ILArray<>]]></param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 smaller as in2's elements, false if they are not.
            </returns>
            <remarks>Dimension of in1 and in2 must match. This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]>. The type of in1 must be the same as the 
            type of in2.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Equality(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Equalty operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Inequality(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Unequalty operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 not equal in2, false if they are equal.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThanOrEqual(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Greater or equal operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 are greater or equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThanOrEqual(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Smaller or equal operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing smaller or equal in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_GreaterThan(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Greater operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing greater in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_LessThan(ILNumerics.ILArray{`0},System.Double)">
            <summary>
            Smaller operator of <![CDATA[ILArray<>]]> with scalar
            </summary>
            <param name="in1">ILArray</param>
            <param name="in2">Scalar</param>
            <returns>ILLogicalArray of same size than in1, with elements having 'true' values 
            for all corresponding elements of in1 beeing smaller in2, false if they are not.
            </returns>
            <remarks>This operator is overloaded for 
            all numeric types of <![CDATA[ILArray<>]]> for in1. The type of in2 is always double. </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert scalar to ILArray of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns> New ILArray of type ILArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[])~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast 1-dim. system array to ILArray (vector)
            </summary>
            <param name="vector_elements">1d system array arbitrary type</param>
            <returns>ILArray of same type as elements - built as row vector. Empty array if input is null.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(System.Array)~ILNumerics.ILArray{`0}">
            <summary>
            implicit cast n-dim. system array to ILArray
            </summary>
            <param name="elements">arbitrary sized System.Array</param>
            <returns>If elements is null: empty array. Else: ILArray of same size as elements</returns>
            <remarks>The inner type of input array <paramref name="elements"/> must match the requested type <typeparamref name="BaseT"/>. The resulting ILArray will reflect all dimensions of the input. Elements of input array will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match requested type BaseT</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Explicit(ILNumerics.ILArray{`0})~`0">
            <summary>
            Explicitly convert ILArray of size 1x1 (scalar) to system value type.
            </summary>
            <param name="val">ILArray of type ILArray <![CDATA[BaseT]]> of size 1x1</param>
            <returns> System type of size scalar holding the only element with value of val.
            </returns>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if input ILArray is not scalar</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_UnaryNegation(ILNumerics.ILArray{`0})">
            <summary>
            negate elements of array - if applicable
            </summary>
            <param name="in1">input array</param>
            <returns>new solid arrray having the elements of in1 negated</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            Create ILArray of specified size and type
            </summary>
            <param name="size">
            Variable length integer array specifying the number and size of dimensions 
            to be created.
            </param>
            <param name="data">preallocated array with data. The array will
            directly be used for storage. No copy will be done.</param>
            <remarks>The size parameter may not be null or empty! 
            An exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified type and 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.Misc.ILDimension)">
            <summary>
            Create ILArray of specified size and type
            </summary>
            <param name="data">preallocated array with data. The array will
            directly be used for storage. No copy will be done.</param>
            <param name="dimensions">
            dimension specification. The ILDimension given must not be null and will 
            directly be used for the new object! No copy will be made for it!
            </param>
            <remarks>The size parameter may not be null or empty! 
            An exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified type and 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(System.Int32[])">
            <summary>
            	Create ILArray of type object and given name and size 
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions 
            to be created.
            </param>
            <remarks>The size parameter may not be null or an empty array! 
            An Exception will be thrown in this case. The dimensions will be trimmed 
            before processing (removing non singleton dimensions from the end). 
            Depending on the requested size an ILArray of the specified 
            dimension will be created. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILArray{`0})">
            <summary>
            'Copy' Constructor. Creates a new ILArray as exact copy of input array
            </summary>
            <param name="inp">
            ILArray object to create a copy from
            </param>
            <remarks>
            <para>
            The ILArray given will be copied and the reference counter will get increased. The resulting 
            new ILArray will be an exact - but shallow - copy of inp. 
            Use this constructor only for casting purposes! For copy/clone operations 
            use the Subarray/CreateReference/Copy/Clone functions or the index access instead!</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.MarshalCopy(ILNumerics.ILArray{`0})">
            <summary>
            implicit copy constructor
            </summary>
            <param name="inp">ILArray to be copied</param>
            <remarks>This is used in C++ derivate as assignment operator</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[])">
            <summary>
            create scalar or row vector from values explitely given
            </summary>
            <param name="vector_elements">elements. </param>
            <remarks><para>The elements may are given as comma seperated list or as predefined System.Array 
            of type 'BaseT'. In this case the System.Array object given will directly be used as storage 
            for the newly created ILArray.</para>
            <para>If vector_elements is null, an empty ILArray will be created.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor">
            <summary>
            Standard constructor creating empty ILArray
            </summary>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this ILArray + dimension shift
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> string specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Subarray(System.String[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Double})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{ILNumerics.complex})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequential(ILNumerics.ILArray{System.Byte})">
            <summary>
            create physical copy from this physical array 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <returns>physical copy of elements addressed by indices.shape of indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalSequentialShifted(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            create physical copy from this physical array and shift dimensions 
            </summary>
            <param name="indices">sequential indices. may be of any size</param>
            <param name="shift">number of dimensions to shift the result</param>
            <returns>physical copy of elements addressed by indices.shape of shifted indices</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysical(ILNumerics.Storage.ILRange)">
            <summary>
            create physical subarray from physical ILArray 
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalSubarrayFromPhysicalShifted(System.Int32,ILNumerics.Storage.ILRange)">
            <summary>
            create shifted physical subarray of ILArray specified by range and shift
            </summary>
            <param name="range">must be valid range</param>
            <param name="shift">may be any integer - will be handled modulus ranges dimensions</param>
            <returns>physical array specified by range / shift</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalShiftedFromPhysical(System.Int32)">
            <summary>
            create physical shifted version if this is physical array 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>physical array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.CreatePhysicalShiftedFromReference(System.Int32)">
            <summary>
            create physical shifted version if this is a reference array 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>reference array</returns>
        </member>
        <member name="P:ILNumerics.ILArray`1.T">
            <summary>
            create transposed version transpose / dimension shift by 1 dimension
            </summary>
            <remarks>this is an alias for GetShifted(1).
            <para><c>T</c> returns an Array of the same size than this array, but 
            having the dimensions shifted by 1. This array may be a vector, matrix or n-dimensional array.</para>
            <para>For complex arrays the result will <![CDATA[<b>NOT<b/>]]> be the complex conjugate! The 
            content of this array will copied only without altering.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.C">
            <summary>
            create solid clone of this object
            </summary>
            <remarks>this is a casting alias for object <![CDATA[ILArray<BaseT>.Clone()]]>.</remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.MaxValue">
            <summary>
            maximum of all elements in this array - if exists
            </summary>
            <remarks>For reference types the original element will be returned. No copy will be made!
            <para>in order to be comparable, the inner type of this array must implement IComparable. If it does not, 
            an exception will be thrown. </para>
            <para>Important note: keep in mind, the element with the largest distance from the center will be returned. For 
            all numeric types, this might be a <b>negative</b> value as well! </para> </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException"> if the inner type BaseT cannot be compared. Inner types 
            must implement IComparable&lt;&gt; in order to compute the maximum.</exception>
        </member>
        <member name="P:ILNumerics.ILArray`1.MinValue">
            <summary>
            Minimum of all elements in this array - if exists
            </summary>
            <remarks>For reference types the original element will be returned. No copy will be made!
            <para>in order to be comparable, the inner type of this array must implement IComparable. If it does not, 
            an exception will be thrown. Note: all numeric System types do implement IComparable.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentTypeException"> if the inner type BaseT cannot be compared. Inner types 
            must implement IComparable&lt;BaseT&gt; in order to compute the maximum.</exception>
        </member>
        <member name="P:ILNumerics.ILArray`1.Diagonal">
            <summary>
            Get / set diagonal elements 
            </summary>
            <value>vector of same length as number of diagonal elements or scalar. If value is scalar, 
            all diagonal elements will be filled with this scalar value.</value>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.String[])">
            <summary>
            Subarray access for get/set/removal 
            </summary>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the selected parts removed.</returns>
            <remarks>Query access: for N-dimensional arrays and at least 1 dimensions specified, missing trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <example>
            <code>Having a matrix A =     
            [0, 1, 2, 3
            4, 5, 6, 7];
            So A[":,2"] will lead to 
            [2
             6]; 
            A["1,:"] gives [4, 5, 6, 7]
            A["1"] gives [4]
            A["1,1"] gives [5]
            </code>
            </example>
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains complex index specifications for one ... any 
            dimension. If more than one dimension is to be specified, the dimensions must be seperated 
            by ';' (semicolon).</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than ";". If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int16,System.String[])">
            <summary>
            Subarray access for ILArray and dimension shift
            </summary>
            <paramref name="dims" value="dimension specification"/>
            <value>returns new ILArray as reference subarray to this ILBaseArray</value>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int32[])">
            <summary>
            get/set/remove single element 
            </summary>
            <param name="indices">The type of access depends on the length of indices. 
            <list type="bullet">
            <item>if indices is a single value: sequential (linear) index of element to access</item>
            <item>if indices.Length &gt; 1: index array access </item></list></param>
            <returns>scalar ILArray of same type than this array with the only element</returns>
            <remarks>If indices contains only one element, the array will be accessed via sequential index access. 
            This is sometimes called "linear" index access also. Sequential index access reflects the index of internal storage 
            the way the data are actually organized in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access: 
            <example><code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A[2] gives: 3.0
            </code>But
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0</code>
            <para>For get access the array returned will be a scalar solid array.</para></example>
            <para>The reason, this indexer return ILArray is that returning BaseT directly would permit 
            the use of convinient syntax: A[2] = null; for removal ! There is also the argument of consistency between the indexer. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            subarray access
            </summary>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(System.Int16,ILNumerics.ILBaseArray[])">
            <summary>
            ranged subarray access
            </summary>
            <param name="shiftDim">number of dimensions to shift the result</param>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. </returns>
            <remarks>For n-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range. However, if range contains only one array, those indices 
            are interpreted as sequential index access elements. I.e. the elements in the index vector are allowed to 
            range from 0...[NumberOfElements-1]. A vector containing corresponding elements will be returned for this case.
            <para>The indexer may be used for querying single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILArray`1.Values">
            <summary>
            Enumerator returning elements in their natural type
            </summary>
            <example>ILArray&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A.Values) {
            // all 'element's are scalar double values
            String.Format("Element: {0} ",element);
            }
            </example>
        </member>
        <member name="T:ILNumerics.MatFileType">
            <summary>
            inner types for MATLAB data elements
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUNKNOWN">
            <summary>
            unknown 
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT8">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT16">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT32">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miSINGLE">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miDOUBLE">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miINT64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUINT64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miMATRIX">
            <summary>
            matrix type (general)
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miCOMPRESSED">
            <summary>
            compressed
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF8">
            <summary>
            utf8 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF16">
            <summary>
            utf16 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileType.miUTF32">
            <summary>
            utf32 encoded
            </summary>
        </member>
        <member name="T:ILNumerics.MatFileArrayClass">
            <summary>
            types for matrix chunks
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxCELL_CLASS">
            <summary>
            cell
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSTRUCT_CLASS">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxOBJECT_CLASS">
            <summary>
            object
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxCHAR_CLASS">
            <summary>
            char
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSPARSE_CLASS">
            <summary>
            sparse
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxDOUBLE_CLASS">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxSINGLE_CLASS">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT8_CLASS">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT8_CLASS">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT16_CLASS">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT16_CLASS">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxINT32_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.MatFileArrayClass.mxUINT32_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile">
            <summary>
            Matlab .mat file wrapper class
            </summary>
            <remarks>This class can read and write Matlab .mat files version 6! 
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported yet.</remarks>
        </member>
        <member name="F:ILNumerics.ILMatFile.ReservedKeywords">
            <summary>
            list of keywords which Matlab disallows for variable names
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.sizeOf(ILNumerics.MatFileType)">
            <summary>
            size of single elements stored in Matlab's *.mat files
            </summary>
            <param name="type">one of Matlab's inner element types</param>
            <returns>size in bytes </returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.typeToString(ILNumerics.MatFileType)">
            <summary>
            Convert MatFileType enumeration member to string representation
            </summary>
            <param name="type">MatFileType enumeration member</param>
            <returns>String representing the Matlab's inner element type</returns>
            <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.Add(ILNumerics.ILBaseArray)">
            <summary>
            add array to collection of arrays in this ILMatFile container
            </summary>
            <param name="A">array to be added to ILMatFile</param>
            <returns>string used to identify the array in the collection of arrays</returns>
            <remarks><para>The internal <code>Name</code> property of array given will be used as identification key.</para>
            <para>Note, the test if elements of A are supported by MatFile specification is done if the MatFile is to be written to stream ('write').</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException"> if the internal name of A does not fullfill the restrictions given by Matlab.</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(System.String,System.String[])">
            <summary>
            create MatFile object from existing mat file 
            </summary>
            <param name="file2open">path to Matlab mat file to open</param>
            <param name="vars2load">variables to load from file: leave empty to load them all</param>
            <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create MatFile object from ILBaseArray
            </summary>
            <param name="input">ILBaseArray of arbitrary size/type</param>
            <exception cref="T:System.ArgumentNullException"> if input array was null or one of the names in the input arrays does not fullfill the restrictions made from Matlab</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor">
            <summary>
            create empty MatFile object
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.IO.Stream)">
            <summary>
            Write this mat file into (binary) stream
            </summary>
            <param name="stream">stream to receive data. This will commonly be a FileStream object.</param>
            <remarks>
            <example><code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code></example></remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.read_miMATRIX(System.IO.BinaryReader,System.String[])">
            <summary>
            read ONE array (arbitrary dimensions/type) from MAT file 
            </summary>
            <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
            <returns>ILBaseArray of size and type originally stored into the mat file. Null if not loading this variable.</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.MatFileType,System.Array@,System.Int32@,System.Int32)">
            <summary>
            read array of supported matlab data types 
            </summary>
            <param name="br">binary reader, opened and correctly positioned</param>
            <param name="storageType">actual storage type</param>
            <param name="realData">output: on return, the array read</param>
            <param name="len">input: number of bytes to read, on return: number of elements in array</param>
            <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
        </member>
        <member name="M:ILNumerics.ILMatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
            <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            </summary>
            <param name="arrName">name property</param>
            <param name="type">will be 'miINT8' on return</param>
            <param name="data">return data array </param>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementClass(ILNumerics.ILBaseArray)">
            <summary>
            get mat file array class type corresponding to this arra element type
            </summary>
            <param name="arr">arra with generic system type or complex/fcomplex</param>
            <returns>mat file array class type code (int value)</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementLength(ILNumerics.ILBaseArray)">
            <summary>
            get storage length of inner array elements 
            </summary>
            <param name="arr">base array in question</param>
            <returns>storage length in bytes</returns>
        </member>
        <member name="P:ILNumerics.ILMatFile.Filelocation">
            <summary>
            Path to mat file, if this object was created from an existing mat file.
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Arrays">
            <summary>
            Arrays stored in this mat file
            </summary>
            <remarks>If the mat file was created from an existing ILBaseArray[] 
            array, the property gives access to the stored arrays directly! 
            This means one operates directly on the data and not on a copy!</remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Keys">
            <summary>
            list all key names currently stored with arrays 
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Item(System.String)">
            <summary>
            Get or set arrays to the MatFile array container
            </summary>
            <param name="name">the name of the array to display in Matlab</param>
            <returns>The array currently stored in the MatFile container.</returns>
            <remarks><para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
            <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.ILMatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current array will be removed from the list. If the name does 
            not already exist, the new array will be added and assigned to this name.</para>
            <para>Restrictions on array names: Matlab allowes variables to have names of maximum length 63. Therefore, if the 
            name given was larger than 63, it will be abbreviated. Names must start with a letter and contain only digits, (ASCII) letters or underscores '_'.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the name does not fullfill the restrictions given from Matlab</exception>
        </member>
        <member name="T:ILNumerics.ILCell">
            <summary>
            ILCell : container base class holding arbitrary ILBaseArray objects 
            </summary>
            <remarks>
            ILCell is derived from <![CDATA[ILArray<ILBaseArray>]]>. Therefore any 
            ILBaseArray may be used as inner element type. No further constraints are made 
            for the elements. All array types used inside ILNumerics.Net (e.g.<![CDATA[ILArray<BaseT>]]>) 
            inherit from ILBaseArray.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.ILBaseArray[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.ILArray{ILNumerics.ILBaseArray})">
            <summary>
            constructor creating ILCell from base type
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(System.Int32[])">
            <summary>
            Create empty cell object 
            </summary>
            <param name="size">dimensions. This may be a comma separeted list
            or a int array holding dimension lengths.</param>
        </member>
        <member name="M:ILNumerics.ILCell.DeepReferenceElements">
            <summary>
            walk through all elements of this ILCell and replace them with references to their original
            </summary>
            <returns>this object having alle elements "referenced"</returns>
            <remarks>This may be seen as a deep reference (in distinction to deep copy). Elements 
            of type ILCell will recursevely get changed into references. </remarks>
        </member>
        <member name="P:ILNumerics.ILCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.Int32[])">
            <summary>
            get/set/remove single element 
            </summary>
            The type of access depends on the length of indices. 
            <paramref name="indices" value="index to element"/>
            <value>inner element, new inner element or null</value>
            <remarks>If indices contains only one element, the array will be accessed via sequential index access. 
            This is sometimes called "linear" index access also. Sequential index access reflects the index of internal storage 
            the way the data are actually organized in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example><code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A[2] gives: 3.0
            </code>But the transpose 
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = new  ILArray&lt;double&gt;(1.0,12.0);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>For get access the array returned will be a reference to the element addressed.</para>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;BaseT&gt; the array returned will be a reference to the original array (same type and size).</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original element stored.</item>
            <item>for other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to elements of elements of this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vector(10,200); 
            innerCell[1] = ILArray&lt;int&gt;(-10,-20,-30);
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new ILArray&lt;string&gt;("foobla"); 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para>
            <para>For set access the element <code>value</code> will directly be stored in the ILCell. No copy/reference will be done for it!</para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">address range</param>
            <returns>reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore an empty array 
            (of the same type) or null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than null for this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[null,2] = null;  // &gt;- will remove the third column (index '2') from the cell.
            C[null,ILMath.vector(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not null! 
            </code></example></para>
            <para>In case of removal the object will be changed into a reference array having the only removal dimension decreased.</para>
            <para>The general behaviors of this acces methods are compatible with corresponding Matlab access: a(:) = []. </para>
            <para></para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.String[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">address range. String array with each element holding a comma seperated list of indices for each dimension. </param>
            <returns>reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks><para>The colon ':' is used, to identify the whole dimension. If used, the colon must be the only char in the dimension string.</para>
            <para><c>indices</c> may be a single string having dimension strings seperated by semicolon ';'</para>
            Query access: for N-dimensional cell arrays missing trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contain index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore an empty array 
            (of the same type) or null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than ":" for this case. If <c>indices</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":;2"] = null;  // &gt;- will remove the third column (index '2') from the cell.
            C[":;2,5"] = null;  &gt;- will remove columns 3...6
            C["1;1"] = null; &gt;- will produce an error. Only one dimension can be specified not null! 
            </code></example></para>
            <para>In case of removal the object will be changed into a reference array having the only removal dimension decreased.</para>
            <para>The general behaviors of this access methods are compatible with corresponding Matlab access: a(:) = []. </para>
            <para></para></remarks>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort">
            <summary>
            Bucket sort algorithm (for internal use)
            </summary>
            <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILNumerics.BuiltInFunctions.ILMath.sort(ILNumerics.ILArray{System.Double})"/></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILBucketSort.BucketSort``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Algorithms.ILKeyMapper{``0,``1},ILNumerics.Algorithms.ILBucketSort.SortMethod)">
            <summary>
            Bucket sort algorithm 
            </summary>
            <param name="input"></param>
            <param name="indices">return corresponding source element indices</param>
            <param name="mapper"></param>
            <param name="method"></param>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort.SortMethod">
            <summary>
            sort method for bucket sorts
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.ConstantLength">
            <summary>
            constant length
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.VariableLenth">
            <summary>
            variable length
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.LDA">
            <summary>
            linear discriminant analysis
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.#ctor">
            <summary>
            create new LDA algorithm
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.TrainLDA(ILNumerics.ILArray{System.Double},ILNumerics.ILLogicalArray)">
            <summary>
            train the LDA 
            </summary>
            <param name="X">data</param>
            <param name="Labels">labels</param>
            <returns>linear hyperplane wich best discriminates both classes</returns>
            <remarks> gamma will be set to 0.0</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.LDA.TrainLDA(ILNumerics.ILArray{System.Double},ILNumerics.ILLogicalArray,System.Double)">
            <summary>
            linear discriminant analysis 
            </summary>
            <param name="X">data matrix. Must be of size d x n, having samples arranged in columns </param>
            <param name="Labels">class labels for <paramref name="X"/>. </param>
            <param name="gamma">RLDA regularization parameter, with values between 0 and 1. 
            GAMMA=0 gives normal LDA, GAMMA=1 uses a multiple of the identity matrix instead 
            of the pooled covariance matrix.</param>
            <returns>cell array with discriminant hyperplane description</returns>
            <remarks><para><c>Labels</c> can be a vector of length n, having positive/negative values at indices 
            corresponding to data X. Alternatively it is a 2 row matrix of length n with 1's in the first row at positions 
            of data in the dirst class and 1's in the second row labeling the data in the second class.</para>
            <para>References: <list><item>J.H. Friedman, Regularized Discriminant Analysis, Journal
            of the Americal Statistical Association, vol.84(405), 1989. The method implemented here 
            is Friedman's method with LAMDBA==1. </item>
            <item>The algorithm is base on implementation of Fraunhofer FIRST.IDA (2004)</item></list></para></remarks>    
        </member>
        <member name="T:ILNumerics.Algorithms.LDA.Hyperplane">
            <summary>
            defines hyperplane c by the formula: c = wx + b
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.LDA.Hyperplane.w">
            <summary>
            hyperplane vector
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.LDA.Hyperplane.b">
            <summary>
            offset for hyperplane
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLParameter">
            <summary>
            MKL configuration parameters (constant definitions)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLValues">
            <summary>
            MKL configuration values (constant definitions) 
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLImports">
            <summary>
            import functions (pinvoke)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILMKLFFT">
            <summary>
            Wrapper for FFT interface using MKL 10_03
            </summary>
        </member>
        <member name="T:ILNumerics.Native.IILFFT">
            <summary>
            Interface for all FFT methods supported
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimensions to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FreePlans">
            <summary>
            Clear all currently cached plans
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAlgorithmEventArgs">
            <summary>
            Information arguments for events to be fired from within ILAlgorithms
            </summary>
            <remarks>ILAlgorithmEventArgs carry some additional parameter to inform 
            clients of ILAlgorithms in case of state changes. </remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Progress">
            <summary>
            current progess state. This number is in the range 0 ... 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Message">
            <summary>
            A textual message associated with the current event
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.State">
            <summary>
            The state of the ILAlgorithm. This is a constant out of the enum ILAlgorithmRunningStates
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Cancel">
            <summary>
            Cancel the excecution of the sender of the event. 
            </summary>
            <remarks>If set to true, the sender (a ILAlgorith) will cancel and return from excecution.</remarks>
        </member>
        <member name="F:ILNumerics.Algorithms.ILAlgorithmEventArgs.Parameter">
            <summary>
            Additional user defined data to be transferred to event registrar
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithmEventArgs.#ctor(System.Double,System.String,ILNumerics.ILAlgorithmState)">
            <summary>
            Construct a new ILAlgorithmEventArgs object for delivery
            </summary>
            <param name="progress">Current progress</param>
            <param name="message">A message to be included for the receiver of the event.</param>
            <param name="state">The state of the algorithm. Must be one out of the enum <typeparamref name="ILAlgorithmRunningState"/></param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAlgorithmEventArgs.#ctor(System.Double,System.String,ILNumerics.ILAlgorithmState,System.Object)">
            <summary>
            Construct a new ILAlgorithmEventArgs object for delivery
            </summary>
            <param name="progress">Current progress</param>
            <param name="message">A message to be included for the receiver of the event.</param>
            <param name="parameter">Additional user defined data to be transferred to event registrar</param>
            <param name="state">The state of the algorithm. Must be one out of the enum <typeparamref name="ILAlgorithmRunningState"/></param>
        </member>
        <member name="T:ILNumerics.Untyped.ILUntype">
            <summary>
            Max - experimental implementation
            </summary>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.repmat``1(ILNumerics.ILArray{``0},System.Object,System.Object[])">
            <summary>
            array replication _ : TODO : implement correctly! 
            </summary>
            <param name="X">input array to be replicated</param>
            <param name="rows">number of rows</param>
            <param name="sizeEx">number of columns and higher dimensions</param>
            <returns>reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.mean(ILNumerics.ILBaseArray[],ILNumerics.ILBaseArray[])">
            <summary>
            mean of array A
            </summary>
            <param name="inParameters">variable input parameter of type ILBaseArray. 
            <list type="bullet">
            <item> mean(A), where A is an ILArray of type supported, will give the 
            mean along the first non singleton dimension.</item>
            <item> mean (A, D) where A is a N-D array of type 
            supported and D is s single scalar sized ILArray of type double or int: returnes 
            mean of elements of A along dimension dim.</item>
            </list></param>
            <param name="outParameters"> Output. Depending on the 
            length of A and on the type of its elements the output return value will be a single 
            ILBaseArray with mean of elements along dimension specified 
            or along first non singleton dimension. The type of the single ILArray 
            returned will be the same as the underlying type of A.</param>
            <remarks> This function is supported for all numeric arrays: /*!HC:ENUM:inCls1:*/ <![CDATA[ ILArray<complex>, ILArray<byte>]]> /*!HC:/ENUM*/. 
            It does return a <![CDATA[ILArray<BaseT>]]> for all input arrays, where BaseT is the inner
            type of the input array.
            </remarks>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.max(ILNumerics.ILBaseArray[]@,ILNumerics.ILBaseArray[])">
            <summary>
            maximum
            </summary>
            <param name="inParameter"> system.Array of ILBaseArray's. The number of elements 
            in inParams specifies the mode of max: 
            <list type="bullet">
            <item> 1:  Single array element. the function will give the maximum of elements 
            along the first non singleton dimension. If the length of outParamter is 2, the
            indices of the elements with maximum values found is given back as second return 
            value. [Matlab: [i,y] = max(A)]</item>
            <item> 2: first element: input Array. Second element: second input array. Either 
            one may be a scalar. the function gives back the maximum value of corresponding 
            elements of both input arrays as single otuput parameter. [Matlab: y = max(A,B)]</item>
            <item> 3: first element: input array. second element will be ignored, third element 
            will specify the dimension to operate along. If the length of outParameter specified 
            is 2, the indices of maximum elements into the operation dimension will be given back 
            also. [MAtlab: [y,i] = max(A,[],d)]</item>
            </list>  
            </param>
            <param name="outParameter">[output] return maximum value as requested. If the number of outParameter
            equals 2 on entry, the indices of corresponding maximum valued elements are returned also.</param>
            <remarks>Following types are supported: /*!HC:ENUM:TinCls:*/ <![CDATA[ ILArray<complex>, ILArray<byte>]]> /*!HC:/ENUM*/.
            The dimension specifier may be any positive (including 0) scalar value inside ILArray 
            of type double or int or float. 
            The length of outParameter specifies the number of values returned. 
            The initial content of outParameter argument will be destroyed on return. </remarks>
        </member>
        <member name="M:ILNumerics.Untyped.ILUntype.min(ILNumerics.ILBaseArray[]@,ILNumerics.ILBaseArray[])">
            <summary>
            maximum
            </summary>
            <param name="inParameter"> system.Array of ILBaseArray's. The number of elements 
            in inParams specifies the mode of min: 
            <list type="bullet">
            <item> 1:  Single array element. the function will give the maximum of elements 
            along the first non singleton dimension. If the length of outParamter is 2, the
            indices of the elements with maximum values found is given back as second return 
            value. [Matlab: [i,y] = min(A)]</item>
            <item> 2: first element: input Array. Second element: second input array. Either 
            one may be a scalar. the function gives back the maximum value of corresponding 
            elements of both input arrays as single otuput parameter. [Matlab: y = min(A,B)]</item>
            <item> 3: first element: input array. second element will be ignored, third element 
            will specify the dimension to operate along. If the length of outParameter specified 
            is 2, the indices of maximum elements into the operation dimension will be given back 
            also. [MAtlab: [y,i] = min(A,[],d)]</item>
            </list>  
            </param>
            <param name="outParameter">[output] return maximum value as requested. If the number of outParameter
            equals 2 on entry, the indices of corresponding maximum valued elements are returned also.</param>
            <remarks>Following types are supported: /*!HC:ENUM:TinCls:*/ <![CDATA[ ILArray<complex>, ILArray<byte>]]> /*!HC:/ENUM*/.
            The dimension specifier may be any positive (including 0) scalar value inside ILArray 
            of type double or int or float. 
            The length of outParameter specifies the number of values returned. 
            The initial content of outParameter argument will be destroyed on return. </remarks>
        </member>
        <member name="T:ILNumerics.MachineParameterSingle">
            <summary>
            Extensive numerical machine parameter infos - single precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ibeta">
            <summary>
            radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.it">
            <summary>
            number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.irnd">
            <summary>
            rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>under-/ overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ngrd">
            <summary>
            number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.machep">
            <summary>
            exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.negep">
            <summary>
            exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.iexp">
            <summary>
            number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.minexp">
            <summary>
            smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.maxexp">
            <summary>
            smalles power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.eps">
            <summary>
            distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.epsneg">
            <summary>
            alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmin">
            <summary>
            smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmax">
            <summary>
            largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterDouble">
            <summary>
            Extensive numerical machine parameter infos - double precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ibeta">
            <summary>
            radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.it">
            <summary>
            number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.irnd">
            <summary>
            rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>under-/ overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ngrd">
            <summary>
            number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.machep">
            <summary>
            exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.negep">
            <summary>
            exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.iexp">
            <summary>
            number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.minexp">
            <summary>
            smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.maxexp">
            <summary>
            smalles power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.eps">
            <summary>
            distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.epsneg">
            <summary>
            alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmin">
            <summary>
            smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmax">
            <summary>
            largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.Data.ILProrityQueue`1">
            <summary>
            experimental performant priority queue implementation (WORK IN PROGRESS!)
            </summary>
            <typeparam name="T">inner type for elements (arbitrary)</typeparam>
        </member>
        <member name="M:ILNumerics.Data.ILProrityQueue`1.Add(`0)">
            <summary>
            add an element to the queue
            </summary>
            <param name="element"></param>
        </member>
        <member name="T:ILNumerics.Algorithms.ILKeyMapper`2">
            <summary>
            key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            </summary>
            <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
            <typeparam name="SubelementType">Type of subelements</typeparam>
            <remarks>This class can be overriden to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list>
            <item>colors: number/type of subelements: 1/any (f.e. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item>
            <item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item>
            <item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item>
            <item>...</item></list></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`1)">
            <summary>
            maps subelement types to bucket index
            </summary>
            <param name="inSubelement">item</param>
            <returns>bucket index</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`0,System.Int32,System.Int32)">
            <summary>
            map subelemt - provide fallback on error
            </summary>
            <param name="element">element item</param>
            <param name="position">position of subelement in element item to be mapped</param>
            <param name="fallback">if position is out of range, give back fallback</param>
            <returns>mapped bucket for subelement or fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.SubelementsCount(`0)">
            <summary>
            count subelements in an element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.GetSubelement(`0,System.Int32)">
            <summary>
            get subelement from element item
            </summary>
            <param name="element">element item</param>
            <param name="idx">position of subitem in element</param>
            <returns>subitem referenced</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.#ctor(System.Int32)">
            <summary>
            construct key mapper
            </summary>
            <param name="NumberOfKeys">maximm number of different subitems (keys)</param>
        </member>
        <member name="P:ILNumerics.Algorithms.ILKeyMapper`2.NumberOfKeys">
            <summary>
            maximum number of keys (different subitems)
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILASCIIKeyMapper">
            <summary>
            Concrete implementation of a key mapper for strings
            </summary>
            <remarks>this class is the default key mapper, used for bucket sort on strings</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.Char)">
            <summary>
            map subelement to bucket 
            </summary>
            <param name="inSubelement">subelement to be mapped</param>
            <returns>ASCII code of the subelement character</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
            <summary>
            Map char out of string with fallback
            </summary>
            <param name="element">full string item</param>
            <param name="position">position of character in string</param>
            <param name="fallback">fallback bucket number, if position is out of range</param>
            <returns>ASCII code for character specified, fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
            <summary>
            give one char from string
            </summary>
            <param name="element">full string item</param>
            <param name="idx">character position in string</param>
            <returns>character in string</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.SubelementsCount(System.String)">
            <summary>
            Count numer of characters in string
            </summary>
            <param name="element">element item</param>
            <returns>number of characters in string - length of string</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.#ctor">
            <summary>
            construct ASCII key mapper for 256 buckets
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILIntLimitedKeyMapper">
            <summary>
            Integer key mapper - sample implementation for bucket sort
            </summary>
            <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para>
            <para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
            <summary>
            Gives subelement - i.e. the element itself
            </summary>
            <param name="element">element</param>
            <param name="idx">(ignored)</param>
            <returns>element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
            <summary>
            map element - ignoring position &amp; fallback
            </summary>
            <param name="element">integer element</param>
            <param name="position">(ignored)</param>
            <param name="fallback">(ignored)</param>
            <returns>integer element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32)">
            <summary>
            map (copy) subelement
            </summary>
            <param name="inSubelement">subelement</param>
            <returns>subelement</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.SubelementsCount(System.Int32)">
            <summary>
            number of subelements in an element (Here: always 1)
            </summary>
            <param name="element">element</param>
            <returns>1</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.#ctor(System.Int32)">
            <summary>
            construct integer key mapper
            </summary>
            <param name="limit">maximum number of buckets to be used</param>
        </member>
        <member name="T:ILNumerics.Test.ILTest">
            <summary>
            Base test case class
            </summary>
            <remarks>This class serves as base class for all test classes for ILNumerics.Net. It is used as standalone and simple 
            test framework in order to make testing easy for non - microsoft systems (mono) also. </remarks>
        </member>
        <member name="F:ILNumerics.Test.ILTest.m_failed">
            <summary>
            internal counter for failed tests
            </summary>
        </member>
        <member name="F:ILNumerics.Test.ILTest.m_success">
            <summary>
            internal counter for succeeded tests
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Run">
            <summary>
            Start running the test
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Header">
            <summary>
            Print default header information to console. May be overwritten by derived classes
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.WriteMemoryPoolStats">
            <summary>
            write information about current state of ILMemoryPool
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Footer">
            <summary>
            Print default footer information. May be overwritten by derived classes. 
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Error(System.Int32,System.String)">
            <summary>
            handles printing of error informateion
            </summary>
            <param name="code">error code at time the test failed. This value depends only on the specifi test function implementation.</param>
            <param name="msg">Descriptive error message.</param>
            <remarks><para>The function will prepend the name of the function and stack trace information to the message</para>
            <para>A garbage collector run is initialized. </para></remarks>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Error(System.String)">
            <summary>
            print simple error information
            </summary>
            <param name="message">simple descriptive message </param>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Success(System.String)">
            <summary>
            print succes information to console
            </summary>
            <param name="message">descripive information message</param>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Success">
            <summary>
            print simple success information to console
            </summary>
        </member>
        <member name="M:ILNumerics.Test.ILTest.GetMethodName">
            <summary>
            query the name of the calling method for output
            </summary>
            <returns>name of the function this call came from</returns>
        </member>
        <member name="M:ILNumerics.Test.ILTest.Info(System.String)">
            <summary>
            outputs informational message
            </summary>
            <param name="message">message</param>
        </member>
        <member name="T:ILNumerics.Misc.ILMemoryPool">
            <summary>
            Memory pool serving as temporary storage for System.Array objects
            </summary>
            <remarks>The pool reduces the pressure on the systems memory done by larger objects.
            <para>Arrays created in ILNumerics.Net will try to reclaim its memory from this pool. If attempt fails, the memory is gathered from the managed heap normally.</para>
            <para>Disposed array objects register their underlying System.Array in the pool for later reusing. The process is triggered by the garbage collector or by the user calling the Dispose function available for all ILArray objects.</para></remarks>
        </member>
        <member name="F:ILNumerics.Misc.ILMemoryPool.Pool">
            <summary>
            The only global ILMemoryPool instance
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinArrayLength">Minimum length for array object to be stored inside the pool</param>
            <param name="PoolSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.DisposeContent">
            <summary>
            Dispose all object currently hold in the pool 
            </summary>
            <remarks>The pool get cleared and continues working with the same parameters after the call has finished. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.RegisterObject``1(``0[])">
            <summary>
            Register an array object of value type in the pool
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="arr">value type array</param>
            <remarks><para>In order to be stored in the pool, the array must meet the minimum array length and must fit into the global pool size.
            Null objects or empty arrays or array not suitable for the pool will be silently ignored.</para>
            <para>If the new array is too large to fit into the remaining pool space, the oldest objects in the pool will be released until the object can get registered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32)">
            <summary>
            Request a System.Array instance
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>There is no way of determining, if the array was recalimed from pool or newly created! If you must be sure, the element values are set to default(T), call the overloaded version <see cref="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32,System.Boolean,System.Boolean@)"/> instead!</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection is triggered and the array is again requested from the pool. If this failes again, another attempt to create the array is done. Exceptions may thrown from this last attempt are not catched and transported back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.New``1(System.Int32,System.Boolean,System.Boolean@)">
            <summary>
            Request a System.Array instance and optionally clear the array
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <param name="clear">if true, the elements of the array returned are set to default(T).</param>
            <param name="iscleared">out paramater determining if the array returned has been cleared</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>If the <paramref name="clear">clear </paramref> parameter was set to false, the <paramref name="iscleared">iscleared</paramref> parameter can be used to determine, if the object was returnd from the pool and may need extra clearing.</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection is triggered and the array is again requested from the pool. If this failes again, another attempt to create the array is done. Exceptions eventually thrown from this last attempt are not catched and transported back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean,System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <param name="reset">true: reset internal counter for reclaimed objects/ - bytes</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info">
            <summary>
            Give extended infos about pool state
            </summary>
            <returns>Full info about current and reclaimed pool objects</returns>
            <remarks>For short version infos use the overloaded version <see cref="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean)"/></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Info(System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Collect(System.Int32)">
            <summary>
            Collect all pending objects waiting for garbage cleaning and finalization
            </summary>
            <param name="generations">collect objects of given generations number only</param>
            <remarks>This function will return, if a garbage collector run and all subsequent finalizers has been completed.
            <para>After the function returns, all pending <code>ILArray</code>s not referenced from anywhere will have been placed 
            into the pool for reusement.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPool.Collect">
            <summary>
            Collect all pending objects waiting for garbage cleaning and finalization
            </summary>
            <remarks>This function will return, if a garbage collector run and all subsequent 
            finalizers has been completed.
            <para>After the function returns, all pending <code>ILArray</code>s 
            not referenced from anywhere will have been placed 
            into the pool for reusement. Therefore this function should only be called, 
            in order to prepare the pool directly <b>before</b> requesting large amounts of memory. 
            </para></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPool.ReclaimedBytesCount">
            <summary>
            Number of reclaimed bytes since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)"/></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPool.ReclaimedObjectsCount">
            <summary>
            Number of reclaimed objects since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="M:ILNumerics.Misc.ILMemoryPool.Reset(System.Int32,System.Int32)"/></remarks>
        </member>
        <member name="T:ILNumerics.Storage.ILIteratorPositions">
            <summary>
            Iterator positions, used for creating ILIterators and specifying initial 
            positions of the current element.
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILStart">
            <summary>
            position the iterator at the first element
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILEnd">
            <summary>
            position the iterator at the last element
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILIteratorPositions.ILMiddle">
            <summary>
            position the iterator at the middle element
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILIterator`1">
            <summary>
            High performance iterator for ILArray's 
            </summary>
            <remarks>This iterator is optimized for physical storages as well as 
            for reference storages. However, the iteration for reference storage 
            is (and will always be) couple of times slower than for physical storages.
            <para>This type is marked as <b>deprecated</b> and may be removed in a 
            future release. Use foreach constructs for read access and SetValue(seqIdx) for write 
            access instead. Those functions - however - may not reach the performance of the 
            iterator for write access in certain situations.</para>
            </remarks>
            <typeparam name="BaseT">the base type of the storage's instance.</typeparam>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.#ctor(`0[],ILNumerics.Misc.ILDimension)">
            <summary>
            create ILIterator - this is not for public use! Use <see cref="M:ILNumerics.ILArray`1.CreateIterator"/> instead!
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.#ctor(`0[],ILNumerics.Misc.ILDimension,ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            create ILIterator - this is not for public use! Use <see cref="M:ILNumerics.ILArray`1.CreateIterator"/> instead!
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
            <param name="startPos">enumeration value where to set the initial element position </param>
            <param name="leadingDimension">the dimension, the iterator is going to walk along</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.commonConstruct(`0[],ILNumerics.Misc.ILDimension,ILNumerics.Storage.ILIteratorPositions,System.Int32)">
            <summary>
            this helper function is used from all constructors
            </summary>
            <param name="data">storage of source array</param>
            <param name="indexOffset">ILIndexOffset mapping for reference arrays</param>
            <param name="dimensions">Dimension specification</param>
            <param name="startPos">enumeration value where to set the initial element position </param>
            <param name="leadingDimension">the dimension, the iterator is going to walk along</param>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.IsAtEnd">
            <summary>
            determine, if the current element is the last element
            </summary>
            <returns>true if the current element is the last element in the array, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.IsAtStart">
            <summary>
            determine, if the current element is the first element
            </summary>
            <returns>true if the current element is the first element in the array, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILIterator`1.Increment">
            <summary>
            increment to next position and return value at new position
            </summary>
            <returns>Value of element at new position</returns>
        </member>
        <member name="P:ILNumerics.Storage.ILIterator`1.IsReadonly">
            <summary>
            readonly state of the storage attached to this iterator
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILIterator`1.Value">
            <summary>
            get/set value at current position
            </summary>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException">if the storage was readonly, while 
            attempting to alter elements</exception>
        </member>
        <member name="T:ILNumerics.ILDetachingBehavior">
            <summary>
            Switches to set the detaching behavior for referencing storages. 
            </summary>
            <remarks>
            Special attention is to be made for altering ranges on reference storages. There are 
            cases where setting a value may alter other elements as well. This is true
            for elements "pointing" to the same physical array elements. If you dont want 
            this behavior, set this switch to 'DetachAlways' so you wont have to worry about 
            storages beeing references anymore. This behavior may be known as similar 
            to other mathematical engines (like Matlab f.e.).
            
            The default switch is 'DetachOnWrite'.</remarks>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachNever">
            <summary>
            if used, ILArray's will never automatically detach. This can 
            lead to situations, where altering the elements of one array also change 
            the elements of another array, if the second is referencing the same solid
            array elements. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachOnWrite">
            <summary>
            (default) - Referencing arrays will automatically detach 
            themself before attempting to alter any values used. The results are self 
            dereferencing arrays which act to the outside world, like they would 
            all consist out of solid storages, but internally save memory by not creating 
            any real copies of arrays as long as it is not absolutely neccessary.
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachAlways">
            <summary>
            Attempts to create a reference of an existing array will result 
            in copying the values. This is the way other (native) mathematical engines usually handle 
            their storages. It consumes more memory, but will sometimes 
            lead to increased performance for large computations, since physical storages
            are optimized for faster element access.
            </summary>
        </member>
        <member name="F:ILNumerics.ILDetachingBehavior.DetachSave">
            <summary>
            This value acts like 'DetachOnWrite' except a storage will not 
            be detached, if it is the only reference to the underlying physical storage.
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayStreamSerializationFlags">
            <summary>
            Defines the way ILArrays are serialized to stream. Used by function ToStream. 
            </summary>
            <seealso cref="M:ILNumerics.ILArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)"/>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Serial">
            <summary>
            print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Formatted">
            <summary>
            print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. ILArray's are capable of constructing from streams containing this type of 
            output. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Matlab">
            <summary>
            export whole array instance to matlab 5.0 format
            </summary>
        </member>
        <member name="T:ILNumerics.FFTModes">
            <summary>
            [deprecated]
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT3DReal">
            <summary>
            3-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT3DComplex">
            <summary>
            3-dim fft, complex input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT2DReal">
            <summary>
            2-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT2DComplex">
            <summary>
            2-dim fft, complex input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT1DReal">
            <summary>
            1-dim fft, real input
            </summary>
        </member>
        <member name="F:ILNumerics.FFTModes.FFT1DComplex">
            <summary>
            1-dim fft, complex input
            </summary>
        </member>
        <member name="T:ILNumerics.MatrixProperties">
            <summary>
            possible properties for matrices 
            </summary>
            <remarks><para>These properties may be returned by function overloads receiving a MatrixProperties parameter by reference. The properties must be checked inside the function, the result is returned also.</para>
            <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para></remarks>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hermitian">
            <summary>
            hermitian matrix 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
            <summary>
            positive definite
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
            <summary>
            upper triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
            <summary>
            lower triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Square">
            <summary>
            square matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Diagonal">
            <summary>
            diagonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Singular">
            <summary>
            the matrix is singular 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hessenberg">
            <summary>
            hessenberg matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Householder">
            <summary>
            householder matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unitary">
            <summary>
            unitary matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthogonal">
            <summary>
            orthogonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthonormal">
            <summary>
            orthonormal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.RankDeficient">
            <summary>
            the matrix has deficient rank
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.None">
            <summary>
            the matrix has no special properties
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unknown">
            <summary>
            no specific properties known (default)
            </summary>
        </member>
        <member name="T:ILNumerics.ILAlgorithmState">
            <summary>
            Possible states for <see cref="T:ILNumerics.Algorithms.ILAsyncAlgorithm"/>
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Initialized">
            <summary>
            The algorithm was newly created
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Running">
            <summary>
            the algorithm is running normally 
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Suspended">
            <summary>
            the algorithm was temporarily suspended
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Finished">
            <summary>
            the algorithm finished successfully
            </summary>
        </member>
        <member name="F:ILNumerics.ILAlgorithmState.Canceled">
            <summary>
            the algorithm was cancelled
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILACMLFFT">
            <summary>
            Wrapper for FFT interface using ACML ver. 3.6
            </summary>
        </member>
        <member name="T:ILNumerics.ILLogicalArray">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[<byte>]]> and an ILLogicalArray is, the ILLogicalArray 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="F:ILNumerics.ILLogicalArray.m_numberNonZero">
            <summary>
            internal field, caches the number of 'true' elements
            </summary>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Int32[])">
            <summary>
            constructor - create ILLogicalArray of type <code>Byte</code> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <code>bool</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(ILNumerics.ILArray{System.Byte})">
            <summary>
            Constructor creating ILLogicalArray from <![CDATA[ILArray<byte>]]>
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogicalArray</param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Constructor creating ILLogicalArray from <![CDATA[ILArray<byte>]]>
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogicalArray</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create ILLogicalArray of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILLogicalArray of the specified size 
            will be created. The type of storage will be <code>byte</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],ILNumerics.Misc.ILDimension)">
            <summary>
            Constructor creating ILLogicalArray, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor(System.Byte[],ILNumerics.Misc.ILDimension,System.Int32)">
            <summary>
            Constructor creating ILLogicalArray, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.sumElements">
            <summary>
             sum all elements of this storage. 
            </summary>
            <returns>Number of non zero elements</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.#ctor">
            <summary>
            Standard constructor creating empty ILArray
            </summary>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Concat(ILNumerics.ILArray{System.Byte},System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="inArray">N-dimensional storage. Except for dimensions leadDim 
            the dimensions must match the dimensions of this storage.</param>
            <param name="leadDim">index of dimension to concatenate arrays along.
            If leadDim is larger than the number of dimensions of any of the arrays
            its value will be used in modulus</param>
            <returns>logical array having the size 
            of both input arrays layed behind each other along the leadDim's-dimension</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference storage, if inArray is the same as this array (object references 
            are the same) and ILArray.MinimumRefDimensions is less or equal 
            the number of dimensions of the resulting storage, or a 
            </item>
            <item>physical storage else. 
            </item></list>
            There are only very few cases where it is possible to reference two arrays in the 
            same reference storage. Not only the storages must point to the same underlying 
            physical System.Array, but the ILIndexOffset must be suited in a special way. 
            Therefore the restriction was made always to create a reference storage, if 
            both storages are not the same.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Repmat(System.Int32[])">
            <summary>
            Replicate this ILArray. Make large ILLogicalArray out of it.
            </summary>
            <param name="dims">dimensions specifier. This may be a comma sep.
            list or an array of integer values. If the number of elements in dim is 
            less the number of dimensions in this ILArray, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>large array beeing a multiple (dims) copy of this array along 
            arbitrary dimensions</returns>
            <remarks>The array returned will be a 
            <list type="bullet">
            <item> reference storage, if the number of dimensions resulting is more or equal 
            to ILArray.MinimumRefDimensions, or a 
            </item>
            <item>physical storage else. 
            </item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.Int32,ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this ILArray + dimension shift
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.Int32,System.String[])">
            <summary>
            Subarray to this array + dimension shift
            </summary>
            <param name="range"> string specifying the ranges to create subarray from</param>
            <param name="shift"> Number of dimensions to shift the result.</param>
            <returns>shifted subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Subarray(System.String[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> strings specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj
            </summary>
            <param name="obj">typed ILArray containing the values to compare this array with</param>
            <returns>true if all elements contained in obj are equal to the 
            elements of this array. False otherwise.</returns>
            <remarks> This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.GetHashCode">
            <summary>
            give the HashCode for this ILLogicalArray
            </summary>
            <returns>HashCode as given from base class</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Boolean)~ILNumerics.ILLogicalArray">
            <summary>
            Implicitly convert Byte scalar to ILLogicalArray of size 1x1 (scalar).
            </summary>
            <param name="val">Byte scalar</param>
            <returns>New ILLogicalArray of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Byte[])~ILNumerics.ILLogicalArray">
            <summary>
            Implicit cast System.Array of type byte[] to ILLogicalArray
            </summary>
            <param name="vector_elements">predefined elements values</param>
            <returns>new ILLogicalArray using the System.Array given as storage.</returns>
            <remarks><para>Since the System.Type 'byte' can address more then 2 values used by ILLogicalArray (i.e. '0' and '1'), 
            and the given array is directly be used as storage for the newly created array, undefined behavior can result, if 
            the System.Array given contains values other then 0 or 1. No check is made for this!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(ILNumerics.ILLogicalArray)~System.Boolean">
            <summary>
            Implicitly convert ILLogicalArray of size 1x1 to bool/byte (scalar).
            </summary>
            <param name="A">scalar ILLogicalArray</param>
            <returns>true if A is scalar array holding the only element '01', false otherwise 
            </returns>
            <remarks> if A is null, the function will always return false. If 'A' is empty or not scalar,
            an ILArgumentException will be thrown.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> if A is not scalar</exception>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_Implicit(System.Int32)~ILNumerics.ILLogicalArray">
            <summary>
            Implicitly convert integer scalar to ILLogicalArray of size 1x1 (scalar).
            </summary>
            <param name="val">scalar value</param>
            <returns>New ILLogicalArray of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.op_LogicalNot(ILNumerics.ILLogicalArray)">
            <summary>
            invert values of array elements 
            </summary>
            <param name="in1">input array</param>
            <returns>new solid ILLogicalArray, inverted element values</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Serialize(System.IO.Stream)">
            <summary>
            Serialize this ILLogicalArray into stream. 
            </summary>
            <param name="outStream">System.IO.Stream to receive/store this objects data</param>
            <returns>true on success, false on error.</returns>
            <remarks>Use this member to convert the data of this array 
            to persistant state. The storage will automatically determine the 
            state wich will consume less memory and detach itself accordingly. 
            </remarks>
            <example>
            <code>
            FileStream fs = new FileStream("filename", FileMode.Create);
            A.Serialize(fs); 
            fs.Close();
            </code></example>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize an ILLogicalArray from stream 
            </summary>
            <param name="inStream">strem to read from</param>
            <returns>ILLogicalArray deserialized from stream</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.GetShifted(System.Int32)">
            <summary>
            get reference to this array having the dimensions shifted by <c>shiftDimensions</c>.
            </summary>
            <param name="shiftDimensions">number of dimensions to shift this array (to the left for positive values)</param>
            <returns>Referencing ILArray of the same type and size with <c>shiftDimensions</c> dimensions shifted to the left.</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.ToString(System.String,System.Int32)">
            <summary>
            output information about this ILLogicalArray
            </summary>
            <param name="s">predefined string, to be used as prefix for output</param>
            <param name="maxLength">number of characters in lines of output</param>
            <returns>string representation of this ILLogicalArray</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.ToString">
            <summary>
            output information about this ILLogicalArray
            </summary>
            <returns>string representation of this ILLogicalArray</returns>
        </member>
        <member name="M:ILNumerics.ILLogicalArray.empty(ILNumerics.Misc.ILDimension)">
            <summary>
            [deprecated] create empty ILLogicalArray 
            </summary>
            <returns>empty ILLogicalArray.</returns>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.NumberTrues">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks> this value caches the number of 'true' elements in this ILLogicalArray. 
            It may be used for information purposes but is actually needed for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.String[])">
            <summary>
            Subarray access for ILArray. Get: Create referencing subarray, 
            Set: alter range of this ILArray with new value elements.
            </summary>
            <paramref name="dims" value="Range specification for subarray elements"/>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int16,System.String[])">
            <summary>
            Subarray access for ILArray and dimension shift
            </summary>
            <paramref name="dims" value="dimension specification"/>
            <value>returns new ILArray as reference subarray to this ILBaseArray</value>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(ILNumerics.ILBaseArray[])">
            <summary>
            subarray access
            </summary>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int16,ILNumerics.ILBaseArray[])">
            <summary>
            ranged subarray access
            </summary>
            <param name="shiftdim">number of dimensions to shift the result</param>
            <param name="range">range specification</param>
            <returns>reference pointing to the elements of this array specified by range. </returns>
            <remarks>For n-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range. However, if range contains only one array, those indices 
            are interpreted as sequential index access elements. I.e. the elements in the index vector are allowed to 
            range from 0...[NumberOfElements-1]. A vector containing corresponding elements will be returned for this case.
            <para>The indexer may be used for querying single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.Item(System.Int32[])">
            <summary>
            Single element access
            </summary>
            <param name="dims">dimensions specifier. int array or comma seperated list.
            If this is a single int element only, this will lead to sequential index access. 
            If dims consist out of at least 2 elements, trailing missing dimensions will be replaced by "0". </param>
            <returns>Scalar ILLogicalArray element pointed to by 'dims'</returns>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.T">
            <summary>
            shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILLogicalArray.C">
            <summary>
            create solid array as copy of this array 
            </summary>
        </member>
        <member name="T:ILNumerics.NumericType">
            <summary>
            Enumerate all numeric type names used by ILNumerics.Net
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Double">
            <summary>
            double element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Single">
            <summary>
            float element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Complex">
            <summary>
            complex element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.FComplex">
            <summary>
            fcomplex element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Byte">
            <summary>
            byte element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Char">
            <summary>
            char element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int16">
            <summary>
            Int16 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int32">
            <summary>
            Int32 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int64">
            <summary>
            Int64 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt16">
            <summary>
            unsigned UInt16 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt32">
            <summary>
            unsigned UInt32 element type
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.UInt64">
            <summary>
            unsigned UInt64 element type
            </summary>
        </member>
        <member name="T:ILNumerics.Untyped.ILMath">
            <summary>
            general math class. This is in an experimental state! 
            </summary>
        </member>
        <member name="M:ILNumerics.Untyped.ILMath.Find(ILNumerics.ILBaseArray[],ILNumerics.ILBaseArray[])">
            <summary>
            
            </summary>
            <param name="outValue">Array of BaseArray of output parameter. outValue must be 
            at least of lenght 1, at most of length 3. The meanings are: 
            <list type="bullet">
            <item>One parameter: the sequential indices of all nonzero elements of X are returned.</item>
            <item>Two parameter: The first BaseArray returned in 'outValue' will hold the row indices of 
            nonzero elements of X, the second BaseArray will hold the column indices of those nonzero elements.</item>
            <item>If Length of outValue is 3, the rows and columns of nonzero elements are returned as the 
            first and second BaseArray elements. The third array will hold a (shallow) copy of those 
            nonzero elements found.</item>
            </list>
            </param>
            <param name="X">Array of input parameter. This must be at least 1 BaseArray holding 
            the input array for evaluation. If this array has length of 2, the second element must 
            be a scalar array of type <![CDATA[ILArray<double> or ILArray<int> or ILArray<float> or ILArray<byte>]]> 
            specifying the integer number of values to be returned. If this value is smaller 0, Find will 
            return that number of nonzero elements of X from the end of X.</param>
            <remarks>In order to specify the mode of Find, the length of the arrays 'outValue' and 
            'X' will be recognized only. Any initial values of elements in 'outValue' will 
            be destroyed. The elements of X will not be altered.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sinc(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number og columns</param>
            <param name="periods">influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sinc(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number of columns</param>
            <returns>matrix with sinc data in 2 dimensions</returns>
            <remarks>the function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sincos1D(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data
            </summary>
            <param name="numSamples">number of samples</param>
            <param name="periods">number of (full) periods to be generated, must be &gt; 0</param>
            <returns>matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.waterfall(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">number of rows</param>
            <param name="cols">number of columns</param>
            <returns>matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.sphere(System.Int32,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Create surface data of a sphere
            </summary>
            <param name="n">number of facettes per angle</param>
            <param name="X">[output] X coords</param>
            <param name="Y">[output] Y coords</param>
            <param name="Z">[output] Z coords</param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILSpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@,ILNumerics.ILArray{System.Double}@)">
            <summary>
            Create surface data for a Möbius strip 
            </summary>
            <param name="n">granularity (number of facettes)</param>
            <param name="w">width</param>
            <param name="R">radius</param>
            <param name="X">[output] X coords</param>
            <param name="Y">[output] Y coords</param>
            <param name="Z">[output] Z coords</param>
            <remarks>Möbius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.</remarks>
        </member>
        <member name="T:ILNumerics.Misc.ILDimension">
            <summary>
            ILDimension - dimensions for ILArray objects (immutable)
            </summary>
            <remarks>The class internally manages the dimensions of ILArray. 
            The class is immutable. Therefore, once created, it informs the user 
            about all dimension related properties, but cannot get altered.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor">
            <summary>
             create new (0 x 0) ILDimension 
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor(System.Int32[])">
            <summary>
             create new ILDimension 
            </summary>
            <param name="dims">variable length dimensions specifier</param>
            <remarks>trailing singleton dimensions of dims will be kept.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.#ctor(System.Boolean,System.Int32[])">
            <summary>
            create new ILDimension, with or without trimming trailing singleton dimensions
            </summary>
            <param name="trimSingletons">true: trailing singleton 
            dimensions will be trimmed, false: those singleton dimensions will be kept.</param>
            <param name="dims">dimension length specifiers</param>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.FirstNonSingleton">
            <summary>
            find first non singleton dimension - if exist
            </summary>
            <returns>index of first non singleton dimension or -1, if this is a scalar.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.SequentialIndexDistance(System.Int32)">
            <summary>
            Marks the number of elements between adjacent elementes of 
            each dimension as if the underlying storage was a dense storage.
            </summary>
            <param name="dim">dimension number to query the element distance for. The
            first dimension has index 0 ('zero')!</param>
            <returns>number of elements between adjacent elementes of dimension dim.
            </returns>
            <remarks>if dimension index dim is larger than the number of 
            dimensions inside this ILDimension, the number of elements will 
            be returned (assuming the trailing dimensions to be 1).</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetSequentialIndexDistances(System.Int32)">
            <summary>
            distances between adjacent elements for all dimensions
            </summary>
            <param name="minLength">minimum length of array to be 
            returned. If this is larger than the number of dimensions 
            in this ILDimension, the array will have minLength elements, 
            with elements outside this dimensions repeating the value 
            of the last dimension. The length of the array returned will 
            equal min(minLength,NumberOfDimensions).</param>
            <remarks>This is provided for performance reasons and should be 
            used internally only. It enables developer of index access routines 
            to cache the elements distances directly inside their functions 
            without having to query the info on every index access.
            <para>Keep in mind, only the distances for the number of my 
            dimensions are returned. Higher dimensions must be set to 
            NumberOfElements if needed. This is different than querying 
            the distances by SequentialIndexDistance(int), which will assume 
            and return trailing dimensions to be 1.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToIntArray">
            <summary>
            transfer my dimensions to integer array 
            </summary>
            <returns>integer array containing a copy of dimensions length</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToIntArray(System.Int32)">
            <summary>
            transfer my dimensions to integer array 
            </summary>
            <param name="length">minimum length of output array. If length 
            is larger than my dimensions, trailing ones will be added.</param>
            <returns>integer array containing a copy of dimensions length. 
            Trailing elements outside my dims will be one.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Int32[])">
            <summary>
            Translate indices from int[] Array to sequential storage access 
            in my dimensions
            </summary>
            <param name="idx">int array of nrDims length</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Transform dimension position into sequential index, gather expand 
            information
            </summary>
            <param name="idx">int array of arbitrary length</param>
            <param name="MustExpand">[output] true, if the indices 
            given address an element outside of 
            this dimensions size. In this case, the output parameter 
            'Dimensions' carry the sizes 
            of new dimensions needed. False otherwise</param>
            <param name="Dimensions">sizes of dimension if expansion is needed</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
            <remarks>no checks are made for idx to fit inside dimensions! 
            This functions is used for left side assignments. Therefore it 
            computes the destination index also if it lays outside 
            the array bounds.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IndexFromArray(System.Int32[],System.Int32)">
            <summary>
            Unshift dimensions of indices from int[] Array 
            and translate to index for sequential storage access 
            in my dimensions </summary>
            <param name="idx">int array of the same length as 
            the number of dimensions of this storage. Indices must 
            lay within my dimensions.</param>
            <param name="unshift">number of dimensions to unshift 
            idx before computing index</param>
            <returns>Index number pointing to the value's position 
            in sequential storage.</returns>
            <remarks> If idx contains elements (indices) larger than 
            my dimension bounds, an exception will be thrown. If unshift 
            is 0, the length of idx may be smaller than the length of 
            my dimensions. However, with unshift &gt; 0 the result 
            is undefined.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Shift(System.Int32)">
            <summary>
            [deprecated] Shift this ILDimension
            </summary>
            <param name="shift">number of dimensions to shift.</param>
            <remarks>this will not alter this object anymore but return the shifted version!
            The function will be removed in a future release! Use 
            ILDimension.GetShiftedVersion() instead!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetShifted(System.Int32)">
            <summary>
            return shifted version
            </summary>
            <param name="shift">number of dimensions to shift. The value
            will be considered modules the number of dimensions of 
            this ILDimension.</param>
            <returns>shifted version of this ILDimension object.</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IsSameSize(ILNumerics.Misc.ILDimension)">
            <summary>
            Compares the size of this dimension to another dimension object. 
            </summary>
            <param name="dim2">ILDimension object to compare this to.</param>
            <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by recognizing singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
            <remarks>The function reutrns true, if the squeezed dimensions of 
            both ILDimensions match.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.IsSameShape(ILNumerics.Misc.ILDimension)">
            <summary>
            Compares the shape of this dimension to another dimension object 
            </summary>
            <param name="dim2">ILDimension object to compare this to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than IsSameSize. In order 
            for two dimensions to have the same shape, ALL dimensions must match - 
            even singleton dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.GetSqueezed">
            <summary>
            [deprecated] Create copy of this ILDimension having all singleton 
            dimensions removed.
            </summary>
            <returns>a squeezed copy</returns>
            <remarks>This function is deprecated. Use the ILDimension.Squeeze()
            memeber instead. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Squeeze">
            <summary>
            Create and return copy without singleton dimensions
            </summary>
            <returns>Copy of this ILDimension having all singleton dimensions removed.</returns>
            <remarks> This function does not alter this object (since ILDimension is 
            immutable).
            <para>All arrays in ILNumerics.Net have at least 2 dimensions. 
            Therefore all but the first two singleton dimensions can be removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.Trim">
            <summary>
            Return ILDimension having trailing singleton dimensions removed
            </summary>
            <returns>Copy without trailing singleton dimensions</returns>
            <remarks> this object will NOT be altered. As usual for all ILArrays, 
            the result wil have at least 2 dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILDimension.ToString">
            toString: prints out dimensions 
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NumberOfDimensions">
            <summary>Get number of dimensions.</summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NonSingletonDimensions">
            <summary>
            Number of non singleton dimensions this ILDimension is referencing
            </summary>
            <remarks>non singleton dimensions are dimensions which length is larger than 1. 
            Empty dimensions (length = 0) will not be take into account.</remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.NumberOfElements">
            <summary>
            The number of elements the dimensions reference in an array of that size
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.Longest">
            <summary>
            return longest dimension length
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILDimension.Item(System.Int32)">
            <summary>
            Get length for dimension specified (Readonly)
            </summary>
            <param name="idx">index of dimension</param>
            <returns>length of dimension specified by idx</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if idx is negative</exception>
            <remarks><para>for idx corresponds to an existing dimension, 
            the length of that dimension is returned. If idx is larger than 
            the number of dimensions 1 is returned. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Misc.ILPerformer">
            <summary>
            Measures time spans.
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILListItem`2">
            <summary>
            List items to be used in ILQueueList
            </summary>
            <typeparam name="T1">Data type</typeparam>
            <typeparam name="T2">Index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0)">
            <summary>
            construct list item by data
            </summary>
            <param name="item">item data</param>
            <remarks>the indet will be set to its default value</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0,`1)">
            <summary>
            construct list item, takes item data and - index
            </summary>
            <param name="item">item data</param>
            <param name="index">index</param>
        </member>
        <member name="P:ILNumerics.Misc.ILListItem`2.Index">
            <summary>
            index stored for/with this item
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILQueueList`2">
            <summary>
            Queuelist - queue with list properties also
            </summary>
            <typeparam name="T1">data type</typeparam>
            <typeparam name="T2">index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0,`1)">
            <summary>
            add indexed item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0)">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILListItem{`0,`1})">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            add queue list to end of this queue list
            </summary>
            <param name="list">queue list to be added</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Dequeue">
            <summary>
            Remove from start of queue
            </summary>
            <returns>item from start of queue</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(`0)">
            <summary>
            Add to start of queue
            </summary>
            <param name="item">item data to add to start of queue</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            concatenate 2 queuelists
            </summary>
            <param name="qlist">queue list to be added at start of this queuelist</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Sort``1(ILNumerics.Algorithms.ILKeyMapper{`0,``0})">
            <summary>
            sort utilizing bucket sort
            </summary>
            <typeparam name="SubelementType">subelement type</typeparam>
            <param name="mapper">keymapper mapping subelement items to buckets</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.ToArray">
            <summary>
            convert (copy) items to system array
            </summary>
            <returns>system array with items</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Clear">
            <summary>
            Clear this queue list from all elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.GetEnumerator">
            <summary>
            Create enumerator utilizing 'foreach'
            </summary>
            <returns>enumerator for contained elements</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            gives enumerator for internal list items (ILListItem)
            </summary>
            <returns>ILListItem's</returns>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.Count">
            <summary>
            number of items currentliy in the queue (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.ListItems">
            <summary>
            Gives enumerator for contained items (ILListItem)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILLapackMKL10_0">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Native.ILLapackGeneric">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGeneric.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Native.ILACML4_1">
            <summary>
            LAPACK implementation for AMD processors
            </summary>
            <remarks>By using this module, you will have to make sure,
            you placed all runtime binaries for AMD's performance library 
            into the binary output dir accessable for ILNumerics.Net assemblies. 
            Those modules must be donwloaded seperately, since it is not 
            permitted to distribute them among with LGPL code. However, 
            developing and redistributing of products with ACML is possible though. 
            AMD currently does not charge money for a redistributable 
            license, given that one signs a license agreement with AMD 
            individually.</remarks>
        </member>
        <member name="T:ILNumerics.Native.ILManagedFFT">
            <summary>
            C# implementation of IILFFT
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTBackward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTBackward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimensions to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTBackwSym(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTBackwSym1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTForward(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTForward(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTForward1D(ILNumerics.ILArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FFTForward1D(ILNumerics.ILArray{System.Double},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="alongDim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.ILManagedFFT.FreePlans">
            <summary>
            Clear all currently cached plans
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILManagedFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="P:ILNumerics.Native.ILManagedFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Exceptions.ILException">
            <summary>
            generic exception, base class for all exceptions thrown by ILNumerics.Net
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMathException">
            <summary>
            Base class for mathematical exceptions. Needed e.g. in interpreter for propoer error
            messages
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILDimensionMismatchException">
            <summary>
            One of the most common exceptions: The matrix sizes do not match
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentException">
            <summary>
            something was wrong with the arguments overgiven 
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentNumberException">
            <summary>
            a function was called with the wrong number of arguments
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentSizeException">
            <summary>
            a function argument has the wrong size
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentTypeException">
            <summary>
            a function was called with a wrong argument type
            </summary>
            <remarks>this exception might be thrown if the size or inner 
            type of a argument is invalid. (f.e. matrix expected, but 3D array found)
            </remarks>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMemoryException">
            <summary>
            a request could not be completed due to not enough memory available
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILCastException">
            <summary>
            Thrown on illigal casts 
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String)">
            <summary>
            Costructor
            </summary>
            <param name="message">aditional message to be included into the exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String,System.Exception)">
            <summary>
            Costructor
            </summary>
            <param name="message">aditional message to be included into the exception</param>
            <param name="innerException">on cascaded exception handling, the exception catched before</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILOutputException">
            <summary>
            ILOutputException, thrown if an I/O attempt fails
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidOperationException">
            <summary>
            Exception thrown if an operation could not completed
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">additional message to be included</param>
            <param name="innerException">inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILManagedLapackNotDoneException">
            <summary>
            Exception thrown if an unimplemented part of ILManagedLapack is called
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILManagedLapackNotDoneException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">LAPACK routine where error is found</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILManagedFFTNotDoneException">
            <summary>
            Exception thrown if an unimplemented part of ILManagedFFT is called
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILManagedFFTNotDoneException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">FFT routine where error is found</param>
        </member>
        <member name="T:ILNumerics.Storage.RangeSide">
            <summary>
            Helper class defining ranges for subarray access (internal use only)
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RangeSide.Right">
            <summary>
            Right side range for subarray creation. limited to dimension length 
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RangeSide.Left">
            <summary>
            left side range for assignment. may exeeds dimension length.
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILRange">
            <summary>
            ILRange specify the dimensions for an ILArray object if it is a reference.
            </summary>
            <description>ILRange is used to specify the parts of the original dimensions
            the ILArray objects referes to if it is a reference to another ILArray object. 
            ILRange objects do not know about a 'maximum size'. They dont know the dimensions of the objects,
            they get applied to. Therefore the 'colon' specifier will get stored and evaluated at the 
            time, the range gets assigned to an ILArray Object. </description>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_nrDims">
            <summary>
            number of dimensions defined by this range
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_regularSpaced">
            <summary>
            array defining, if the dimensions of this range are regulary spaced and which spacing the have
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_expanding">
            <summary>
            internal field, stores expanding flag
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_expandDimensions">
            <summary>
            internal field, stores sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_numberOfElements">
            <summary>
            internal field stores the number of elements addressed by this ILRange 
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_nonSingletonDimensions">
            <summary>
            internal field, caches the number of non singleton dimensions
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_range">
            <summary>
            hold ranges as a simple Array of int[] Arrays.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Storage.ILRange)">
            <summary>
            Copy Constructor
            </summary>
            <param name="oldRange">Create new instance from existing ILRange</param>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Misc.ILDimension,ILNumerics.Storage.RangeSide,ILNumerics.ILBaseArray[])">
            <summary>
            Construct ILRange from arrays of indices.
            </summary>
            <param name="ranges">Array of indices. Each element of ranges corresponds to
            one dimension for the new range. ranges must be vector or scalar arrays.</param>
            <param name="side">specifies if the range is intended for left side (assignment) 
            or ride side (subarray creation).</param>
            <param name="dimensions">dimension for destination array. Needed for limit information. </param>
            <remarks>the elements of ranges must either be scalar or vectors (row- or column doesn't matter) or 'null'. Elements 
            inside the ILBaseArrays will be interpreted as indices into the dimension with the same 
            index number. The indices may be of any numeric value type.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.#ctor(ILNumerics.Misc.ILDimension,ILNumerics.Storage.RangeSide,System.String[])">
            <summary>
            Creates ILRange from string array. Replace all occurences of "end" with corrensponding 
            dimension length. Replace all dimensions consisting only out off ":" with "1:end"
            </summary>
            <param name="dims">dimension specification</param>
            <param name="rng">String array with range specification (may contains "end")</param>
            <param name="side">determine, if this range is applied to left side or right side expressions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Map(System.Int32[],System.Int32[]@)">
            <summary>
            Evaluates (maps) index array on my range. 
            </summary>
            <param name="idx">int array indexing location inside this range</param>
            <param name="retIdx">(output) also return the result into array given</param>
            <returns>Mapped int[] array. It can be used for direct addressing the physical storage object.</returns>
            <remarks>retIdx must be at least of length m_nrDims. No check is made for that!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Copy">
            <summary>
            copy constructor
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.GetDimensions">
            <summary>
            Create trimmed ILDimension from indices in ILRange object
            </summary>
            <returns>new ILDimension object with the neccessary size to 
            hold all indices in this range</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.BuildSequentialArray">
            <summary>
            built a plain physical copy of the ranges stored in m_range in sequential order
            </summary>
            <returns>int array holding the whole m_range information in sequential order</returns>
            <remarks>This reordering is convinient for "marshaling" the multidimensional array to C.
            The format of the returned (1 dim.) array is: 
            <list type="bullet">
            <item>1 int : the number of dimensions</item>
            <item>X int : [nrOfDimensions] int holding the number of int for each dimension</item>
            <item>Y int : all the int values for each dimension after each other </item></list> 
            The overall size of the returned array is therefore: nrOfElements + nrOfDimensions + 1, 
            where nrOfElements is the sum of all elements in each dimension of m_range.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Spacing(System.Int32)">
            <summary>
            Distance between adjecent samples for this range
            </summary>
            <param name="dimIdx">dimension index to get spacing for</param>
            <returns>Spacing of samples inside the dimension if range would be applyied to 
            it or negative value if the range cannot produce an 
            "BLAS-able" reference storage.</returns>
            <remarks><para>For solid arrays, this always reflects the storage 
            structure of the array. I.e. 1  will be returned for the first 
            dimension (dimIdx = 0), for the second (dimIdx = 1) etc.</para> 
            <para>For reference storages this may or may not hold. It does 
            however only hold, if the range the array was constructed of 
            was regulary spaced.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Resize(System.Int32)">
            <summary>
            resize the number of dimensions this ILRange holds
            </summary>
            <param name="nrDims">new number of dimensions</param>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Expanding">
            <summary>
            true for left side ranges, if at least one dimension must be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.ExpandDimensions">
            <summary>
            array with sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.NumberOfDimensions">
            <summary>
            Get number of dimensions described by this ILRange
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.NumberOfElements">
            <summary>
            Number of elements addressed by this ILRange
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.nonSingletonDimensions">
            <summary>
            Number of non singleton Dimensions in this range object 
            </summary>
            <remarks>may be used to verify the space needed to store values referenced by this range</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.RangeArray">
            <summary>
            for performance reasons: give reference to internal array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32)">
            <summary>
            Index access for ILRange objects. Set/returns Index array for specifyied dimension.
            </summary>
            <remarks>the reference of the internal onject will be returned!</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32,System.Int32)">
            <summary>
            Index access for ILRange objects. returns the destIndex destination dimension for dimension specifyied by dimNr.
            </summary>
            <remarks>This acces is readonly!</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Limits">
            <summary>
            length of all dimensions of this range
            </summary>
            <remarks>This property is readonly. Keep in mind, it does not cache the values.</remarks>
        </member>
        <member name="T:ILNumerics.Storage.RegularSpacedList">
            <summary>
            helper class used to collect range entries for one dimension and 
            check for regular spacing while adding items
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_regularSpacing">
            <summary>
            internal field, stored the current value of regular spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_isRegularSpaced">
            <summary>
            internal field, stores flag on regular spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.RegularSpacedList.m_lastValue">
            <summary>
            internal field, keeps the last value for comparison
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.#ctor">
            <summary>
            Constructor creating emtpy ILRegularSpacedList
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.#ctor(System.Int32)">
            <summary>
            Constructor creating emtpy ILRegularSpacedList, given capacity
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.Add(System.Int32)">
            <summary>
            Add elements to this list
            </summary>
            <param name="value">new element</param>
        </member>
        <member name="M:ILNumerics.Storage.RegularSpacedList.Clear">
            <summary>
            reset / clear this list
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.RegularSpacedList.RegularSpacing">
            <summary>
            Give the spacing between elements of this list
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.RegularSpacedList.IsRegularSpaced">
            <summary>
            Get if all elements of this list are regulary spaced (in incoming order)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT">
            <summary>
            Wrapper for FFT interface using FFTW3 libs
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT.fftw_iodim">
            <summary>
            This struct is used to define (n-dimensional) transform sizes
            </summary>
            <remarks>This struct is only user in C-API. It is NOT used for the Fortran interface (i.e. it's not used in here)!!! </remarks>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.n">
            <summary>
            length of dimension
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.iS">
            <summary>
            input stride
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.oS">
            <summary>
            output stride
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayDebuggerProxy`1">
            <summary>
            This class is for internal use only. Do not instantiate from this class!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ILNumerics.Algorithms.SimpleAsyncSample">
            <summary>
            Sample class for user defined asynchronous algorithm
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILAsyncAlgorithm">
            <summary>
            base class for asynchronous algorithms
            </summary>
            <remarks>the abstract class implements an asynchronous algorithm class. It 
            fires events for all state changes and for progress information. Algorithms 
            derived from this class are capable of cancelling on user rewuest and to transparently 
            invoke event signals in the context of a calling System.Windows.Form - even from the internal 
            worker thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.GetResult">
            <summary>
            query algorithm result 
            </summary>
            <remarks><para>if the algorithm has not finished yet, the method waits for the thread to end. 
            If the algorithm has not started yet, null will be returned.</para>
            <para>You may query the state of the algorithm before calling this property, in order to prevent for the lock.</para>
            <para>Class designer of derived classes use this property to get the result object after an algorithm has finnished. The 
            return value is the return value of the abstract method <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)"/>. The type 
            of the result object depends on the actual implementation of the derived class.</para> </remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.SetProgress(System.Double,System.String)">
            <summary>
            Set the current progress of the algorithm. 
            </summary>
            <param name="progress">progress value. 0 &lt;= progress &lt;= 1.0</param>
            <param name="message">additional message.</param>
            <remarks><para>Calling this methos will fire an <see cref="E:ILNumerics.Algorithms.ILAsyncAlgorithm.ProgressChanged">ProgressChanged</see> event.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.#ctor(System.Windows.Forms.Control)">
            <summary>
            constructor creating a new ILAsyncAlgorithm object.
            </summary>
            <param name="control">if not null, events fired from this class will be 
            executed in the context of the thread owning the control. This is specifically 
            important for Windows.Forms.Control user interfaces, which require this in order to allow 
            direct manipulation of the control from inside the event handlers.</param>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Kill(System.Int32)">
            <summary>
            Kills this algorithm thread. 
            </summary>
            <param name="msec">waits for at most <paramref name="msec"/> milliseconds before returning</param>
            <returns>true: the thread has been successfully canceled. false: the thread has acknowledged the 
            cancellation request after msec milliseconds.</returns>
            <remarks><para>This method kills the algorithm thread without waiting for the algorithm to end. It 
            waits for at most msec milliseconds for the algorithm thread to respond and acknowledge the cancellation.</para>
            <para>You should always prefer the Cancel() method for the Kill() method. This gives the algorithm the chance 
            to exit cleanly.</para>
            <para>Calling this function will <b>NOT</b> call any StateChanged events.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Cancel(System.Int32)">
            <summary>
            Cancel the algorithm.
            </summary>
            <param name="timeout">waits for at most msec milliseconds after the cancelation request was published.</param>
            <returns>true: the algorithm has finished/ cancelled successfully. false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Suspend">
            <summary>
            halt the algorithm
            </summary>
            <returns>true if the algorithm was suspended successfully. False otherwise.</returns>
            <remarks>An algorithm which has suspended may later be resumed. Calling this 
            method on an algorithm which is not running will have no effect and return true.
            <para>This method will be called in the context of the algorithm caller thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Resume">
            <summary>
            Resume algorithm
            </summary>
            <remarks>If the algorithm is in state 'Suspended', calling this method will 
            resume execution for this thread. Calling this method for an algorithm which is 
            not in state 'Suspended' will have no effect.
            <para>This method will be called in the context of the algorithm caller thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)">
            <summary>
            this function serves as a placeholder for your derived class method wich does the actual computing 
            </summary>
            <remarks>Algorithm class designer must implement their algorithms in this function. Make sure, to 
            frequently check the CancelPending member of the base class, to determine if a cancellation was requested.
            <para>This method will be called in the context of the algorithm worker thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.CompileParameter">
            <summary>
            assemble parameter object i.o. to overgive to thread worker
            </summary>
            <returns>parameter object</returns>
            <remarks>This function must be implemented by algorithm class designers. It compiles all neccessary 
            input parameter for the computation function. The output of this method will later be the only input 
            parameter for the <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.AlgorithmFunction(System.Object)">AlgorithmFunction</see> 
            on a seperate thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnAlgorithmFinished">
            <summary>
            Additionally clean up after the algorithm has finished successfully.
            </summary>
            <remarks>This method will be called in the context of the algorithm worker thread.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.RunAsync">
            <summary>
            Start algorithm asynchronously
            </summary>
            <remarks>The algorithm will be started in a new thread. the state of the algorithm will be set to 'Running'.</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.RunSync">
            <summary>
            Execute this algorithm and wait for finish 
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnStateChanged">
            <summary>
            Fires the StateChanged event.
            </summary>
            <remarks><para>If the control parameter was given in the constructor of the class, the 
            event is fired in the context of the calling thread and not of the worker thread.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILAsyncAlgorithm.OnProgressChanged">
            <summary>
            Fires the ProgressChanged event.
            </summary>
            <remarks><para>If the control parameter was given in the constructor of the class, the 
            event is fired in the context of the calling thread and not of the worker thread.</para></remarks>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAsyncAlgorithm.StateChanged">
            <summary>
            fires whenever the state of the algorithm changes
            </summary>
        </member>
        <member name="E:ILNumerics.Algorithms.ILAsyncAlgorithm.ProgressChanged">
            <summary>
            fires if the progress of the algorithm changes 
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.State">
            <summary>
            The current state of the algorithm. One out of the enumeration <see cref="T:ILNumerics.ILAlgorithmState"/>.
            </summary>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.CancelPending">
            <summary>
            informs about a pending cancelation
            </summary>
            <remarks>
            <para>This will be set to true, if an algorithm is running and the user of the class called the <see cref="M:ILNumerics.Algorithms.ILAsyncAlgorithm.Cancel(System.Int32)"/> method.</para>
            <para>Class designer of derived classes should frequently check this property. If a cancellatioin was 
            requested, the algorithm should close as fast as possible. This is the 'good way' out of the algorithm. If the algorithm 
            does not respond fast enough, the user might kill the thread, which will not give the algorithm the chance to exit cleanly.</para></remarks>
        </member>
        <member name="P:ILNumerics.Algorithms.ILAsyncAlgorithm.Progress">
            <summary>
            current progress value.
            </summary>
        </member>
        <member name="M:ManagedLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.Double*,System.Int32,System.Double*,System.Int32,System.Double,System.Double*,System.Int32)">
            <summary>
            Performs one of the matrix-matrix operations
            C := alpha*op( A )*op( B ) + beta*C, where  op( X ) is one of
            op( X ) = X  or op( X ) = X', alpha and beta are scalars,
            and A, B and C are matrices, with op( A ) an m by k matrix, 
            op( B )  a  k by n matrix and  C an m by n matrix.
            </summary>
            <param name="transa">
            On entry, TRANSA specifies the form of op( A ) to be used in
            the matrix multiplication as follows:
            TRANSA = 'N' or 'n',  op( A ) = A.
            TRANSA = 'T' or 't',  op( A ) = A'.
            TRANSA = 'C' or 'c',  op( A ) = A'.
            </param>
            <param name="transb">
            On entry, TRANSB specifies the form of op( B ) to be used in
            the matrix multiplication as follows:
            TRANSB = 'N' or 'n',  op( B ) = B.
            TRANSB = 'T' or 't',  op( B ) = B'.
            TRANSB = 'C' or 'c',  op( B ) = B'.
            </param>
            <param name="m">
            On entry, M specifies the number of rows of the matrix
            op( A ) and of the matrix C. M  must be at least zero.
            </param>
            <param name="n">
            On entry,  N  specifies the number  of columns of the matrix
            op( B ) and the number of columns of the matrix C. N must be
            at least zero.
            </param>
            <param name="k">
            On entry,  K  specifies  the number of columns of the matrix
            op( A ) and the number of rows of the matrix op( B ). K must
            be at least  zero.
            </param>
            <param name="alpha">
            On entry, ALPHA specifies the scalar alpha.
            </param>
            <param name="a">
            Array of DIMENSION ( LDA, ka ), where ka is
            k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
            Before entry with  TRANSA = 'N' or 'n',  the leading  m by k 
            part of the array  A  must contain the matrix  A,  otherwise 
            the leading  k by m  part of the array  A  must contain  the 
            matrix A.
            </param>
            <param name="lda">
            On entry, LDA specifies the first dimension of A as declared
            in the calling (sub) program. When  TRANSA = 'N' or 'n' then 
            LDA must be at least  max( 1, m ), otherwise  LDA must be at 
            least  max( 1, k ). 
            </param>
            <param name="b">Array of DIMENSION ( LDB, kb ), where kb is 
            n  when  TRANSB = 'N' or 'n',  and is  k  otherwise. 
            Before entry with  TRANSB = 'N' or 'n',  the leading  k by n 
            part of the array  B  must contain the matrix  B,  otherwise 
            the leading  n by k  part of the array  B  must contain  the 
            matrix B.
            </param>
            <param name="ldb">
            On entry, LDB specifies the first dimension of B as declared 
            in the calling (sub) program. When  TRANSB = 'N' or 'n' then 
            LDB must be at least  max( 1, k ), otherwise  LDB must be at 
            least  max( 1, n ). 
            </param>
            <param name="beta">
            On entry,  BETA  specifies the scalar  beta.  When  BETA  is 
            supplied as zero then C need not be set on input. 
            </param>
            <param name="c__">
            Array of DIMENSION ( LDC, n ). 
            Before entry, the leading  m by n  part of the array  C must 
            contain the matrix  C,  except when  beta  is zero, in which 
            case C need not be set on entry. 
            On exit, the array  C  is overwritten by the  m by n  matrix 
            ( alpha*op( A )*op( B ) + beta*C ).
            </param>
            <param name="ldc">
            On entry, LDC specifies the first dimension of C as declared 
            in  the  calling  (sub)  program.   LDC  must  be  at  least 
            max( 1, m ). 
            </param>
            <returns>
            Zero.
            </returns>
            <remarks>
            Level 3 Blas routine -- Written on 8-February-1989. 
            Jack Dongarra, Argonne National Laboratory. 
            Iain Duff, AERE Harwell. 
            Jeremy Du Croz, Numerical Algorithms Group Ltd.
            Sven Hammarling, Numerical Algorithms Group Ltd.
            </remarks>
        </member>
    </members>
</doc>
